import type * as rdfjs from "@rdfjs/types";
import { sha256 } from "js-sha256";
import { DataFactory as dataFactory } from "n3";
import * as purify from "purify-ts";
import * as rdfLiteral from "rdf-literal";
import * as rdfjsResource from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import * as uuid from "uuid";
import { z as zod } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
export type EqualsResult = purify.Either<EqualsResult.Unequal, true>;

export namespace EqualsResult {
  export const Equal: EqualsResult = purify.Either.of<Unequal, true>(true);

  export function fromBooleanEqualsResult(
    left: any,
    right: any,
    equalsResult: boolean | EqualsResult,
  ): EqualsResult {
    if (typeof equalsResult !== "boolean") {
      return equalsResult;
    }

    if (equalsResult) {
      return Equal;
    }
    return purify.Left({
      left,
      right,
      type: "BooleanEquals",
    });
  }

  export type Unequal =
    | {
        readonly left: {
          readonly array: readonly any[];
          readonly element: any;
          readonly elementIndex: number;
        };
        readonly right: {
          readonly array: readonly any[];
          readonly unequals: readonly Unequal[];
        };
        readonly type: "ArrayElement";
      }
    | {
        readonly left: readonly any[];
        readonly right: readonly any[];
        readonly type: "ArrayLength";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "BooleanEquals";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "LeftError";
      }
    | {
        readonly right: any;
        readonly type: "LeftNull";
      }
    | {
        readonly left: bigint | boolean | number | string;
        readonly right: bigint | boolean | number | string;
        readonly type: "Primitive";
      }
    | {
        readonly left: object;
        readonly right: object;
        readonly propertyName: string;
        readonly propertyValuesUnequal: Unequal;
        readonly type: "Property";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "RightError";
      }
    | {
        readonly left: any;
        readonly type: "RightNull";
      };
}
/**
 * Compare two objects with equals(other: T): boolean methods and return an EqualsResult.
 */
export function booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): EqualsResult {
  return EqualsResult.fromBooleanEqualsResult(left, right, left.equals(right));
}
export function arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | EqualsResult,
): EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return purify.Left({
      left: leftArray,
      right: rightArray,
      type: "ArrayLength",
    });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return purify.Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: {
          array: rightArray,
          unequals: rightUnequals,
        },
        type: "ArrayElement",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return EqualsResult.Equal;
}
/**
 * Compare two values for strict equality (===), returning an EqualsResult rather than a boolean.
 */
export function strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): EqualsResult {
  return EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}
type UnwrapR<T> = T extends purify.Either<any, infer R> ? R : never;
export function maybeEquals<T>(
  leftMaybe: purify.Maybe<T>,
  rightMaybe: purify.Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | EqualsResult,
): EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return purify.Left({
      left: leftMaybe.unsafeCoerce(),
      type: "RightNull",
    });
  }

  if (rightMaybe.isJust()) {
    return purify.Left({
      right: rightMaybe.unsafeCoerce(),
      type: "LeftNull",
    });
  }

  return EqualsResult.Equal;
}
/**
 * Compare two Dates and return an EqualsResult.
 */
export function dateEquals(left: Date, right: Date): EqualsResult {
  return EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.getTime() === right.getTime(),
  );
}
export interface LabelStub {
  readonly identifier: rdfjs.BlankNode | rdfjs.NamedNode;
  readonly literalForm: purify.NonEmptyList<rdfjs.Literal>;
  readonly type: "LabelStub";
}

export namespace LabelStub {
  export function create(parameters: {
    readonly identifier: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    readonly literalForm: purify.NonEmptyList<rdfjs.Literal>;
  }): LabelStub {
    let identifier: rdfjs.BlankNode | rdfjs.NamedNode;
    if (typeof parameters.identifier === "object") {
      identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      identifier = parameters.identifier as never;
    }

    const literalForm = parameters.literalForm;
    const type = "LabelStub" as const;
    return { identifier, literalForm, type };
  }

  export function equals(left: LabelStub, right: LabelStub): EqualsResult {
    return booleanEquals(left.identifier, right.identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        ((left, right) => arrayEquals(left, right, booleanEquals))(
          left.literalForm,
          right.literalForm,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "literalForm",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(left.type, right.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      literalForm: purify.NonEmptyList<rdfjs.Literal>;
      type: "LabelStub";
    }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const literalForm = purify.NonEmptyList.fromArray(
      _jsonObject["literalForm"],
    )
      .unsafeCoerce()
      .map((_item) =>
        dataFactory.literal(
          _item["@value"],
          typeof _item["@language"] !== "undefined"
            ? _item["@language"]
            : typeof _item["@type"] !== "undefined"
              ? dataFactory.namedNode(_item["@type"])
              : undefined,
        ),
      );
    const type = "LabelStub" as const;
    return purify.Either.of({ identifier, literalForm, type });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LabelStub> {
    return LabelStub.propertiesFromJson(json);
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      literalForm: purify.NonEmptyList<rdfjs.Literal>;
      type: "LabelStub";
    }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode("http://www.w3.org/2008/05/skos-xl#Label"),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://www.w3.org/2008/05/skos-xl#Label",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _literalFormEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.NonEmptyList<rdfjs.Literal>
    > = purify.NonEmptyList.fromArray([
      ..._resource
        .values(
          dataFactory.namedNode(
            "http://www.w3.org/2008/05/skos-xl#literalForm",
          ),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .filter((_value) => {
              const _languageInOrDefault = _languageIn ?? [];
              if (_languageInOrDefault.length === 0) {
                return true;
              }
              const _valueLiteral = _value.toLiteral().toMaybe().extract();
              if (typeof _valueLiteral === "undefined") {
                return false;
              }
              return _languageInOrDefault.some(
                (_languageIn) => _languageIn === _valueLiteral.language,
              );
            })
            .head()
            .chain((_value) => _value.toLiteral())
            .toMaybe()
            .toList(),
        ),
    ]).toEither(
      new rdfjsResource.Resource.ValueError({
        focusResource: _resource,
        message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} is empty`,
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2008/05/skos-xl#literalForm",
        ),
      }),
    );
    if (_literalFormEither.isLeft()) {
      return _literalFormEither;
    }

    const literalForm = _literalFormEither.unsafeCoerce();
    const type = "LabelStub" as const;
    return purify.Either.of({ identifier, literalForm, type });
  }

  export function fromRdf(
    parameters: Parameters<typeof LabelStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, LabelStub> {
    return LabelStub.propertiesFromRdf(parameters);
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://www.w3.org/2008/05/skos-xl#Label",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/literalForm`, type: "Control" },
        {
          rule: {
            condition: {
              schema: { const: "LabelStub" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "LabelStub",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      literalForm: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array()
        .nonempty()
        .min(1),
      type: zod.literal("LabelStub"),
    });
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_labelStub: LabelStub, _hasher: HasherT): HasherT {
    for (const _item0 of _labelStub.literalForm) {
      _hasher.update(_item0.datatype.value);
      _hasher.update(_item0.language);
      _hasher.update(_item0.termType);
      _hasher.update(_item0.value);
    }

    return _hasher;
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LabelStub.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LabelStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LabelStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("labelStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "labelStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2008/05/skos-xl#literalForm",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("labelStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "labelStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://www.w3.org/2008/05/skos-xl#Label",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/2008/05/skos-xl#literalForm",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }

  export function toJson(_labelStub: LabelStub): {
    readonly "@id": string;
    readonly literalForm: purify.NonEmptyList<{
      readonly "@language": string | undefined;
      readonly "@type": string | undefined;
      readonly "@value": string;
    }>;
    readonly type: "LabelStub";
  } {
    return JSON.parse(
      JSON.stringify({
        "@id":
          _labelStub.identifier.termType === "BlankNode"
            ? `_:${_labelStub.identifier.value}`
            : _labelStub.identifier.value,
        literalForm: _labelStub.literalForm.map((_item) => ({
          "@language": _item.language.length > 0 ? _item.language : undefined,
          "@type":
            _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
              ? _item.datatype.value
              : undefined,
          "@value": _item.value,
        })),
        type: _labelStub.type,
      } satisfies ReturnType<typeof LabelStub.toJson>),
    );
  }

  export function toRdf(
    _labelStub: LabelStub,
    {
      ignoreRdfType,
      mutateGraph,
      resourceSet,
    }: {
      ignoreRdfType?: boolean;
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    const _resource = resourceSet.mutableResource({
      identifier: _labelStub.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://www.w3.org/2008/05/skos-xl#Label",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2008/05/skos-xl#literalForm"),
      _labelStub.literalForm.map((_item) => _item),
    );
    return _resource;
  }
}
export interface KosResourceStub {
  readonly identifier: rdfjs.NamedNode;
  readonly prefLabel: readonly rdfjs.Literal[];
  readonly prefLabelXl: readonly LabelStub[];
  readonly type: "ConceptSchemeStub" | "ConceptStub";
}

export namespace KosResourceStub {
  export function create(parameters: {
    readonly identifier: rdfjs.NamedNode | string;
    readonly prefLabel?: readonly rdfjs.Literal[];
    readonly prefLabelXl?: readonly LabelStub[];
  }): Omit<KosResourceStub, "type"> {
    let identifier: rdfjs.NamedNode;
    if (typeof parameters.identifier === "object") {
      identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      identifier = parameters.identifier as never;
    }

    let prefLabel: readonly rdfjs.Literal[];
    if (typeof parameters.prefLabel === "undefined") {
      prefLabel = [];
    } else if (Array.isArray(parameters.prefLabel)) {
      prefLabel = parameters.prefLabel;
    } else {
      prefLabel = parameters.prefLabel as never;
    }

    let prefLabelXl: readonly LabelStub[];
    if (typeof parameters.prefLabelXl === "undefined") {
      prefLabelXl = [];
    } else if (Array.isArray(parameters.prefLabelXl)) {
      prefLabelXl = parameters.prefLabelXl;
    } else {
      prefLabelXl = parameters.prefLabelXl as never;
    }

    return { identifier, prefLabel, prefLabelXl };
  }

  export function equals(
    left: KosResourceStub,
    right: KosResourceStub,
  ): EqualsResult {
    return booleanEquals(left.identifier, right.identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: left,
        right: right,
        propertyName: "identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        ((left, right) => arrayEquals(left, right, booleanEquals))(
          left.prefLabel,
          right.prefLabel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "prefLabel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => arrayEquals(left, right, LabelStub.equals))(
          left.prefLabelXl,
          right.prefLabelXl,
        ).mapLeft((propertyValuesUnequal) => ({
          left: left,
          right: right,
          propertyName: "prefLabelXl",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(left.type, right.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: left,
            right: right,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      prefLabel: readonly rdfjs.Literal[];
      prefLabelXl: readonly LabelStub[];
    }
  > {
    const _jsonSafeParseResult =
      kosResourceStubJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const prefLabel = _jsonObject["prefLabel"].map((_item) =>
      dataFactory.literal(
        _item["@value"],
        typeof _item["@language"] !== "undefined"
          ? _item["@language"]
          : typeof _item["@type"] !== "undefined"
            ? dataFactory.namedNode(_item["@type"])
            : undefined,
      ),
    );
    const prefLabelXl = _jsonObject["prefLabelXl"].map((_item) =>
      LabelStub.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ identifier, prefLabel, prefLabelXl });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      prefLabel: readonly rdfjs.Literal[];
      prefLabelXl: readonly LabelStub[];
    }
  > {
    const identifier = _resource.identifier;
    const _prefLabelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly rdfjs.Literal[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode(
            "http://www.w3.org/2004/02/skos/core#prefLabel",
          ),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .filter((_value) => {
              const _languageInOrDefault = _languageIn ?? [];
              if (_languageInOrDefault.length === 0) {
                return true;
              }
              const _valueLiteral = _value.toLiteral().toMaybe().extract();
              if (typeof _valueLiteral === "undefined") {
                return false;
              }
              return _languageInOrDefault.some(
                (_languageIn) => _languageIn === _valueLiteral.language,
              );
            })
            .head()
            .chain((_value) => _value.toLiteral())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_prefLabelEither.isLeft()) {
      return _prefLabelEither;
    }

    const prefLabel = _prefLabelEither.unsafeCoerce();
    const _prefLabelXlEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly LabelStub[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode("http://www.w3.org/2008/05/skos-xl#prefLabel"),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              LabelStub.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_prefLabelXlEither.isLeft()) {
      return _prefLabelXlEither;
    }

    const prefLabelXl = _prefLabelXlEither.unsafeCoerce();
    return purify.Either.of({ identifier, prefLabel, prefLabelXl });
  }

  export function jsonSchema() {
    return zodToJsonSchema(kosResourceStubJsonZodSchema());
  }

  export function kosResourceStubJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/prefLabel`, type: "Control" },
        LabelStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/prefLabelXl`,
        }),
        {
          rule: {
            condition: {
              schema: { const: "KosResourceStub" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "KosResourceStub",
      type: "Group",
    };
  }

  export function kosResourceStubJsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      prefLabel: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array(),
      prefLabelXl: LabelStub.jsonZodSchema().array(),
      type: zod.enum(["ConceptSchemeStub", "ConceptStub"]),
    });
  }

  export function hashKosResourceStub<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_kosResourceStub: KosResourceStub, _hasher: HasherT): HasherT {
    for (const _item0 of _kosResourceStub.prefLabel) {
      _hasher.update(_item0.datatype.value);
      _hasher.update(_item0.language);
      _hasher.update(_item0.termType);
      _hasher.update(_item0.value);
    }

    for (const _item0 of _kosResourceStub.prefLabelXl) {
      LabelStub.hash(_item0, _hasher);
    }

    return _hasher;
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        KosResourceStub.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        KosResourceStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      KosResourceStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("kosResourceStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "kosResourceStub");
    return [
      {
        object: dataFactory.variable!(`${variablePrefix}PrefLabel`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2004/02/skos/core#prefLabel",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}PrefLabelXl`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2008/05/skos-xl#prefLabel",
        ),
        subject,
      },
      ...LabelStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PrefLabelXl`),
        variablePrefix: `${variablePrefix}PrefLabelXl`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("kosResourceStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "kosResourceStub");
    return [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}PrefLabel`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2004/02/skos/core#prefLabel",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}PrefLabelXl`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2008/05/skos-xl#prefLabel",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...LabelStub.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}PrefLabelXl`),
            variablePrefix: `${variablePrefix}PrefLabelXl`,
          }),
        ],
        type: "optional",
      },
    ];
  }

  export function toJson(_kosResourceStub: KosResourceStub): {
    readonly "@id": string;
    readonly prefLabel: readonly {
      readonly "@language": string | undefined;
      readonly "@type": string | undefined;
      readonly "@value": string;
    }[];
    readonly prefLabelXl: readonly ReturnType<typeof LabelStub.toJson>[];
    readonly type: "ConceptSchemeStub" | "ConceptStub";
  } {
    return JSON.parse(
      JSON.stringify({
        "@id": _kosResourceStub.identifier.value,
        prefLabel: _kosResourceStub.prefLabel.map((_item) => ({
          "@language": _item.language.length > 0 ? _item.language : undefined,
          "@type":
            _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
              ? _item.datatype.value
              : undefined,
          "@value": _item.value,
        })),
        prefLabelXl: _kosResourceStub.prefLabelXl.map((_item) =>
          LabelStub.toJson(_item),
        ),
        type: _kosResourceStub.type,
      } satisfies ReturnType<typeof KosResourceStub.toJson>),
    );
  }

  export function toRdf(
    _kosResourceStub: KosResourceStub,
    {
      mutateGraph,
      resourceSet,
    }: {
      ignoreRdfType?: boolean;
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: _kosResourceStub.identifier,
      mutateGraph,
    });
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#prefLabel"),
      _kosResourceStub.prefLabel.map((_item) => _item),
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2008/05/skos-xl#prefLabel"),
      _kosResourceStub.prefLabelXl.map((_item) =>
        LabelStub.toRdf(_item, {
          mutateGraph: mutateGraph,
          resourceSet: resourceSet,
        }),
      ),
    );
    return _resource;
  }
}
/**
 * entity
 */
abstract class Entity {
  abstract readonly identifier: rdfjs.NamedNode;
  abstract readonly type:
    | "Answer"
    | "BooleanValue"
    | "CategoricalQuestion"
    | "CategoricalValue"
    | "Claim"
    | "CompletionMessage"
    | "ConceptSchemeConceptSelector"
    | "ConceptSchemeTopConceptSelector"
    | "Corpus"
    | "CorpusDeletion"
    | "CorpusDeletionInput"
    | "DichotomousQuestion"
    | "Document"
    | "DocumentDeletion"
    | "DocumentDeletionInput"
    | "DocumentTitle"
    | "EnumeratedConceptSelector"
    | "Exception"
    | "Image"
    | "Instruction"
    | "LanguageModelFamily"
    | "LanguageModelInvocation"
    | "LanguageModelInvocationInput"
    | "LanguageModelInvocationOutput"
    | "LanguageModelSpecification"
    | "NarrowerConceptSelector"
    | "NarrowerTransitiveConceptSelector"
    | "PostWorkflowExecutionEvent"
    | "PostWorkflowStepExecutionEvent"
    | "PreWorkflowExecutionEvent"
    | "PreWorkflowStepExecutionEvent"
    | "Prompt"
    | "PromptConstruction"
    | "PromptConstructionInput"
    | "PromptConstructionOutput"
    | "PromptLiteralInputValue"
    | "PromptMessage"
    | "PromptMessageTemplate"
    | "PromptSparqlSelectInputValue"
    | "PromptTemplate"
    | "QuestionAdministration"
    | "QuestionAdministrationInput"
    | "QuestionAdministrationOutput"
    | "QuestionAdministrationSubProcesses"
    | "Questionnaire"
    | "QuestionnaireAdministration"
    | "QuestionnaireAdministrationInput"
    | "QuestionnaireAdministrationOutput"
    | "QuestionnaireAdministrationSubProcesses"
    | "RealValue"
    | "RealValuedQuestion"
    | "TextQuestion"
    | "TextValue"
    | "TextualEntity"
    | "ValueExtraction"
    | "ValueExtractionInput"
    | "ValueExtractionOutput"
    | "Workflow"
    | "WorkflowDeletion"
    | "WorkflowDeletionInput"
    | "WorkflowExecution"
    | "WorkflowExecutionInput"
    | "WorkflowExecutionOutput"
    | "WorkflowExecutionStub"
    | "WorkflowExecutionSubProcesses"
    | "WorkflowQuestionnaireStep"
    | "WorkflowQuestionnaireStepExecution"
    | "WorkflowQuestionnaireStepExecutionInput"
    | "WorkflowQuestionnaireStepExecutionOutput"
    | "WorkflowQuestionnaireStepExecutionSubProcesses";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(_parameters: object) {}

  equals(other: Entity): EqualsResult {
    return booleanEquals(this.identifier, other.identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  toJson(): {
    readonly "@id": string;
    readonly type:
      | "Answer"
      | "BooleanValue"
      | "CategoricalQuestion"
      | "CategoricalValue"
      | "Claim"
      | "CompletionMessage"
      | "ConceptSchemeConceptSelector"
      | "ConceptSchemeTopConceptSelector"
      | "Corpus"
      | "CorpusDeletion"
      | "CorpusDeletionInput"
      | "DichotomousQuestion"
      | "Document"
      | "DocumentDeletion"
      | "DocumentDeletionInput"
      | "DocumentTitle"
      | "EnumeratedConceptSelector"
      | "Exception"
      | "Image"
      | "Instruction"
      | "LanguageModelFamily"
      | "LanguageModelInvocation"
      | "LanguageModelInvocationInput"
      | "LanguageModelInvocationOutput"
      | "LanguageModelSpecification"
      | "NarrowerConceptSelector"
      | "NarrowerTransitiveConceptSelector"
      | "PostWorkflowExecutionEvent"
      | "PostWorkflowStepExecutionEvent"
      | "PreWorkflowExecutionEvent"
      | "PreWorkflowStepExecutionEvent"
      | "Prompt"
      | "PromptConstruction"
      | "PromptConstructionInput"
      | "PromptConstructionOutput"
      | "PromptLiteralInputValue"
      | "PromptMessage"
      | "PromptMessageTemplate"
      | "PromptSparqlSelectInputValue"
      | "PromptTemplate"
      | "QuestionAdministration"
      | "QuestionAdministrationInput"
      | "QuestionAdministrationOutput"
      | "QuestionAdministrationSubProcesses"
      | "Questionnaire"
      | "QuestionnaireAdministration"
      | "QuestionnaireAdministrationInput"
      | "QuestionnaireAdministrationOutput"
      | "QuestionnaireAdministrationSubProcesses"
      | "RealValue"
      | "RealValuedQuestion"
      | "TextQuestion"
      | "TextValue"
      | "TextualEntity"
      | "ValueExtraction"
      | "ValueExtractionInput"
      | "ValueExtractionOutput"
      | "Workflow"
      | "WorkflowDeletion"
      | "WorkflowDeletionInput"
      | "WorkflowExecution"
      | "WorkflowExecutionInput"
      | "WorkflowExecutionOutput"
      | "WorkflowExecutionStub"
      | "WorkflowExecutionSubProcesses"
      | "WorkflowQuestionnaireStep"
      | "WorkflowQuestionnaireStepExecution"
      | "WorkflowQuestionnaireStepExecutionInput"
      | "WorkflowQuestionnaireStepExecutionOutput"
      | "WorkflowQuestionnaireStepExecutionSubProcesses";
  } {
    return JSON.parse(
      JSON.stringify({
        "@id": this.identifier.value,
        type: this.type,
      } satisfies ReturnType<Entity["toJson"]>),
    );
  }

  toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace Entity {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<zod.ZodError, { identifier: rdfjs.NamedNode }> {
    const _jsonSafeParseResult = entityJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode }
  > {
    const identifier = _resource.identifier;
    return purify.Either.of({ identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(entityJsonZodSchema());
  }

  export function entityJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Entity" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "entity",
      type: "Group",
    };
  }

  export function entityJsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      type: zod.enum([
        "Answer",
        "BooleanValue",
        "CategoricalQuestion",
        "CategoricalValue",
        "Claim",
        "CompletionMessage",
        "ConceptSchemeConceptSelector",
        "ConceptSchemeTopConceptSelector",
        "Corpus",
        "CorpusDeletion",
        "CorpusDeletionInput",
        "DichotomousQuestion",
        "Document",
        "DocumentDeletion",
        "DocumentDeletionInput",
        "DocumentTitle",
        "EnumeratedConceptSelector",
        "Exception",
        "Image",
        "Instruction",
        "LanguageModelFamily",
        "LanguageModelInvocation",
        "LanguageModelInvocationInput",
        "LanguageModelInvocationOutput",
        "LanguageModelSpecification",
        "NarrowerConceptSelector",
        "NarrowerTransitiveConceptSelector",
        "PostWorkflowExecutionEvent",
        "PostWorkflowStepExecutionEvent",
        "PreWorkflowExecutionEvent",
        "PreWorkflowStepExecutionEvent",
        "Prompt",
        "PromptConstruction",
        "PromptConstructionInput",
        "PromptConstructionOutput",
        "PromptLiteralInputValue",
        "PromptMessage",
        "PromptMessageTemplate",
        "PromptSparqlSelectInputValue",
        "PromptTemplate",
        "QuestionAdministration",
        "QuestionAdministrationInput",
        "QuestionAdministrationOutput",
        "QuestionAdministrationSubProcesses",
        "Questionnaire",
        "QuestionnaireAdministration",
        "QuestionnaireAdministrationInput",
        "QuestionnaireAdministrationOutput",
        "QuestionnaireAdministrationSubProcesses",
        "RealValue",
        "RealValuedQuestion",
        "TextQuestion",
        "TextValue",
        "TextualEntity",
        "ValueExtraction",
        "ValueExtractionInput",
        "ValueExtractionOutput",
        "Workflow",
        "WorkflowDeletion",
        "WorkflowDeletionInput",
        "WorkflowExecution",
        "WorkflowExecutionInput",
        "WorkflowExecutionOutput",
        "WorkflowExecutionStub",
        "WorkflowExecutionSubProcesses",
        "WorkflowQuestionnaireStep",
        "WorkflowQuestionnaireStepExecution",
        "WorkflowQuestionnaireStepExecutionInput",
        "WorkflowQuestionnaireStepExecutionOutput",
        "WorkflowQuestionnaireStepExecutionSubProcesses",
      ]),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Entity.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Entity.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Entity.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function sparqlWherePatterns(_parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
export abstract class ProcessSubProcesses extends Entity {
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "QuestionAdministrationSubProcesses"
    | "QuestionnaireAdministrationSubProcesses"
    | "WorkflowExecutionSubProcesses"
    | "WorkflowQuestionnaireStepExecutionSubProcesses";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(parameters: ConstructorParameters<typeof Entity>[0]) {
    super(parameters);
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ProcessSubProcesses {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      processSubProcessesJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Entity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromRdf>
    >
  > {
    const _super0Either = Entity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(processSubProcessesJsonZodSchema());
  }

  export function processSubProcessesJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [Entity.entityJsonUiSchema({ scopePrefix })],
      label: "ProcessSubProcesses",
      type: "Group",
    };
  }

  export function processSubProcessesJsonZodSchema() {
    return Entity.entityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.enum([
          "QuestionAdministrationSubProcesses",
          "QuestionnaireAdministrationSubProcesses",
          "WorkflowExecutionSubProcesses",
          "WorkflowQuestionnaireStepExecutionSubProcesses",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ProcessSubProcesses.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ProcessSubProcesses.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ProcessSubProcesses.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("processSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "processSubProcesses");
    return [
      ...Entity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("processSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "processSubProcesses");
    return [
      ...Entity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }
}
export class WorkflowQuestionnaireStepExecutionSubProcesses extends ProcessSubProcesses {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly questionnaireAdministration: purify.Maybe<QuestionnaireAdministration>;
  override readonly type = "WorkflowQuestionnaireStepExecutionSubProcesses";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly questionnaireAdministration?:
        | QuestionnaireAdministration
        | purify.Maybe<QuestionnaireAdministration>;
    } & ConstructorParameters<typeof ProcessSubProcesses>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.questionnaireAdministration)) {
      this.questionnaireAdministration = parameters.questionnaireAdministration;
    } else if (
      typeof parameters.questionnaireAdministration === "object" &&
      parameters.questionnaireAdministration instanceof
        QuestionnaireAdministration
    ) {
      this.questionnaireAdministration = purify.Maybe.of(
        parameters.questionnaireAdministration,
      );
    } else if (typeof parameters.questionnaireAdministration === "undefined") {
      this.questionnaireAdministration = purify.Maybe.empty();
    } else {
      this.questionnaireAdministration =
        parameters.questionnaireAdministration as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(
    other: WorkflowQuestionnaireStepExecutionSubProcesses,
  ): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.questionnaireAdministration,
          other.questionnaireAdministration,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "questionnaireAdministration",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.questionnaireAdministration.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    return _hasher;
  }

  override toJson(): {
    readonly questionnaireAdministration:
      | ReturnType<QuestionnaireAdministration["toJson"]>
      | undefined;
  } & ReturnType<ProcessSubProcesses["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        questionnaireAdministration: this.questionnaireAdministration
          .map((_item) => _item.toJson())
          .extract(),
      } satisfies ReturnType<
        WorkflowQuestionnaireStepExecutionSubProcesses["toJson"]
      >),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionSubProcesses",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#questionnaireAdministration",
      ),
      this.questionnaireAdministration.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowQuestionnaireStepExecutionSubProcesses {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      questionnaireAdministration: purify.Maybe<QuestionnaireAdministration>;
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowQuestionnaireStepExecutionSubProcessesJsonZodSchema().safeParse(
        _json,
      );
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessSubProcesses.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const questionnaireAdministration = purify.Maybe.fromNullable(
      _jsonObject["questionnaireAdministration"],
    ).map((_item) =>
      QuestionnaireAdministration.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ..._super0,
      identifier,
      questionnaireAdministration,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<
    zod.ZodError,
    WorkflowQuestionnaireStepExecutionSubProcesses
  > {
    return WorkflowQuestionnaireStepExecutionSubProcesses.propertiesFromJson(
      json,
    ).map(
      (properties) =>
        new WorkflowQuestionnaireStepExecutionSubProcesses(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      questionnaireAdministration: purify.Maybe<QuestionnaireAdministration>;
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromRdf>>
  > {
    const _super0Either = ProcessSubProcesses.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionSubProcesses",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionSubProcesses",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _questionnaireAdministrationEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<QuestionnaireAdministration>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#questionnaireAdministration",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          QuestionnaireAdministration.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_questionnaireAdministrationEither.isLeft()) {
      return _questionnaireAdministrationEither;
    }

    const questionnaireAdministration =
      _questionnaireAdministrationEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      questionnaireAdministration,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof WorkflowQuestionnaireStepExecutionSubProcesses.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowQuestionnaireStepExecutionSubProcesses
  > {
    return WorkflowQuestionnaireStepExecutionSubProcesses.propertiesFromRdf(
      parameters,
    ).map(
      (properties) =>
        new WorkflowQuestionnaireStepExecutionSubProcesses(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionSubProcesses",
  );

  export function jsonSchema() {
    return zodToJsonSchema(
      workflowQuestionnaireStepExecutionSubProcessesJsonZodSchema(),
    );
  }

  export function workflowQuestionnaireStepExecutionSubProcessesJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessSubProcesses.processSubProcessesJsonUiSchema({ scopePrefix }),
        QuestionnaireAdministration.questionnaireAdministrationJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/questionnaireAdministration`,
        }),
      ],
      label: "WorkflowQuestionnaireStepExecutionSubProcesses",
      type: "Group",
    };
  }

  export function workflowQuestionnaireStepExecutionSubProcessesJsonZodSchema() {
    return ProcessSubProcesses.processSubProcessesJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        questionnaireAdministration:
          QuestionnaireAdministration.questionnaireAdministrationJsonZodSchema().optional(),
        type: zod.literal("WorkflowQuestionnaireStepExecutionSubProcesses"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowQuestionnaireStepExecutionSubProcesses.sparqlConstructTemplateTriples(
          { ignoreRdfType, subject },
        ),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowQuestionnaireStepExecutionSubProcesses.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowQuestionnaireStepExecutionSubProcesses.sparqlConstructQuery(
        parameters,
      ),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecutionSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecutionSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(
          `${variablePrefix}QuestionnaireAdministration`,
        ),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaireAdministration",
        ),
        subject,
      },
      ...QuestionnaireAdministration.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}QuestionnaireAdministration`,
        ),
        variablePrefix: `${variablePrefix}QuestionnaireAdministration`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecutionSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecutionSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionSubProcesses",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}QuestionnaireAdministration`,
                ),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#questionnaireAdministration",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...QuestionnaireAdministration.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${variablePrefix}QuestionnaireAdministration`,
            ),
            variablePrefix: `${variablePrefix}QuestionnaireAdministration`,
          }),
        ],
        type: "optional",
      },
    ];
  }
}
export abstract class ProcessOutput extends Entity {
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "LanguageModelInvocationOutput"
    | "PromptConstructionOutput"
    | "QuestionAdministrationOutput"
    | "QuestionnaireAdministrationOutput"
    | "ValueExtractionOutput"
    | "WorkflowExecutionOutput"
    | "WorkflowQuestionnaireStepExecutionOutput";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(parameters: ConstructorParameters<typeof Entity>[0]) {
    super(parameters);
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ProcessOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = processOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Entity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromRdf>
    >
  > {
    const _super0Either = Entity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(processOutputJsonZodSchema());
  }

  export function processOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [Entity.entityJsonUiSchema({ scopePrefix })],
      label: "ProcessOutput",
      type: "Group",
    };
  }

  export function processOutputJsonZodSchema() {
    return Entity.entityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.enum([
          "LanguageModelInvocationOutput",
          "PromptConstructionOutput",
          "QuestionAdministrationOutput",
          "QuestionnaireAdministrationOutput",
          "ValueExtractionOutput",
          "WorkflowExecutionOutput",
          "WorkflowQuestionnaireStepExecutionOutput",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ProcessOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ProcessOutput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ProcessOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("processOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "processOutput");
    return [
      ...Entity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("processOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "processOutput");
    return [
      ...Entity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }
}
export class WorkflowQuestionnaireStepExecutionOutput extends ProcessOutput {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "WorkflowQuestionnaireStepExecutionOutput";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionOutput",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowQuestionnaireStepExecutionOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      workflowQuestionnaireStepExecutionOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowQuestionnaireStepExecutionOutput> {
    return WorkflowQuestionnaireStepExecutionOutput.propertiesFromJson(
      json,
    ).map(
      (properties) => new WorkflowQuestionnaireStepExecutionOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionOutput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof WorkflowQuestionnaireStepExecutionOutput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowQuestionnaireStepExecutionOutput
  > {
    return WorkflowQuestionnaireStepExecutionOutput.propertiesFromRdf(
      parameters,
    ).map(
      (properties) => new WorkflowQuestionnaireStepExecutionOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(
      workflowQuestionnaireStepExecutionOutputJsonZodSchema(),
    );
  }

  export function workflowQuestionnaireStepExecutionOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ProcessOutput.processOutputJsonUiSchema({ scopePrefix })],
      label: "WorkflowQuestionnaireStepExecutionOutput",
      type: "Group",
    };
  }

  export function workflowQuestionnaireStepExecutionOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("WorkflowQuestionnaireStepExecutionOutput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowQuestionnaireStepExecutionOutput.sparqlConstructTemplateTriples(
          { ignoreRdfType, subject },
        ),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowQuestionnaireStepExecutionOutput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowQuestionnaireStepExecutionOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecutionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecutionOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecutionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecutionOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export abstract class ProcessInput extends Entity {
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "CorpusDeletionInput"
    | "DocumentDeletionInput"
    | "LanguageModelInvocationInput"
    | "PromptConstructionInput"
    | "QuestionAdministrationInput"
    | "QuestionnaireAdministrationInput"
    | "ValueExtractionInput"
    | "WorkflowDeletionInput"
    | "WorkflowExecutionInput"
    | "WorkflowQuestionnaireStepExecutionInput";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(parameters: ConstructorParameters<typeof Entity>[0]) {
    super(parameters);
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ProcessInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = processInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Entity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromRdf>
    >
  > {
    const _super0Either = Entity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(processInputJsonZodSchema());
  }

  export function processInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [Entity.entityJsonUiSchema({ scopePrefix })],
      label: "ProcessInput",
      type: "Group",
    };
  }

  export function processInputJsonZodSchema() {
    return Entity.entityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.enum([
          "CorpusDeletionInput",
          "DocumentDeletionInput",
          "LanguageModelInvocationInput",
          "PromptConstructionInput",
          "QuestionAdministrationInput",
          "QuestionnaireAdministrationInput",
          "ValueExtractionInput",
          "WorkflowDeletionInput",
          "WorkflowExecutionInput",
          "WorkflowQuestionnaireStepExecutionInput",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ProcessInput.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ProcessInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ProcessInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("processInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "processInput");
    return [
      ...Entity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("processInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "processInput");
    return [
      ...Entity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }
}
export class WorkflowQuestionnaireStepExecutionInput extends ProcessInput {
  readonly document: DocumentStub;
  private _identifier: rdfjs.NamedNode | undefined;
  readonly step: WorkflowQuestionnaireStep;
  override readonly type = "WorkflowQuestionnaireStepExecutionInput";

  constructor(
    parameters: {
      readonly document: DocumentStub;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly step: WorkflowQuestionnaireStep;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.document = parameters.document;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.step = parameters.step;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(
    other: WorkflowQuestionnaireStepExecutionInput,
  ): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.document,
          other.document,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "document",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(this.step, other.step).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "step",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.document.hash(_hasher);
    this.step.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly document: ReturnType<DocumentStub["toJson"]>;
    readonly step: ReturnType<WorkflowQuestionnaireStep["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        document: this.document.toJson(),
        step: this.step.toJson(),
      } satisfies ReturnType<
        WorkflowQuestionnaireStepExecutionInput["toJson"]
      >),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#document",
      ),
      this.document.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#workflowQuestionnaireStep",
      ),
      this.step.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowQuestionnaireStepExecutionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      step: WorkflowQuestionnaireStep;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowQuestionnaireStepExecutionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const document = DocumentStub.fromJson(
      _jsonObject["document"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const step = WorkflowQuestionnaireStep.fromJson(
      _jsonObject["step"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, document, identifier, step });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowQuestionnaireStepExecutionInput> {
    return WorkflowQuestionnaireStepExecutionInput.propertiesFromJson(json).map(
      (properties) => new WorkflowQuestionnaireStepExecutionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      step: WorkflowQuestionnaireStep;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionInput",
          ),
        }),
      );
    }

    const _documentEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_documentEither.isLeft()) {
      return _documentEither;
    }

    const document = _documentEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _stepEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowQuestionnaireStep
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflowQuestionnaireStep",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowQuestionnaireStep.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_stepEither.isLeft()) {
      return _stepEither;
    }

    const step = _stepEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, document, identifier, step });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof WorkflowQuestionnaireStepExecutionInput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowQuestionnaireStepExecutionInput
  > {
    return WorkflowQuestionnaireStepExecutionInput.propertiesFromRdf(
      parameters,
    ).map(
      (properties) => new WorkflowQuestionnaireStepExecutionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(
      workflowQuestionnaireStepExecutionInputJsonZodSchema(),
    );
  }

  export function workflowQuestionnaireStepExecutionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        DocumentStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/document`,
        }),
        WorkflowQuestionnaireStep.workflowQuestionnaireStepJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/step`,
        }),
      ],
      label: "WorkflowQuestionnaireStepExecutionInput",
      type: "Group",
    };
  }

  export function workflowQuestionnaireStepExecutionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        document: DocumentStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        step: WorkflowQuestionnaireStep.workflowQuestionnaireStepJsonZodSchema(),
        type: zod.literal("WorkflowQuestionnaireStepExecutionInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowQuestionnaireStepExecutionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowQuestionnaireStepExecutionInput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowQuestionnaireStepExecutionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecutionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecutionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Document`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        subject,
      },
      ...DocumentStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Step`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflowQuestionnaireStep",
        ),
        subject,
      },
      ...WorkflowQuestionnaireStep.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Step`),
        variablePrefix: `${variablePrefix}Step`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecutionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecutionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecutionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Document`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#document",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Step`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#workflowQuestionnaireStep",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowQuestionnaireStep.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Step`),
        variablePrefix: `${variablePrefix}Step`,
      }),
    ];
  }
}
export abstract class Process extends Entity {
  readonly endedAtTime: purify.Maybe<Date>;
  abstract override readonly identifier: rdfjs.NamedNode;
  readonly startedAtTime: Date;
  abstract override readonly type:
    | "CorpusDeletion"
    | "DocumentDeletion"
    | "LanguageModelInvocation"
    | "PromptConstruction"
    | "QuestionAdministration"
    | "QuestionnaireAdministration"
    | "ValueExtraction"
    | "WorkflowDeletion"
    | "WorkflowExecution"
    | "WorkflowExecutionStub"
    | "WorkflowQuestionnaireStepExecution";

  constructor(
    parameters: {
      readonly endedAtTime?: Date | purify.Maybe<Date>;
      readonly startedAtTime: Date;
    } & ConstructorParameters<typeof Entity>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.endedAtTime)) {
      this.endedAtTime = parameters.endedAtTime;
    } else if (
      typeof parameters.endedAtTime === "object" &&
      parameters.endedAtTime instanceof Date
    ) {
      this.endedAtTime = purify.Maybe.of(parameters.endedAtTime);
    } else if (typeof parameters.endedAtTime === "undefined") {
      this.endedAtTime = purify.Maybe.empty();
    } else {
      this.endedAtTime = parameters.endedAtTime as never;
    }

    this.startedAtTime = parameters.startedAtTime;
  }

  override equals(other: Process): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => maybeEquals(left, right, dateEquals))(
          this.endedAtTime,
          other.endedAtTime,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "endedAtTime",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        dateEquals(this.startedAtTime, other.startedAtTime).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "startedAtTime",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.endedAtTime.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    _hasher.update(this.startedAtTime.toISOString());
    return _hasher;
  }

  override toJson(): {
    readonly endedAtTime: string | undefined;
    readonly startedAtTime: string;
  } & ReturnType<Entity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        endedAtTime: this.endedAtTime
          .map((_item) => _item.toISOString())
          .extract(),
        startedAtTime: this.startedAtTime.toISOString(),
      } satisfies ReturnType<Process["toJson"]>),
    );
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#endedAtTime",
      ),
      this.endedAtTime,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#startedAtTime",
      ),
      this.startedAtTime,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Process {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      endedAtTime: purify.Maybe<Date>;
      identifier: rdfjs.NamedNode;
      startedAtTime: Date;
    } & UnwrapR<ReturnType<typeof Entity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = processJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Entity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const endedAtTime = purify.Maybe.fromNullable(
      _jsonObject["endedAtTime"],
    ).map((_item) => new Date(_item));
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const startedAtTime = new Date(_jsonObject["startedAtTime"]);
    return purify.Either.of({
      ..._super0,
      endedAtTime,
      identifier,
      startedAtTime,
    });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      endedAtTime: purify.Maybe<Date>;
      identifier: rdfjs.NamedNode;
      startedAtTime: Date;
    } & UnwrapR<ReturnType<typeof Entity.propertiesFromRdf>>
  > {
    const _super0Either = Entity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const _endedAtTimeEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#endedAtTime",
          ),
          { unique: true },
        )
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_endedAtTimeEither.isLeft()) {
      return _endedAtTimeEither;
    }

    const endedAtTime = _endedAtTimeEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _startedAtTimeEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Date
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#startedAtTime",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toDate());
    if (_startedAtTimeEither.isLeft()) {
      return _startedAtTimeEither;
    }

    const startedAtTime = _startedAtTimeEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      endedAtTime,
      identifier,
      startedAtTime,
    });
  }

  export function jsonSchema() {
    return zodToJsonSchema(processJsonZodSchema());
  }

  export function processJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Entity.entityJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/endedAtTime`, type: "Control" },
        { scope: `${scopePrefix}/properties/startedAtTime`, type: "Control" },
      ],
      label: "Process",
      type: "Group",
    };
  }

  export function processJsonZodSchema() {
    return Entity.entityJsonZodSchema().merge(
      zod.object({
        endedAtTime: zod.string().datetime().optional(),
        "@id": zod.string().min(1),
        startedAtTime: zod.string().datetime(),
        type: zod.enum([
          "CorpusDeletion",
          "DocumentDeletion",
          "LanguageModelInvocation",
          "PromptConstruction",
          "QuestionAdministration",
          "QuestionnaireAdministration",
          "ValueExtraction",
          "WorkflowDeletion",
          "WorkflowExecution",
          "WorkflowExecutionStub",
          "WorkflowQuestionnaireStepExecution",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Process.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Process.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Process.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("process");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "process");
    return [
      ...Entity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}EndedAtTime`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#endedAtTime",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}StartedAtTime`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#startedAtTime",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("process");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "process");
    return [
      ...Entity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}EndedAtTime`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#endedAtTime",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}StartedAtTime`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#startedAtTime",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class WorkflowQuestionnaireStepExecution extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: WorkflowQuestionnaireStepExecutionInput;
  readonly output: Exception | WorkflowQuestionnaireStepExecutionOutput;
  readonly subProcesses: WorkflowQuestionnaireStepExecutionSubProcesses;
  override readonly type = "WorkflowQuestionnaireStepExecution";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: WorkflowQuestionnaireStepExecutionInput;
      readonly output: Exception | WorkflowQuestionnaireStepExecutionOutput;
      readonly subProcesses: WorkflowQuestionnaireStepExecutionSubProcesses;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
    this.subProcesses = parameters.subProcesses;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowQuestionnaireStepExecution): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | WorkflowQuestionnaireStepExecutionOutput,
          right: Exception | WorkflowQuestionnaireStepExecutionOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "WorkflowQuestionnaireStepExecutionOutput" &&
            right.type === "WorkflowQuestionnaireStepExecutionOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.subProcesses,
          other.subProcesses,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "subProcesses",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "WorkflowQuestionnaireStepExecutionOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    this.subProcesses.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<
      WorkflowQuestionnaireStepExecutionInput["toJson"]
    >;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<WorkflowQuestionnaireStepExecutionOutput["toJson"]>;
    readonly subProcesses: ReturnType<
      WorkflowQuestionnaireStepExecutionSubProcesses["toJson"]
    >;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "WorkflowQuestionnaireStepExecutionOutput"
            ? this.output.toJson()
            : this.output.toJson(),
        subProcesses: this.subProcesses.toJson(),
      } satisfies ReturnType<WorkflowQuestionnaireStepExecution["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecution",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "WorkflowQuestionnaireStepExecutionOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#subProcesses",
      ),
      this.subProcesses.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowQuestionnaireStepExecution {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: WorkflowQuestionnaireStepExecutionInput;
      output: Exception | WorkflowQuestionnaireStepExecutionOutput;
      subProcesses: WorkflowQuestionnaireStepExecutionSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowQuestionnaireStepExecutionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = WorkflowQuestionnaireStepExecutionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "WorkflowQuestionnaireStepExecutionOutput"
        ? WorkflowQuestionnaireStepExecutionOutput.fromJson(
            _jsonObject["output"],
          ).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    const subProcesses =
      WorkflowQuestionnaireStepExecutionSubProcesses.fromJson(
        _jsonObject["subProcesses"],
      ).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowQuestionnaireStepExecution> {
    return WorkflowQuestionnaireStepExecution.propertiesFromJson(json).map(
      (properties) => new WorkflowQuestionnaireStepExecution(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: WorkflowQuestionnaireStepExecutionInput;
      output: Exception | WorkflowQuestionnaireStepExecutionOutput;
      subProcesses: WorkflowQuestionnaireStepExecutionSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecution",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecution",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowQuestionnaireStepExecutionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowQuestionnaireStepExecutionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | WorkflowQuestionnaireStepExecutionOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | WorkflowQuestionnaireStepExecutionOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            WorkflowQuestionnaireStepExecutionOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | WorkflowQuestionnaireStepExecutionOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    const _subProcessesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowQuestionnaireStepExecutionSubProcesses
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowQuestionnaireStepExecutionSubProcesses.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_subProcessesEither.isLeft()) {
      return _subProcessesEither;
    }

    const subProcesses = _subProcessesEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof WorkflowQuestionnaireStepExecution.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowQuestionnaireStepExecution
  > {
    return WorkflowQuestionnaireStepExecution.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowQuestionnaireStepExecution(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecution",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowQuestionnaireStepExecutionJsonZodSchema());
  }

  export function workflowQuestionnaireStepExecutionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        WorkflowQuestionnaireStepExecutionInput.workflowQuestionnaireStepExecutionInputJsonUiSchema(
          { scopePrefix: `${scopePrefix}/properties/input` },
        ),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
        WorkflowQuestionnaireStepExecutionSubProcesses.workflowQuestionnaireStepExecutionSubProcessesJsonUiSchema(
          { scopePrefix: `${scopePrefix}/properties/subProcesses` },
        ),
      ],
      label: "WorkflowQuestionnaireStepExecution",
      type: "Group",
    };
  }

  export function workflowQuestionnaireStepExecutionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input:
          WorkflowQuestionnaireStepExecutionInput.workflowQuestionnaireStepExecutionInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          WorkflowQuestionnaireStepExecutionOutput.workflowQuestionnaireStepExecutionOutputJsonZodSchema(),
        ]),
        subProcesses:
          WorkflowQuestionnaireStepExecutionSubProcesses.workflowQuestionnaireStepExecutionSubProcessesJsonZodSchema(),
        type: zod.literal("WorkflowQuestionnaireStepExecution"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowQuestionnaireStepExecution.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowQuestionnaireStepExecution.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowQuestionnaireStepExecution.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecution");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecution");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...WorkflowQuestionnaireStepExecutionInput.sparqlConstructTemplateTriples(
        {
          ignoreRdfType: true,
          subject: dataFactory.variable!(`${variablePrefix}Input`),
          variablePrefix: `${variablePrefix}Input`,
        },
      ),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...WorkflowQuestionnaireStepExecutionOutput.sparqlConstructTemplateTriples(
        {
          ignoreRdfType: true,
          subject: dataFactory.variable!(`${variablePrefix}Output`),
          variablePrefix: `${variablePrefix}Output`,
        },
      ),
      {
        object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        subject,
      },
      ...WorkflowQuestionnaireStepExecutionSubProcesses.sparqlConstructTemplateTriples(
        {
          ignoreRdfType: true,
          subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
          variablePrefix: `${variablePrefix}SubProcesses`,
        },
      ),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowQuestionnaireStepExecution");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStepExecution");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStepExecution",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowQuestionnaireStepExecutionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...WorkflowQuestionnaireStepExecutionOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#subProcesses",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowQuestionnaireStepExecutionSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        variablePrefix: `${variablePrefix}SubProcesses`,
      }),
    ];
  }
}
/**
 * information content entity
 */
abstract class InformationContentEntity extends Entity {
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "Answer"
    | "BooleanValue"
    | "CategoricalQuestion"
    | "CategoricalValue"
    | "Claim"
    | "CompletionMessage"
    | "ConceptSchemeConceptSelector"
    | "ConceptSchemeTopConceptSelector"
    | "Corpus"
    | "DichotomousQuestion"
    | "Document"
    | "DocumentTitle"
    | "EnumeratedConceptSelector"
    | "Exception"
    | "Image"
    | "Instruction"
    | "LanguageModelFamily"
    | "LanguageModelSpecification"
    | "NarrowerConceptSelector"
    | "NarrowerTransitiveConceptSelector"
    | "Prompt"
    | "PromptLiteralInputValue"
    | "PromptMessage"
    | "PromptMessageTemplate"
    | "PromptSparqlSelectInputValue"
    | "PromptTemplate"
    | "Questionnaire"
    | "RealValue"
    | "RealValuedQuestion"
    | "TextQuestion"
    | "TextValue"
    | "TextualEntity"
    | "Workflow"
    | "WorkflowQuestionnaireStep";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(parameters: ConstructorParameters<typeof Entity>[0]) {
    super(parameters);
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace InformationContentEntity {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      informationContentEntityJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Entity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromRdf>
    >
  > {
    const _super0Either = Entity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(informationContentEntityJsonZodSchema());
  }

  export function informationContentEntityJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [Entity.entityJsonUiSchema({ scopePrefix })],
      label: "information content entity",
      type: "Group",
    };
  }

  export function informationContentEntityJsonZodSchema() {
    return Entity.entityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.enum([
          "Answer",
          "BooleanValue",
          "CategoricalQuestion",
          "CategoricalValue",
          "Claim",
          "CompletionMessage",
          "ConceptSchemeConceptSelector",
          "ConceptSchemeTopConceptSelector",
          "Corpus",
          "DichotomousQuestion",
          "Document",
          "DocumentTitle",
          "EnumeratedConceptSelector",
          "Exception",
          "Image",
          "Instruction",
          "LanguageModelFamily",
          "LanguageModelSpecification",
          "NarrowerConceptSelector",
          "NarrowerTransitiveConceptSelector",
          "Prompt",
          "PromptLiteralInputValue",
          "PromptMessage",
          "PromptMessageTemplate",
          "PromptSparqlSelectInputValue",
          "PromptTemplate",
          "Questionnaire",
          "RealValue",
          "RealValuedQuestion",
          "TextQuestion",
          "TextValue",
          "TextualEntity",
          "Workflow",
          "WorkflowQuestionnaireStep",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InformationContentEntity.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InformationContentEntity.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InformationContentEntity.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("informationContentEntity");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "informationContentEntity");
    return [
      ...Entity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("informationContentEntity");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "informationContentEntity");
    return [
      ...Entity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }
}
export class WorkflowQuestionnaireStep extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly languageModel: purify.Maybe<LanguageModelSpecificationStub>;
  readonly questionnaire: Questionnaire;
  override readonly type = "WorkflowQuestionnaireStep";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly languageModel?:
        | LanguageModelSpecificationStub
        | purify.Maybe<LanguageModelSpecificationStub>;
      readonly questionnaire: Questionnaire;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.languageModel)) {
      this.languageModel = parameters.languageModel;
    } else if (
      typeof parameters.languageModel === "object" &&
      parameters.languageModel instanceof LanguageModelSpecificationStub
    ) {
      this.languageModel = purify.Maybe.of(parameters.languageModel);
    } else if (typeof parameters.languageModel === "undefined") {
      this.languageModel = purify.Maybe.empty();
    } else {
      this.languageModel = parameters.languageModel as never;
    }

    this.questionnaire = parameters.questionnaire;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowQuestionnaireStep): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.languageModel,
          other.languageModel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageModel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.questionnaire,
          other.questionnaire,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "questionnaire",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.languageModel.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    this.questionnaire.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly languageModel:
      | ReturnType<LanguageModelSpecificationStub["toJson"]>
      | undefined;
    readonly questionnaire: ReturnType<Questionnaire["toJson"]>;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        languageModel: this.languageModel
          .map((_item) => _item.toJson())
          .extract(),
        questionnaire: this.questionnaire.toJson(),
      } satisfies ReturnType<WorkflowQuestionnaireStep["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStep",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModel",
      ),
      this.languageModel.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#questionnaire",
      ),
      this.questionnaire.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowQuestionnaireStep {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      languageModel: purify.Maybe<LanguageModelSpecificationStub>;
      questionnaire: Questionnaire;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowQuestionnaireStepJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const languageModel = purify.Maybe.fromNullable(
      _jsonObject["languageModel"],
    ).map((_item) =>
      LanguageModelSpecificationStub.fromJson(_item).unsafeCoerce(),
    );
    const questionnaire = Questionnaire.fromJson(
      _jsonObject["questionnaire"],
    ).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      languageModel,
      questionnaire,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowQuestionnaireStep> {
    return WorkflowQuestionnaireStep.propertiesFromJson(json).map(
      (properties) => new WorkflowQuestionnaireStep(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      languageModel: purify.Maybe<LanguageModelSpecificationStub>;
      questionnaire: Questionnaire;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStep",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStep",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _languageModelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<LanguageModelSpecificationStub>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#languageModel",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          LanguageModelSpecificationStub.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_languageModelEither.isLeft()) {
      return _languageModelEither;
    }

    const languageModel = _languageModelEither.unsafeCoerce();
    const _questionnaireEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Questionnaire
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaire",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Questionnaire.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_questionnaireEither.isLeft()) {
      return _questionnaireEither;
    }

    const questionnaire = _questionnaireEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      languageModel,
      questionnaire,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof WorkflowQuestionnaireStep.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowQuestionnaireStep
  > {
    return WorkflowQuestionnaireStep.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowQuestionnaireStep(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStep",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowQuestionnaireStepJsonZodSchema());
  }

  export function workflowQuestionnaireStepJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        LanguageModelSpecificationStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/languageModel`,
        }),
        Questionnaire.questionnaireJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/questionnaire`,
        }),
      ],
      label: "WorkflowQuestionnaireStep",
      type: "Group",
    };
  }

  export function workflowQuestionnaireStepJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        languageModel:
          LanguageModelSpecificationStub.jsonZodSchema().optional(),
        questionnaire: Questionnaire.questionnaireJsonZodSchema(),
        type: zod.literal("WorkflowQuestionnaireStep"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowQuestionnaireStep.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowQuestionnaireStep.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowQuestionnaireStep.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowQuestionnaireStep");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStep");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        subject,
      },
      ...LanguageModelSpecificationStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Questionnaire`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaire",
        ),
        subject,
      },
      ...Questionnaire.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Questionnaire`),
        variablePrefix: `${variablePrefix}Questionnaire`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowQuestionnaireStep");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowQuestionnaireStep");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowQuestionnaireStep",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#languageModel",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...LanguageModelSpecificationStub.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
            variablePrefix: `${variablePrefix}LanguageModel`,
          }),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Questionnaire`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#questionnaire",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Questionnaire.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Questionnaire`),
        variablePrefix: `${variablePrefix}Questionnaire`,
      }),
    ];
  }
}
export class WorkflowExecutionStub extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "WorkflowExecutionStub";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowExecutionStub {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Process.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      workflowExecutionStubJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowExecutionStub> {
    return WorkflowExecutionStub.propertiesFromJson(json).map(
      (properties) => new WorkflowExecutionStub(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof Process.propertiesFromRdf>
    >
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowExecutionStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowExecutionStub> {
    return WorkflowExecutionStub.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowExecutionStub(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowExecutionStubJsonZodSchema());
  }

  export function workflowExecutionStubJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [Process.processJsonUiSchema({ scopePrefix })],
      label: "WorkflowExecutionStub",
      type: "Group",
    };
  }

  export function workflowExecutionStubJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("WorkflowExecutionStub"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowExecutionStub.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowExecutionStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowExecutionStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecutionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionStub");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecutionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionStub");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class WorkflowExecutionSubProcesses extends ProcessSubProcesses {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly stepExecutions: readonly WorkflowStepExecution[];
  override readonly type = "WorkflowExecutionSubProcesses";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly stepExecutions: readonly WorkflowStepExecution[];
    } & ConstructorParameters<typeof ProcessSubProcesses>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.stepExecutions = parameters.stepExecutions;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowExecutionSubProcesses): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, WorkflowStepExecution.equals))(
          this.stepExecutions,
          other.stepExecutions,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "stepExecutions",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.stepExecutions) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly stepExecutions: readonly ReturnType<
      WorkflowQuestionnaireStepExecution["toJson"]
    >[];
  } & ReturnType<ProcessSubProcesses["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        stepExecutions: this.stepExecutions.map((_item) => _item.toJson()),
      } satisfies ReturnType<WorkflowExecutionSubProcesses["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionSubProcesses",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#workflowStepExecutions",
      ),
      this.stepExecutions.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#WorkflowStepExecutionList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.stepExecutions.reduce(
                (_hasher, _item) => {
                  _item.hash(_hasher);
                  return _hasher;
                },
                sha256.create(),
              )}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowExecutionSubProcesses {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      stepExecutions: readonly WorkflowStepExecution[];
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowExecutionSubProcessesJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessSubProcesses.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const stepExecutions = _jsonObject["stepExecutions"].map((_item) =>
      WorkflowStepExecution.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ..._super0, identifier, stepExecutions });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowExecutionSubProcesses> {
    return WorkflowExecutionSubProcesses.propertiesFromJson(json).map(
      (properties) => new WorkflowExecutionSubProcesses(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      stepExecutions: readonly WorkflowStepExecution[];
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromRdf>>
  > {
    const _super0Either = ProcessSubProcesses.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionSubProcesses",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionSubProcesses",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _stepExecutionsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly WorkflowStepExecution[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflowStepExecutions",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              WorkflowStepExecution.fromRdf({
                ..._context,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_stepExecutionsEither.isLeft()) {
      return _stepExecutionsEither;
    }

    const stepExecutions = _stepExecutionsEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, stepExecutions });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof WorkflowExecutionSubProcesses.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowExecutionSubProcesses
  > {
    return WorkflowExecutionSubProcesses.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowExecutionSubProcesses(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionSubProcesses",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowExecutionSubProcessesJsonZodSchema());
  }

  export function workflowExecutionSubProcessesJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessSubProcesses.processSubProcessesJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/stepExecutions`, type: "Control" },
      ],
      label: "WorkflowExecutionSubProcesses",
      type: "Group",
    };
  }

  export function workflowExecutionSubProcessesJsonZodSchema() {
    return ProcessSubProcesses.processSubProcessesJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        stepExecutions: WorkflowStepExecution.jsonZodSchema().array(),
        type: zod.literal("WorkflowExecutionSubProcesses"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowExecutionSubProcesses.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowExecutionSubProcesses.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowExecutionSubProcesses.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowExecutionSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}StepExecutions`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflowStepExecutions",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}StepExecutions`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}Item0`,
        ),
      },
      ...WorkflowStepExecution.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}StepExecutions`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}StepExecutions`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}Rest0`,
        ),
      },
      {
        subject: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}RestN`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}ItemN`,
        ),
      },
      ...WorkflowStepExecution.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}ItemN`,
        ),
        variablePrefix: `${`${variablePrefix}StepExecutions`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}RestN`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}RestNBasic`,
        ),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("workflowExecutionSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionSubProcesses",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}StepExecutions`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#workflowStepExecutions",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}StepExecutions`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}StepExecutions`}Item0`,
            ),
          },
        ],
      },
      ...WorkflowStepExecution.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}StepExecutions`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}StepExecutions`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}StepExecutions`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}StepExecutions`}Rest0`,
            ),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${variablePrefix}StepExecutions`,
                ),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}StepExecutions`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}StepExecutions`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}StepExecutions`}ItemN`,
                ),
              },
            ],
          },
          ...WorkflowStepExecution.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}StepExecutions`}ItemN`,
            ),
            variablePrefix: `${`${variablePrefix}StepExecutions`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}StepExecutions`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}StepExecutions`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class WorkflowExecutionOutput extends ProcessOutput {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "WorkflowExecutionOutput";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionOutput",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowExecutionOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      workflowExecutionOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowExecutionOutput> {
    return WorkflowExecutionOutput.propertiesFromJson(json).map(
      (properties) => new WorkflowExecutionOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionOutput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowExecutionOutput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowExecutionOutput> {
    return WorkflowExecutionOutput.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowExecutionOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowExecutionOutputJsonZodSchema());
  }

  export function workflowExecutionOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ProcessOutput.processOutputJsonUiSchema({ scopePrefix })],
      label: "WorkflowExecutionOutput",
      type: "Group",
    };
  }

  export function workflowExecutionOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("WorkflowExecutionOutput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowExecutionOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowExecutionOutput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowExecutionOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecutionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecutionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class WorkflowStub {
  /**
   * deleted
   */
  readonly deleted: boolean;
  readonly identifier: rdfjs.NamedNode;
  /**
   * has label
   */
  readonly label: purify.Maybe<string>;
  readonly type = "WorkflowStub";

  constructor(parameters: {
    readonly deleted?: boolean;
    readonly identifier: rdfjs.NamedNode | string;
    readonly label?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters.deleted === "boolean") {
      this.deleted = parameters.deleted;
    } else if (typeof parameters.deleted === "undefined") {
      this.deleted = false;
    } else {
      this.deleted = parameters.deleted as never;
    }

    if (typeof parameters.identifier === "object") {
      this.identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this.identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this.identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.label)) {
      this.label = parameters.label;
    } else if (typeof parameters.label === "string") {
      this.label = purify.Maybe.of(parameters.label);
    } else if (typeof parameters.label === "undefined") {
      this.label = purify.Maybe.empty();
    } else {
      this.label = parameters.label as never;
    }
  }

  equals(other: WorkflowStub): EqualsResult {
    return strictEquals(this.deleted, other.deleted)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "deleted",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        booleanEquals(this.identifier, other.identifier).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "identifier",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => maybeEquals(left, right, strictEquals))(
          this.label,
          other.label,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "label",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.deleted.toString());
    this.label.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  toJson(): {
    readonly deleted: boolean;
    readonly "@id": string;
    readonly label: string | undefined;
    readonly type: "WorkflowStub";
  } {
    return JSON.parse(
      JSON.stringify({
        deleted: this.deleted,
        "@id": this.identifier.value,
        label: this.label.map((_item) => _item).extract(),
        type: this.type,
      } satisfies ReturnType<WorkflowStub["toJson"]>),
    );
  }

  toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Workflow",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#deleted",
      ),
      this.deleted ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowStub {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: purify.Maybe<string>;
    }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const deleted = _jsonObject["deleted"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = purify.Maybe.fromNullable(_jsonObject["label"]);
    return purify.Either.of({ deleted, identifier, label });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowStub> {
    return WorkflowStub.propertiesFromJson(json).map(
      (properties) => new WorkflowStub(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: purify.Maybe<string>;
    }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Workflow",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Workflow",
          ),
        }),
      );
    }

    const _deletedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#deleted",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_deletedEither.isLeft()) {
      return _deletedEither;
    }

    const deleted = _deletedEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
          { unique: true },
        )
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    return purify.Either.of({ deleted, identifier, label });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowStub> {
    return WorkflowStub.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowStub(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Workflow",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "deleted",
          scope: `${scopePrefix}/properties/deleted`,
          type: "Control",
        },
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "WorkflowStub" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "WorkflowStub",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      deleted: zod.boolean(),
      "@id": zod.string().min(1),
      label: zod.string().optional(),
      type: zod.literal("WorkflowStub"),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowStub.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflowStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Deleted`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflowStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Workflow",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Deleted`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#deleted",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Label`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2000/01/rdf-schema#label",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class WorkflowDeletionInput extends ProcessInput {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "WorkflowDeletionInput";
  readonly workflow: WorkflowStub;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly workflow: WorkflowStub;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.workflow = parameters.workflow;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowDeletionInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.workflow,
          other.workflow,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "workflow",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.workflow.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly workflow: ReturnType<WorkflowStub["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        workflow: this.workflow.toJson(),
      } satisfies ReturnType<WorkflowDeletionInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#workflow",
      ),
      this.workflow.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowDeletionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; workflow: WorkflowStub } & UnwrapR<
      ReturnType<typeof ProcessInput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      workflowDeletionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const workflow = WorkflowStub.fromJson(
      _jsonObject["workflow"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, workflow });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowDeletionInput> {
    return WorkflowDeletionInput.propertiesFromJson(json).map(
      (properties) => new WorkflowDeletionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; workflow: WorkflowStub } & UnwrapR<
      ReturnType<typeof ProcessInput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletionInput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _workflowEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflow",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_workflowEither.isLeft()) {
      return _workflowEither;
    }

    const workflow = _workflowEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, workflow });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowDeletionInput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowDeletionInput> {
    return WorkflowDeletionInput.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowDeletionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowDeletionInputJsonZodSchema());
  }

  export function workflowDeletionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        WorkflowStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/workflow`,
        }),
      ],
      label: "WorkflowDeletionInput",
      type: "Group",
    };
  }

  export function workflowDeletionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("WorkflowDeletionInput"),
        workflow: WorkflowStub.jsonZodSchema(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowDeletionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowDeletionInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowDeletionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowDeletionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowDeletionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Workflow`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflow",
        ),
        subject,
      },
      ...WorkflowStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Workflow`),
        variablePrefix: `${variablePrefix}Workflow`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowDeletionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowDeletionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Workflow`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#workflow",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Workflow`),
        variablePrefix: `${variablePrefix}Workflow`,
      }),
    ];
  }
}
export class WorkflowDeletion extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: WorkflowDeletionInput;
  override readonly type = "WorkflowDeletion";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: WorkflowDeletionInput;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowDeletion): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<WorkflowDeletionInput["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
      } satisfies ReturnType<WorkflowDeletion["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletion",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowDeletion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; input: WorkflowDeletionInput } & UnwrapR<
      ReturnType<typeof Process.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      workflowDeletionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = WorkflowDeletionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowDeletion> {
    return WorkflowDeletion.propertiesFromJson(json).map(
      (properties) => new WorkflowDeletion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; input: WorkflowDeletionInput } & UnwrapR<
      ReturnType<typeof Process.propertiesFromRdf>
    >
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletion",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowDeletionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowDeletionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowDeletion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowDeletion> {
    return WorkflowDeletion.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowDeletion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowDeletionJsonZodSchema());
  }

  export function workflowDeletionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        WorkflowDeletionInput.workflowDeletionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
      ],
      label: "WorkflowDeletion",
      type: "Group",
    };
  }

  export function workflowDeletionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input: WorkflowDeletionInput.workflowDeletionInputJsonZodSchema(),
        type: zod.literal("WorkflowDeletion"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowDeletion.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowDeletion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowDeletion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowDeletion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflowDeletion");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...WorkflowDeletionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowDeletion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflowDeletion");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowDeletion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowDeletionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
    ];
  }
}
export class Workflow extends InformationContentEntity {
  /**
   * deleted
   */
  readonly deleted: boolean;
  private _identifier: rdfjs.NamedNode | undefined;
  /**
   * has label
   */
  readonly label: string;
  readonly steps: readonly WorkflowStep[];
  override readonly type = "Workflow";

  constructor(
    parameters: {
      readonly deleted?: boolean;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly label: string;
      readonly steps: readonly WorkflowStep[];
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.deleted === "boolean") {
      this.deleted = parameters.deleted;
    } else if (typeof parameters.deleted === "undefined") {
      this.deleted = false;
    } else {
      this.deleted = parameters.deleted as never;
    }

    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.label = parameters.label;
    this.steps = parameters.steps;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${uuid.v4()}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Workflow): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.deleted, other.deleted).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "deleted",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.label, other.label).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "label",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => arrayEquals(left, right, WorkflowStep.equals))(
          this.steps,
          other.steps,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "steps",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.deleted.toString());
    _hasher.update(this.label);
    for (const _element0 of this.steps) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly deleted: boolean;
    readonly label: string;
    readonly steps: readonly ReturnType<WorkflowQuestionnaireStep["toJson"]>[];
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        deleted: this.deleted,
        label: this.label,
        steps: this.steps.map((_item) => _item.toJson()),
      } satisfies ReturnType<Workflow["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Workflow",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#deleted",
      ),
      this.deleted ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#workflowSteps",
      ),
      this.steps.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#WorkflowStepList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.steps.reduce((_hasher, _item) => {
                _item.hash(_hasher);
                return _hasher;
              }, sha256.create())}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Workflow {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: string;
      steps: readonly WorkflowStep[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = workflowJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const deleted = _jsonObject["deleted"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = _jsonObject["label"];
    const steps = _jsonObject["steps"].map((_item) =>
      WorkflowStep.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ..._super0, deleted, identifier, label, steps });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Workflow> {
    return Workflow.propertiesFromJson(json).map(
      (properties) => new Workflow(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: string;
      steps: readonly WorkflowStep[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Workflow",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Workflow",
          ),
        }),
      );
    }

    const _deletedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#deleted",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_deletedEither.isLeft()) {
      return _deletedEither;
    }

    const deleted = _deletedEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    const _stepsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly WorkflowStep[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflowSteps",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              WorkflowStep.fromRdf({ ..._context, resource: _resource }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_stepsEither.isLeft()) {
      return _stepsEither;
    }

    const steps = _stepsEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, deleted, identifier, label, steps });
  }

  export function fromRdf(
    parameters: Parameters<typeof Workflow.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Workflow> {
    return Workflow.propertiesFromRdf(parameters).map(
      (properties) => new Workflow(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Workflow",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowJsonZodSchema());
  }

  export function workflowJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        {
          label: "deleted",
          scope: `${scopePrefix}/properties/deleted`,
          type: "Control",
        },
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/steps`, type: "Control" },
      ],
      label: "Workflow",
      type: "Group",
    };
  }

  export function workflowJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        deleted: zod.boolean(),
        "@id": zod.string().min(1),
        label: zod.string(),
        steps: WorkflowStep.jsonZodSchema().array(),
        type: zod.literal("Workflow"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Workflow.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Workflow.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Workflow.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("workflow");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflow");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Deleted`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Steps`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflowSteps",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Steps`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Steps`}Item0`),
      },
      ...WorkflowStep.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Steps`}Item0`),
        variablePrefix: `${`${variablePrefix}Steps`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Steps`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Steps`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Steps`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Steps`}ItemN`),
      },
      ...WorkflowStep.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Steps`}ItemN`),
        variablePrefix: `${`${variablePrefix}Steps`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Steps`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Steps`}RestNBasic`),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("workflow");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflow");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Workflow",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Deleted`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#deleted",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Label`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/2000/01/rdf-schema#label",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Steps`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#workflowSteps",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Steps`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Steps`}Item0`),
          },
        ],
      },
      ...WorkflowStep.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Steps`}Item0`),
        variablePrefix: `${`${variablePrefix}Steps`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Steps`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Steps`}Rest0`),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Steps`),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}Steps`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Steps`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Steps`}ItemN`,
                ),
              },
            ],
          },
          ...WorkflowStep.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${`${variablePrefix}Steps`}ItemN`),
            variablePrefix: `${`${variablePrefix}Steps`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Steps`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Steps`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class ValueExtractionOutput extends ProcessOutput {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "ValueExtractionOutput";
  readonly values: readonly Value[];

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly values: readonly Value[];
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.values = parameters.values;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: ValueExtractionOutput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => arrayEquals(left, right, Value.equals))(
          this.values,
          other.values,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "values",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.values) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly values: readonly (
      | ReturnType<BooleanValue["toJson"]>
      | ReturnType<CategoricalValue["toJson"]>
      | ReturnType<RealValue["toJson"]>
      | ReturnType<TextValue["toJson"]>
    )[];
  } & ReturnType<ProcessOutput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        values: this.values.map((_item) => _item.toJson()),
      } satisfies ReturnType<ValueExtractionOutput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ValueExtractionOutput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#values",
      ),
      this.values.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#ValueList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.values.reduce((_hasher, _item) => {
                _item.hash(_hasher);
                return _hasher;
              }, sha256.create())}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ValueExtractionOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; values: readonly Value[] } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      valueExtractionOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const values = _jsonObject["values"].map((_item) =>
      Value.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ..._super0, identifier, values });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ValueExtractionOutput> {
    return ValueExtractionOutput.propertiesFromJson(json).map(
      (properties) => new ValueExtractionOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; values: readonly Value[] } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ValueExtractionOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#ValueExtractionOutput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _valuesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly Value[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#values",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              Value.fromRdf({ ..._context, resource: _resource }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_valuesEither.isLeft()) {
      return _valuesEither;
    }

    const values = _valuesEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, values });
  }

  export function fromRdf(
    parameters: Parameters<typeof ValueExtractionOutput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ValueExtractionOutput> {
    return ValueExtractionOutput.propertiesFromRdf(parameters).map(
      (properties) => new ValueExtractionOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#ValueExtractionOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(valueExtractionOutputJsonZodSchema());
  }

  export function valueExtractionOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessOutput.processOutputJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/values`, type: "Control" },
      ],
      label: "ValueExtractionOutput",
      type: "Group",
    };
  }

  export function valueExtractionOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("ValueExtractionOutput"),
        values: Value.jsonZodSchema().array(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ValueExtractionOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ValueExtractionOutput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ValueExtractionOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("valueExtractionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "valueExtractionOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Values`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#values",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Values`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Values`}Item0`),
      },
      ...Value.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Values`}Item0`),
        variablePrefix: `${`${variablePrefix}Values`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Values`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Values`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Values`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Values`}ItemN`),
      },
      ...Value.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Values`}ItemN`),
        variablePrefix: `${`${variablePrefix}Values`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Values`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Values`}RestNBasic`),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("valueExtractionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "valueExtractionOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#ValueExtractionOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Values`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#values",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Values`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Values`}Item0`),
          },
        ],
      },
      ...Value.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Values`}Item0`),
        variablePrefix: `${`${variablePrefix}Values`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Values`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Values`}Rest0`),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Values`),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}Values`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Values`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Values`}ItemN`,
                ),
              },
            ],
          },
          ...Value.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${`${variablePrefix}Values`}ItemN`),
            variablePrefix: `${`${variablePrefix}Values`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Values`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Values`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class ValueExtractionInput extends ProcessInput {
  readonly completionMessage: CompletionMessage;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "ValueExtractionInput";

  constructor(
    parameters: {
      readonly completionMessage: CompletionMessage;
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.completionMessage = parameters.completionMessage;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: ValueExtractionInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.completionMessage,
          other.completionMessage,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "completionMessage",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.completionMessage.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly completionMessage: ReturnType<CompletionMessage["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        completionMessage: this.completionMessage.toJson(),
      } satisfies ReturnType<ValueExtractionInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ValueExtractionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#completionMessage",
      ),
      this.completionMessage.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ValueExtractionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      completionMessage: CompletionMessage;
      identifier: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      valueExtractionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const completionMessage = CompletionMessage.fromJson(
      _jsonObject["completionMessage"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, completionMessage, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ValueExtractionInput> {
    return ValueExtractionInput.propertiesFromJson(json).map(
      (properties) => new ValueExtractionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      completionMessage: CompletionMessage;
      identifier: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ValueExtractionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#ValueExtractionInput",
          ),
        }),
      );
    }

    const _completionMessageEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CompletionMessage
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#completionMessage",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        CompletionMessage.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_completionMessageEither.isLeft()) {
      return _completionMessageEither;
    }

    const completionMessage = _completionMessageEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, completionMessage, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof ValueExtractionInput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ValueExtractionInput> {
    return ValueExtractionInput.propertiesFromRdf(parameters).map(
      (properties) => new ValueExtractionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#ValueExtractionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(valueExtractionInputJsonZodSchema());
  }

  export function valueExtractionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        CompletionMessage.completionMessageJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/completionMessage`,
        }),
      ],
      label: "ValueExtractionInput",
      type: "Group",
    };
  }

  export function valueExtractionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        completionMessage: CompletionMessage.completionMessageJsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("ValueExtractionInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ValueExtractionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ValueExtractionInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ValueExtractionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("valueExtractionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "valueExtractionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#completionMessage",
        ),
        subject,
      },
      ...CompletionMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
        variablePrefix: `${variablePrefix}CompletionMessage`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("valueExtractionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "valueExtractionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#ValueExtractionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#completionMessage",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...CompletionMessage.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
        variablePrefix: `${variablePrefix}CompletionMessage`,
      }),
    ];
  }
}
abstract class BaseValue extends InformationContentEntity {
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "BooleanValue"
    | "CategoricalValue"
    | "RealValue"
    | "TextValue";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace BaseValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = baseValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromRdf>
    >
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(baseValueJsonZodSchema());
  }

  export function baseValueJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
      ],
      label: "BaseValue",
      type: "Group",
    };
  }

  export function baseValueJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.enum([
          "BooleanValue",
          "CategoricalValue",
          "RealValue",
          "TextValue",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseValue.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("baseValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseValue");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("baseValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseValue");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }
}
export class TextValue extends BaseValue {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "TextValue";
  readonly value: string;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly value: string;
    } & ConstructorParameters<typeof BaseValue>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.value = parameters.value;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: TextValue): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.value, other.value).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "value",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.value);
    return _hasher;
  }

  override toJson(): { readonly value: string } & ReturnType<
    BaseValue["toJson"]
  > {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        value: this.value,
      } satisfies ReturnType<TextValue["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#TextValue",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#value"),
      this.value,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace TextValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; value: string } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = textValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseValue.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const value = _jsonObject["value"];
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TextValue> {
    return TextValue.propertiesFromJson(json).map(
      (properties) => new TextValue(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; value: string } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseValue.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#TextValue",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#TextValue",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromRdf(
    parameters: Parameters<typeof TextValue.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, TextValue> {
    return TextValue.propertiesFromRdf(parameters).map(
      (properties) => new TextValue(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#TextValue",
  );

  export function jsonSchema() {
    return zodToJsonSchema(textValueJsonZodSchema());
  }

  export function textValueJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseValue.baseValueJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "TextValue",
      type: "Group",
    };
  }

  export function textValueJsonZodSchema() {
    return BaseValue.baseValueJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("TextValue"),
        value: zod.string(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TextValue.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        TextValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TextValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("textValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textValue");
    return [
      ...BaseValue.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Value`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("textValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textValue");
    return [
      ...BaseValue.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#TextValue",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Value`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class RealValue extends BaseValue {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "RealValue";
  readonly value: number;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly value: number;
    } & ConstructorParameters<typeof BaseValue>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.value = parameters.value;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: RealValue): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.value, other.value).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "value",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.value.toString());
    return _hasher;
  }

  override toJson(): { readonly value: number } & ReturnType<
    BaseValue["toJson"]
  > {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        value: this.value,
      } satisfies ReturnType<RealValue["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#RealValue",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#value"),
      this.value,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace RealValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; value: number } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = realValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseValue.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const value = _jsonObject["value"];
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RealValue> {
    return RealValue.propertiesFromJson(json).map(
      (properties) => new RealValue(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; value: number } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseValue.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#RealValue",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#RealValue",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      number
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toNumber());
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromRdf(
    parameters: Parameters<typeof RealValue.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RealValue> {
    return RealValue.propertiesFromRdf(parameters).map(
      (properties) => new RealValue(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#RealValue",
  );

  export function jsonSchema() {
    return zodToJsonSchema(realValueJsonZodSchema());
  }

  export function realValueJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseValue.baseValueJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "RealValue",
      type: "Group",
    };
  }

  export function realValueJsonZodSchema() {
    return BaseValue.baseValueJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("RealValue"),
        value: zod.number(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RealValue.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RealValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RealValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("realValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "realValue");
    return [
      ...BaseValue.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Value`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("realValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "realValue");
    return [
      ...BaseValue.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#RealValue",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Value`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class QuestionnaireAdministrationSubProcesses extends ProcessSubProcesses {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly questionAdministrations: readonly QuestionAdministration[];
  override readonly type = "QuestionnaireAdministrationSubProcesses";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly questionAdministrations: readonly QuestionAdministration[];
    } & ConstructorParameters<typeof ProcessSubProcesses>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.questionAdministrations = parameters.questionAdministrations;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(
    other: QuestionnaireAdministrationSubProcesses,
  ): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, (left, right) => left.equals(right)))(
          this.questionAdministrations,
          other.questionAdministrations,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "questionAdministrations",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.questionAdministrations) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly questionAdministrations: readonly ReturnType<
      QuestionAdministration["toJson"]
    >[];
  } & ReturnType<ProcessSubProcesses["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        questionAdministrations: this.questionAdministrations.map((_item) =>
          _item.toJson(),
        ),
      } satisfies ReturnType<
        QuestionnaireAdministrationSubProcesses["toJson"]
      >),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationSubProcesses",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#questionAdministrations",
      ),
      this.questionAdministrations.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.questionAdministrations.reduce(
                (_hasher, _item) => {
                  _item.hash(_hasher);
                  return _hasher;
                },
                sha256.create(),
              )}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionnaireAdministrationSubProcesses {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      questionAdministrations: readonly QuestionAdministration[];
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      questionnaireAdministrationSubProcessesJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessSubProcesses.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const questionAdministrations = _jsonObject["questionAdministrations"].map(
      (_item) => QuestionAdministration.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ..._super0,
      identifier,
      questionAdministrations,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionnaireAdministrationSubProcesses> {
    return QuestionnaireAdministrationSubProcesses.propertiesFromJson(json).map(
      (properties) => new QuestionnaireAdministrationSubProcesses(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      questionAdministrations: readonly QuestionAdministration[];
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromRdf>>
  > {
    const _super0Either = ProcessSubProcesses.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationSubProcesses",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationSubProcesses",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _questionAdministrationsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly QuestionAdministration[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionAdministrations",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              QuestionAdministration.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_questionAdministrationsEither.isLeft()) {
      return _questionAdministrationsEither;
    }

    const questionAdministrations =
      _questionAdministrationsEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      questionAdministrations,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionnaireAdministrationSubProcesses.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionnaireAdministrationSubProcesses
  > {
    return QuestionnaireAdministrationSubProcesses.propertiesFromRdf(
      parameters,
    ).map(
      (properties) => new QuestionnaireAdministrationSubProcesses(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationSubProcesses",
  );

  export function jsonSchema() {
    return zodToJsonSchema(
      questionnaireAdministrationSubProcessesJsonZodSchema(),
    );
  }

  export function questionnaireAdministrationSubProcessesJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessSubProcesses.processSubProcessesJsonUiSchema({ scopePrefix }),
        QuestionAdministration.questionAdministrationJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/questionAdministrations`,
        }),
      ],
      label: "QuestionnaireAdministrationSubProcesses",
      type: "Group",
    };
  }

  export function questionnaireAdministrationSubProcessesJsonZodSchema() {
    return ProcessSubProcesses.processSubProcessesJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        questionAdministrations:
          QuestionAdministration.questionAdministrationJsonZodSchema().array(),
        type: zod.literal("QuestionnaireAdministrationSubProcesses"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionnaireAdministrationSubProcesses.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionnaireAdministrationSubProcesses.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionnaireAdministrationSubProcesses.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministrationSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministrationSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(
          `${variablePrefix}QuestionAdministrations`,
        ),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionAdministrations",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(
          `${variablePrefix}QuestionAdministrations`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}Item0`,
        ),
      },
      ...QuestionAdministration.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}QuestionAdministrations`}Item0`,
      }),
      {
        subject: dataFactory.variable!(
          `${variablePrefix}QuestionAdministrations`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}Rest0`,
        ),
      },
      {
        subject: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}RestN`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}ItemN`,
        ),
      },
      ...QuestionAdministration.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}ItemN`,
        ),
        variablePrefix: `${`${variablePrefix}QuestionAdministrations`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}RestN`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}RestNBasic`,
        ),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministrationSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministrationSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationSubProcesses",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(
              `${variablePrefix}QuestionAdministrations`,
            ),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#questionAdministrations",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(
              `${variablePrefix}QuestionAdministrations`,
            ),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}QuestionAdministrations`}Item0`,
            ),
          },
        ],
      },
      ...QuestionAdministration.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}QuestionAdministrations`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}QuestionAdministrations`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(
              `${variablePrefix}QuestionAdministrations`,
            ),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}QuestionAdministrations`}Rest0`,
            ),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${variablePrefix}QuestionAdministrations`,
                ),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}QuestionAdministrations`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}QuestionAdministrations`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}QuestionAdministrations`}ItemN`,
                ),
              },
            ],
          },
          ...QuestionAdministration.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}QuestionAdministrations`}ItemN`,
            ),
            variablePrefix: `${`${variablePrefix}QuestionAdministrations`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}QuestionAdministrations`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}QuestionAdministrations`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class QuestionnaireAdministrationOutput extends ProcessOutput {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "QuestionnaireAdministrationOutput";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationOutput",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionnaireAdministrationOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      questionnaireAdministrationOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionnaireAdministrationOutput> {
    return QuestionnaireAdministrationOutput.propertiesFromJson(json).map(
      (properties) => new QuestionnaireAdministrationOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationOutput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionnaireAdministrationOutput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionnaireAdministrationOutput
  > {
    return QuestionnaireAdministrationOutput.propertiesFromRdf(parameters).map(
      (properties) => new QuestionnaireAdministrationOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionnaireAdministrationOutputJsonZodSchema());
  }

  export function questionnaireAdministrationOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ProcessOutput.processOutputJsonUiSchema({ scopePrefix })],
      label: "QuestionnaireAdministrationOutput",
      type: "Group",
    };
  }

  export function questionnaireAdministrationOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("QuestionnaireAdministrationOutput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionnaireAdministrationOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionnaireAdministrationOutput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionnaireAdministrationOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministrationOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministrationOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministrationOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministrationOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class QuestionnaireAdministrationInput extends ProcessInput {
  readonly document: DocumentStub;
  private _identifier: rdfjs.NamedNode | undefined;
  readonly languageModel: LanguageModelSpecificationStub;
  readonly questionnaire: Questionnaire;
  override readonly type = "QuestionnaireAdministrationInput";

  constructor(
    parameters: {
      readonly document: DocumentStub;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly languageModel: LanguageModelSpecificationStub;
      readonly questionnaire: Questionnaire;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.document = parameters.document;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.languageModel = parameters.languageModel;
    this.questionnaire = parameters.questionnaire;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: QuestionnaireAdministrationInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.document,
          other.document,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "document",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.languageModel,
          other.languageModel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageModel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.questionnaire,
          other.questionnaire,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "questionnaire",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.document.hash(_hasher);
    this.languageModel.hash(_hasher);
    this.questionnaire.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly document: ReturnType<DocumentStub["toJson"]>;
    readonly languageModel: ReturnType<
      LanguageModelSpecificationStub["toJson"]
    >;
    readonly questionnaire: ReturnType<Questionnaire["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        document: this.document.toJson(),
        languageModel: this.languageModel.toJson(),
        questionnaire: this.questionnaire.toJson(),
      } satisfies ReturnType<QuestionnaireAdministrationInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#document",
      ),
      this.document.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModel",
      ),
      this.languageModel.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#questionnaire",
      ),
      this.questionnaire.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionnaireAdministrationInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      languageModel: LanguageModelSpecificationStub;
      questionnaire: Questionnaire;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      questionnaireAdministrationInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const document = DocumentStub.fromJson(
      _jsonObject["document"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const languageModel = LanguageModelSpecificationStub.fromJson(
      _jsonObject["languageModel"],
    ).unsafeCoerce();
    const questionnaire = Questionnaire.fromJson(
      _jsonObject["questionnaire"],
    ).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      document,
      identifier,
      languageModel,
      questionnaire,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionnaireAdministrationInput> {
    return QuestionnaireAdministrationInput.propertiesFromJson(json).map(
      (properties) => new QuestionnaireAdministrationInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      languageModel: LanguageModelSpecificationStub;
      questionnaire: Questionnaire;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationInput",
          ),
        }),
      );
    }

    const _documentEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_documentEither.isLeft()) {
      return _documentEither;
    }

    const document = _documentEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _languageModelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      LanguageModelSpecificationStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        LanguageModelSpecificationStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_languageModelEither.isLeft()) {
      return _languageModelEither;
    }

    const languageModel = _languageModelEither.unsafeCoerce();
    const _questionnaireEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Questionnaire
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaire",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Questionnaire.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_questionnaireEither.isLeft()) {
      return _questionnaireEither;
    }

    const questionnaire = _questionnaireEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      document,
      identifier,
      languageModel,
      questionnaire,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionnaireAdministrationInput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionnaireAdministrationInput
  > {
    return QuestionnaireAdministrationInput.propertiesFromRdf(parameters).map(
      (properties) => new QuestionnaireAdministrationInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionnaireAdministrationInputJsonZodSchema());
  }

  export function questionnaireAdministrationInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        DocumentStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/document`,
        }),
        LanguageModelSpecificationStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/languageModel`,
        }),
        Questionnaire.questionnaireJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/questionnaire`,
        }),
      ],
      label: "QuestionnaireAdministrationInput",
      type: "Group",
    };
  }

  export function questionnaireAdministrationInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        document: DocumentStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        languageModel: LanguageModelSpecificationStub.jsonZodSchema(),
        questionnaire: Questionnaire.questionnaireJsonZodSchema(),
        type: zod.literal("QuestionnaireAdministrationInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionnaireAdministrationInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionnaireAdministrationInput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionnaireAdministrationInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministrationInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministrationInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Document`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        subject,
      },
      ...DocumentStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        subject,
      },
      ...LanguageModelSpecificationStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Questionnaire`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaire",
        ),
        subject,
      },
      ...Questionnaire.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Questionnaire`),
        variablePrefix: `${variablePrefix}Questionnaire`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministrationInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministrationInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministrationInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Document`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#document",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModel",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...LanguageModelSpecificationStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Questionnaire`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#questionnaire",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Questionnaire.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Questionnaire`),
        variablePrefix: `${variablePrefix}Questionnaire`,
      }),
    ];
  }
}
export class QuestionnaireAdministration extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: QuestionnaireAdministrationInput;
  readonly output: Exception | QuestionnaireAdministrationOutput;
  readonly subProcesses: QuestionnaireAdministrationSubProcesses;
  override readonly type = "QuestionnaireAdministration";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: QuestionnaireAdministrationInput;
      readonly output: Exception | QuestionnaireAdministrationOutput;
      readonly subProcesses: QuestionnaireAdministrationSubProcesses;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
    this.subProcesses = parameters.subProcesses;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: QuestionnaireAdministration): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | QuestionnaireAdministrationOutput,
          right: Exception | QuestionnaireAdministrationOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "QuestionnaireAdministrationOutput" &&
            right.type === "QuestionnaireAdministrationOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.subProcesses,
          other.subProcesses,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "subProcesses",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "QuestionnaireAdministrationOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    this.subProcesses.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<QuestionnaireAdministrationInput["toJson"]>;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<QuestionnaireAdministrationOutput["toJson"]>;
    readonly subProcesses: ReturnType<
      QuestionnaireAdministrationSubProcesses["toJson"]
    >;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "QuestionnaireAdministrationOutput"
            ? this.output.toJson()
            : this.output.toJson(),
        subProcesses: this.subProcesses.toJson(),
      } satisfies ReturnType<QuestionnaireAdministration["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministration",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "QuestionnaireAdministrationOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#subProcesses",
      ),
      this.subProcesses.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionnaireAdministration {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: QuestionnaireAdministrationInput;
      output: Exception | QuestionnaireAdministrationOutput;
      subProcesses: QuestionnaireAdministrationSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      questionnaireAdministrationJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = QuestionnaireAdministrationInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "QuestionnaireAdministrationOutput"
        ? QuestionnaireAdministrationOutput.fromJson(
            _jsonObject["output"],
          ).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    const subProcesses = QuestionnaireAdministrationSubProcesses.fromJson(
      _jsonObject["subProcesses"],
    ).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionnaireAdministration> {
    return QuestionnaireAdministration.propertiesFromJson(json).map(
      (properties) => new QuestionnaireAdministration(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: QuestionnaireAdministrationInput;
      output: Exception | QuestionnaireAdministrationOutput;
      subProcesses: QuestionnaireAdministrationSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministration",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministration",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      QuestionnaireAdministrationInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        QuestionnaireAdministrationInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | QuestionnaireAdministrationOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | QuestionnaireAdministrationOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            QuestionnaireAdministrationOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | QuestionnaireAdministrationOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    const _subProcessesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      QuestionnaireAdministrationSubProcesses
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        QuestionnaireAdministrationSubProcesses.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_subProcessesEither.isLeft()) {
      return _subProcessesEither;
    }

    const subProcesses = _subProcessesEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionnaireAdministration.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionnaireAdministration
  > {
    return QuestionnaireAdministration.propertiesFromRdf(parameters).map(
      (properties) => new QuestionnaireAdministration(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministration",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionnaireAdministrationJsonZodSchema());
  }

  export function questionnaireAdministrationJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        QuestionnaireAdministrationInput.questionnaireAdministrationInputJsonUiSchema(
          { scopePrefix: `${scopePrefix}/properties/input` },
        ),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
        QuestionnaireAdministrationSubProcesses.questionnaireAdministrationSubProcessesJsonUiSchema(
          { scopePrefix: `${scopePrefix}/properties/subProcesses` },
        ),
      ],
      label: "QuestionnaireAdministration",
      type: "Group",
    };
  }

  export function questionnaireAdministrationJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input:
          QuestionnaireAdministrationInput.questionnaireAdministrationInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          QuestionnaireAdministrationOutput.questionnaireAdministrationOutputJsonZodSchema(),
        ]),
        subProcesses:
          QuestionnaireAdministrationSubProcesses.questionnaireAdministrationSubProcessesJsonZodSchema(),
        type: zod.literal("QuestionnaireAdministration"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionnaireAdministration.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionnaireAdministration.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionnaireAdministration.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministration");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministration");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...QuestionnaireAdministrationInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...QuestionnaireAdministrationOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        subject,
      },
      ...QuestionnaireAdministrationSubProcesses.sparqlConstructTemplateTriples(
        {
          ignoreRdfType: true,
          subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
          variablePrefix: `${variablePrefix}SubProcesses`,
        },
      ),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionnaireAdministration");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionnaireAdministration");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionnaireAdministration",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...QuestionnaireAdministrationInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...QuestionnaireAdministrationOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#subProcesses",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...QuestionnaireAdministrationSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        variablePrefix: `${variablePrefix}SubProcesses`,
      }),
    ];
  }
}
export class Questionnaire extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly members: readonly QuestionnaireMember[];
  override readonly type = "Questionnaire";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly members: readonly QuestionnaireMember[];
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.members = parameters.members;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Questionnaire): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => arrayEquals(left, right, QuestionnaireMember.equals))(
          this.members,
          other.members,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "members",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.members) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly members: readonly (
      | ReturnType<Instruction["toJson"]>
      | ReturnType<CategoricalQuestion["toJson"]>
      | ReturnType<DichotomousQuestion["toJson"]>
      | ReturnType<RealValuedQuestion["toJson"]>
      | ReturnType<TextQuestion["toJson"]>
    )[];
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        members: this.members.map((_item) => _item.toJson()),
      } satisfies ReturnType<Questionnaire["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Questionnaire",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#questionnaireMembers",
      ),
      this.members.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#QuestionnaireMemberList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.members.reduce((_hasher, _item) => {
                _item.hash(_hasher);
                return _hasher;
              }, sha256.create())}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Questionnaire {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      members: readonly QuestionnaireMember[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = questionnaireJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const members = _jsonObject["members"].map((_item) =>
      QuestionnaireMember.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ..._super0, identifier, members });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Questionnaire> {
    return Questionnaire.propertiesFromJson(json).map(
      (properties) => new Questionnaire(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      members: readonly QuestionnaireMember[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Questionnaire",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Questionnaire",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _membersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly QuestionnaireMember[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaireMembers",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              QuestionnaireMember.fromRdf({ ..._context, resource: _resource }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_membersEither.isLeft()) {
      return _membersEither;
    }

    const members = _membersEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, members });
  }

  export function fromRdf(
    parameters: Parameters<typeof Questionnaire.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Questionnaire> {
    return Questionnaire.propertiesFromRdf(parameters).map(
      (properties) => new Questionnaire(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Questionnaire",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionnaireJsonZodSchema());
  }

  export function questionnaireJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/members`, type: "Control" },
      ],
      label: "Questionnaire",
      type: "Group",
    };
  }

  export function questionnaireJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        members: QuestionnaireMember.jsonZodSchema().array(),
        type: zod.literal("Questionnaire"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Questionnaire.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Questionnaire.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Questionnaire.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("questionnaire");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "questionnaire");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Members`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#questionnaireMembers",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Members`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Members`}Item0`),
      },
      ...QuestionnaireMember.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Members`}Item0`),
        variablePrefix: `${`${variablePrefix}Members`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Members`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Members`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Members`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Members`}ItemN`),
      },
      ...QuestionnaireMember.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Members`}ItemN`),
        variablePrefix: `${`${variablePrefix}Members`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Members`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}Members`}RestNBasic`,
        ),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("questionnaire");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "questionnaire");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Questionnaire",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Members`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#questionnaireMembers",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Members`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Members`}Item0`),
          },
        ],
      },
      ...QuestionnaireMember.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Members`}Item0`),
        variablePrefix: `${`${variablePrefix}Members`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Members`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Members`}Rest0`),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Members`),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}Members`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Members`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Members`}ItemN`,
                ),
              },
            ],
          },
          ...QuestionnaireMember.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}Members`}ItemN`,
            ),
            variablePrefix: `${`${variablePrefix}Members`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Members`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Members`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class ValueExtraction extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: ValueExtractionInput;
  readonly output: Exception | ValueExtractionOutput;
  override readonly type = "ValueExtraction";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: ValueExtractionInput;
      readonly output: Exception | ValueExtractionOutput;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: ValueExtraction): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | ValueExtractionOutput,
          right: Exception | ValueExtractionOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "ValueExtractionOutput" &&
            right.type === "ValueExtractionOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "ValueExtractionOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<ValueExtractionInput["toJson"]>;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<ValueExtractionOutput["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "ValueExtractionOutput"
            ? this.output.toJson()
            : this.output.toJson(),
      } satisfies ReturnType<ValueExtraction["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ValueExtraction",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "ValueExtractionOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ValueExtraction {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: ValueExtractionInput;
      output: Exception | ValueExtractionOutput;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      valueExtractionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = ValueExtractionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "ValueExtractionOutput"
        ? ValueExtractionOutput.fromJson(_jsonObject["output"]).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input, output });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ValueExtraction> {
    return ValueExtraction.propertiesFromJson(json).map(
      (properties) => new ValueExtraction(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: ValueExtractionInput;
      output: Exception | ValueExtractionOutput;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ValueExtraction",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#ValueExtraction",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ValueExtractionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        ValueExtractionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | ValueExtractionOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | ValueExtractionOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            ValueExtractionOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | ValueExtractionOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input, output });
  }

  export function fromRdf(
    parameters: Parameters<typeof ValueExtraction.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ValueExtraction> {
    return ValueExtraction.propertiesFromRdf(parameters).map(
      (properties) => new ValueExtraction(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#ValueExtraction",
  );

  export function jsonSchema() {
    return zodToJsonSchema(valueExtractionJsonZodSchema());
  }

  export function valueExtractionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        ValueExtractionInput.valueExtractionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
      ],
      label: "ValueExtraction",
      type: "Group",
    };
  }

  export function valueExtractionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input: ValueExtractionInput.valueExtractionInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          ValueExtractionOutput.valueExtractionOutputJsonZodSchema(),
        ]),
        type: zod.literal("ValueExtraction"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ValueExtraction.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ValueExtraction.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ValueExtraction.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("valueExtraction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "valueExtraction");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...ValueExtractionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...ValueExtractionOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("valueExtraction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "valueExtraction");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#ValueExtraction",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...ValueExtractionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...ValueExtractionOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }
}
export class QuestionAdministrationSubProcesses extends ProcessSubProcesses {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly languageModelInvocation: purify.Maybe<LanguageModelInvocation>;
  readonly promptConstruction: purify.Maybe<PromptConstruction>;
  override readonly type = "QuestionAdministrationSubProcesses";
  readonly valueExtraction: purify.Maybe<ValueExtraction>;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly languageModelInvocation?:
        | LanguageModelInvocation
        | purify.Maybe<LanguageModelInvocation>;
      readonly promptConstruction?:
        | PromptConstruction
        | purify.Maybe<PromptConstruction>;
      readonly valueExtraction?:
        | ValueExtraction
        | purify.Maybe<ValueExtraction>;
    } & ConstructorParameters<typeof ProcessSubProcesses>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.languageModelInvocation)) {
      this.languageModelInvocation = parameters.languageModelInvocation;
    } else if (
      typeof parameters.languageModelInvocation === "object" &&
      parameters.languageModelInvocation instanceof LanguageModelInvocation
    ) {
      this.languageModelInvocation = purify.Maybe.of(
        parameters.languageModelInvocation,
      );
    } else if (typeof parameters.languageModelInvocation === "undefined") {
      this.languageModelInvocation = purify.Maybe.empty();
    } else {
      this.languageModelInvocation =
        parameters.languageModelInvocation as never;
    }

    if (purify.Maybe.isMaybe(parameters.promptConstruction)) {
      this.promptConstruction = parameters.promptConstruction;
    } else if (
      typeof parameters.promptConstruction === "object" &&
      parameters.promptConstruction instanceof PromptConstruction
    ) {
      this.promptConstruction = purify.Maybe.of(parameters.promptConstruction);
    } else if (typeof parameters.promptConstruction === "undefined") {
      this.promptConstruction = purify.Maybe.empty();
    } else {
      this.promptConstruction = parameters.promptConstruction as never;
    }

    if (purify.Maybe.isMaybe(parameters.valueExtraction)) {
      this.valueExtraction = parameters.valueExtraction;
    } else if (
      typeof parameters.valueExtraction === "object" &&
      parameters.valueExtraction instanceof ValueExtraction
    ) {
      this.valueExtraction = purify.Maybe.of(parameters.valueExtraction);
    } else if (typeof parameters.valueExtraction === "undefined") {
      this.valueExtraction = purify.Maybe.empty();
    } else {
      this.valueExtraction = parameters.valueExtraction as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: QuestionAdministrationSubProcesses): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.languageModelInvocation,
          other.languageModelInvocation,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageModelInvocation",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.promptConstruction,
          other.promptConstruction,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "promptConstruction",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.valueExtraction,
          other.valueExtraction,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "valueExtraction",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.languageModelInvocation.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    this.promptConstruction.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    this.valueExtraction.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    return _hasher;
  }

  override toJson(): {
    readonly languageModelInvocation:
      | ReturnType<LanguageModelInvocation["toJson"]>
      | undefined;
    readonly promptConstruction:
      | ReturnType<PromptConstruction["toJson"]>
      | undefined;
    readonly valueExtraction: ReturnType<ValueExtraction["toJson"]> | undefined;
  } & ReturnType<ProcessSubProcesses["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        languageModelInvocation: this.languageModelInvocation
          .map((_item) => _item.toJson())
          .extract(),
        promptConstruction: this.promptConstruction
          .map((_item) => _item.toJson())
          .extract(),
        valueExtraction: this.valueExtraction
          .map((_item) => _item.toJson())
          .extract(),
      } satisfies ReturnType<QuestionAdministrationSubProcesses["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationSubProcesses",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModelInvocation",
      ),
      this.languageModelInvocation.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptConstruction",
      ),
      this.promptConstruction.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#valueExtraction",
      ),
      this.valueExtraction.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionAdministrationSubProcesses {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      languageModelInvocation: purify.Maybe<LanguageModelInvocation>;
      promptConstruction: purify.Maybe<PromptConstruction>;
      valueExtraction: purify.Maybe<ValueExtraction>;
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      questionAdministrationSubProcessesJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessSubProcesses.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const languageModelInvocation = purify.Maybe.fromNullable(
      _jsonObject["languageModelInvocation"],
    ).map((_item) => LanguageModelInvocation.fromJson(_item).unsafeCoerce());
    const promptConstruction = purify.Maybe.fromNullable(
      _jsonObject["promptConstruction"],
    ).map((_item) => PromptConstruction.fromJson(_item).unsafeCoerce());
    const valueExtraction = purify.Maybe.fromNullable(
      _jsonObject["valueExtraction"],
    ).map((_item) => ValueExtraction.fromJson(_item).unsafeCoerce());
    return purify.Either.of({
      ..._super0,
      identifier,
      languageModelInvocation,
      promptConstruction,
      valueExtraction,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionAdministrationSubProcesses> {
    return QuestionAdministrationSubProcesses.propertiesFromJson(json).map(
      (properties) => new QuestionAdministrationSubProcesses(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      languageModelInvocation: purify.Maybe<LanguageModelInvocation>;
      promptConstruction: purify.Maybe<PromptConstruction>;
      valueExtraction: purify.Maybe<ValueExtraction>;
    } & UnwrapR<ReturnType<typeof ProcessSubProcesses.propertiesFromRdf>>
  > {
    const _super0Either = ProcessSubProcesses.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationSubProcesses",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationSubProcesses",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _languageModelInvocationEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<LanguageModelInvocation>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#languageModelInvocation",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          LanguageModelInvocation.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_languageModelInvocationEither.isLeft()) {
      return _languageModelInvocationEither;
    }

    const languageModelInvocation =
      _languageModelInvocationEither.unsafeCoerce();
    const _promptConstructionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<PromptConstruction>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#promptConstruction",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          PromptConstruction.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_promptConstructionEither.isLeft()) {
      return _promptConstructionEither;
    }

    const promptConstruction = _promptConstructionEither.unsafeCoerce();
    const _valueExtractionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<ValueExtraction>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#valueExtraction",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          ValueExtraction.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_valueExtractionEither.isLeft()) {
      return _valueExtractionEither;
    }

    const valueExtraction = _valueExtractionEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      languageModelInvocation,
      promptConstruction,
      valueExtraction,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionAdministrationSubProcesses.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionAdministrationSubProcesses
  > {
    return QuestionAdministrationSubProcesses.propertiesFromRdf(parameters).map(
      (properties) => new QuestionAdministrationSubProcesses(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationSubProcesses",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionAdministrationSubProcessesJsonZodSchema());
  }

  export function questionAdministrationSubProcessesJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessSubProcesses.processSubProcessesJsonUiSchema({ scopePrefix }),
        LanguageModelInvocation.languageModelInvocationJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/languageModelInvocation`,
        }),
        PromptConstruction.promptConstructionJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/promptConstruction`,
        }),
        ValueExtraction.valueExtractionJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/valueExtraction`,
        }),
      ],
      label: "QuestionAdministrationSubProcesses",
      type: "Group",
    };
  }

  export function questionAdministrationSubProcessesJsonZodSchema() {
    return ProcessSubProcesses.processSubProcessesJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        languageModelInvocation:
          LanguageModelInvocation.languageModelInvocationJsonZodSchema().optional(),
        promptConstruction:
          PromptConstruction.promptConstructionJsonZodSchema().optional(),
        type: zod.literal("QuestionAdministrationSubProcesses"),
        valueExtraction:
          ValueExtraction.valueExtractionJsonZodSchema().optional(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionAdministrationSubProcesses.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionAdministrationSubProcesses.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionAdministrationSubProcesses.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionAdministrationSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministrationSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(
          `${variablePrefix}LanguageModelInvocation`,
        ),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelInvocation",
        ),
        subject,
      },
      ...LanguageModelInvocation.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${variablePrefix}LanguageModelInvocation`,
        ),
        variablePrefix: `${variablePrefix}LanguageModelInvocation`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}PromptConstruction`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptConstruction",
        ),
        subject,
      },
      ...PromptConstruction.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PromptConstruction`),
        variablePrefix: `${variablePrefix}PromptConstruction`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}ValueExtraction`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#valueExtraction",
        ),
        subject,
      },
      ...ValueExtraction.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ValueExtraction`),
        variablePrefix: `${variablePrefix}ValueExtraction`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionAdministrationSubProcesses");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministrationSubProcesses");
    return [
      ...ProcessSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationSubProcesses",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}LanguageModelInvocation`,
                ),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#languageModelInvocation",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...LanguageModelInvocation.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${variablePrefix}LanguageModelInvocation`,
            ),
            variablePrefix: `${variablePrefix}LanguageModelInvocation`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}PromptConstruction`,
                ),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#promptConstruction",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...PromptConstruction.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${variablePrefix}PromptConstruction`,
            ),
            variablePrefix: `${variablePrefix}PromptConstruction`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ValueExtraction`,
                ),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#valueExtraction",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...ValueExtraction.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}ValueExtraction`),
            variablePrefix: `${variablePrefix}ValueExtraction`,
          }),
        ],
        type: "optional",
      },
    ];
  }
}
export class QuestionAdministrationOutput extends ProcessOutput {
  readonly answer: Answer;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "QuestionAdministrationOutput";

  constructor(
    parameters: {
      readonly answer: Answer;
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    this.answer = parameters.answer;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: QuestionAdministrationOutput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.answer,
          other.answer,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "answer",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.answer.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly answer: ReturnType<Answer["toJson"]>;
  } & ReturnType<ProcessOutput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        answer: this.answer.toJson(),
      } satisfies ReturnType<QuestionAdministrationOutput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationOutput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#answer",
      ),
      this.answer.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionAdministrationOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { answer: Answer; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      questionAdministrationOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const answer = Answer.fromJson(_jsonObject["answer"]).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, answer, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionAdministrationOutput> {
    return QuestionAdministrationOutput.propertiesFromJson(json).map(
      (properties) => new QuestionAdministrationOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { answer: Answer; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationOutput",
          ),
        }),
      );
    }

    const _answerEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Answer
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#answer",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Answer.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_answerEither.isLeft()) {
      return _answerEither;
    }

    const answer = _answerEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, answer, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionAdministrationOutput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionAdministrationOutput
  > {
    return QuestionAdministrationOutput.propertiesFromRdf(parameters).map(
      (properties) => new QuestionAdministrationOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionAdministrationOutputJsonZodSchema());
  }

  export function questionAdministrationOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessOutput.processOutputJsonUiSchema({ scopePrefix }),
        Answer.answerJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/answer`,
        }),
      ],
      label: "QuestionAdministrationOutput",
      type: "Group",
    };
  }

  export function questionAdministrationOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        answer: Answer.answerJsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("QuestionAdministrationOutput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionAdministrationOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionAdministrationOutput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionAdministrationOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionAdministrationOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministrationOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Answer`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#answer",
        ),
        subject,
      },
      ...Answer.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Answer`),
        variablePrefix: `${variablePrefix}Answer`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionAdministrationOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministrationOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Answer`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#answer",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Answer.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Answer`),
        variablePrefix: `${variablePrefix}Answer`,
      }),
    ];
  }
}
export class QuestionAdministrationInput extends ProcessInput {
  readonly document: DocumentStub;
  private _identifier: rdfjs.NamedNode | undefined;
  readonly languageModel: LanguageModelSpecificationStub;
  readonly question: Question;
  override readonly type = "QuestionAdministrationInput";

  constructor(
    parameters: {
      readonly document: DocumentStub;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly languageModel: LanguageModelSpecificationStub;
      readonly question: Question;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.document = parameters.document;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.languageModel = parameters.languageModel;
    this.question = parameters.question;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: QuestionAdministrationInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.document,
          other.document,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "document",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.languageModel,
          other.languageModel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageModel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        Question.equals(this.question, other.question).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "question",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.document.hash(_hasher);
    this.languageModel.hash(_hasher);
    this.question.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly document: ReturnType<DocumentStub["toJson"]>;
    readonly languageModel: ReturnType<
      LanguageModelSpecificationStub["toJson"]
    >;
    readonly question:
      | ReturnType<CategoricalQuestion["toJson"]>
      | ReturnType<DichotomousQuestion["toJson"]>
      | ReturnType<RealValuedQuestion["toJson"]>
      | ReturnType<TextQuestion["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        document: this.document.toJson(),
        languageModel: this.languageModel.toJson(),
        question: this.question.toJson(),
      } satisfies ReturnType<QuestionAdministrationInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#document",
      ),
      this.document.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModel",
      ),
      this.languageModel.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#question",
      ),
      this.question.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionAdministrationInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      languageModel: LanguageModelSpecificationStub;
      question: Question;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      questionAdministrationInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const document = DocumentStub.fromJson(
      _jsonObject["document"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const languageModel = LanguageModelSpecificationStub.fromJson(
      _jsonObject["languageModel"],
    ).unsafeCoerce();
    const question = Question.fromJson(_jsonObject["question"]).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      document,
      identifier,
      languageModel,
      question,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionAdministrationInput> {
    return QuestionAdministrationInput.propertiesFromJson(json).map(
      (properties) => new QuestionAdministrationInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      languageModel: LanguageModelSpecificationStub;
      question: Question;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationInput",
          ),
        }),
      );
    }

    const _documentEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_documentEither.isLeft()) {
      return _documentEither;
    }

    const document = _documentEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _languageModelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      LanguageModelSpecificationStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        LanguageModelSpecificationStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_languageModelEither.isLeft()) {
      return _languageModelEither;
    }

    const languageModel = _languageModelEither.unsafeCoerce();
    const _questionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Question
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#question",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Question.fromRdf({ ..._context, resource: _resource }),
      );
    if (_questionEither.isLeft()) {
      return _questionEither;
    }

    const question = _questionEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      document,
      identifier,
      languageModel,
      question,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof QuestionAdministrationInput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    QuestionAdministrationInput
  > {
    return QuestionAdministrationInput.propertiesFromRdf(parameters).map(
      (properties) => new QuestionAdministrationInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionAdministrationInputJsonZodSchema());
  }

  export function questionAdministrationInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        DocumentStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/document`,
        }),
        LanguageModelSpecificationStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/languageModel`,
        }),
        { scope: `${scopePrefix}/properties/question`, type: "Control" },
      ],
      label: "QuestionAdministrationInput",
      type: "Group",
    };
  }

  export function questionAdministrationInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        document: DocumentStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        languageModel: LanguageModelSpecificationStub.jsonZodSchema(),
        question: Question.jsonZodSchema(),
        type: zod.literal("QuestionAdministrationInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionAdministrationInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionAdministrationInput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionAdministrationInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionAdministrationInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministrationInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Document`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        subject,
      },
      ...DocumentStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        subject,
      },
      ...LanguageModelSpecificationStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Question`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#question",
        ),
        subject,
      },
      ...Question.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Question`),
        variablePrefix: `${variablePrefix}Question`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("questionAdministrationInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministrationInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministrationInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Document`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#document",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModel",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...LanguageModelSpecificationStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Question`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#question",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Question.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Question`),
        variablePrefix: `${variablePrefix}Question`,
      }),
    ];
  }
}
export class QuestionAdministration extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: QuestionAdministrationInput;
  readonly output: Exception | QuestionAdministrationOutput;
  readonly subProcesses: QuestionAdministrationSubProcesses;
  override readonly type = "QuestionAdministration";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: QuestionAdministrationInput;
      readonly output: Exception | QuestionAdministrationOutput;
      readonly subProcesses: QuestionAdministrationSubProcesses;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
    this.subProcesses = parameters.subProcesses;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: QuestionAdministration): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | QuestionAdministrationOutput,
          right: Exception | QuestionAdministrationOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "QuestionAdministrationOutput" &&
            right.type === "QuestionAdministrationOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.subProcesses,
          other.subProcesses,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "subProcesses",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "QuestionAdministrationOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    this.subProcesses.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<QuestionAdministrationInput["toJson"]>;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<QuestionAdministrationOutput["toJson"]>;
    readonly subProcesses: ReturnType<
      QuestionAdministrationSubProcesses["toJson"]
    >;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "QuestionAdministrationOutput"
            ? this.output.toJson()
            : this.output.toJson(),
        subProcesses: this.subProcesses.toJson(),
      } satisfies ReturnType<QuestionAdministration["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministration",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "QuestionAdministrationOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#subProcesses",
      ),
      this.subProcesses.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace QuestionAdministration {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: QuestionAdministrationInput;
      output: Exception | QuestionAdministrationOutput;
      subProcesses: QuestionAdministrationSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      questionAdministrationJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = QuestionAdministrationInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "QuestionAdministrationOutput"
        ? QuestionAdministrationOutput.fromJson(
            _jsonObject["output"],
          ).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    const subProcesses = QuestionAdministrationSubProcesses.fromJson(
      _jsonObject["subProcesses"],
    ).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionAdministration> {
    return QuestionAdministration.propertiesFromJson(json).map(
      (properties) => new QuestionAdministration(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: QuestionAdministrationInput;
      output: Exception | QuestionAdministrationOutput;
      subProcesses: QuestionAdministrationSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#QuestionAdministration",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#QuestionAdministration",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      QuestionAdministrationInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        QuestionAdministrationInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | QuestionAdministrationOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | QuestionAdministrationOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            QuestionAdministrationOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | QuestionAdministrationOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    const _subProcessesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      QuestionAdministrationSubProcesses
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        QuestionAdministrationSubProcesses.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_subProcessesEither.isLeft()) {
      return _subProcessesEither;
    }

    const subProcesses = _subProcessesEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof QuestionAdministration.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, QuestionAdministration> {
    return QuestionAdministration.propertiesFromRdf(parameters).map(
      (properties) => new QuestionAdministration(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministration",
  );

  export function jsonSchema() {
    return zodToJsonSchema(questionAdministrationJsonZodSchema());
  }

  export function questionAdministrationJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        QuestionAdministrationInput.questionAdministrationInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
        QuestionAdministrationSubProcesses.questionAdministrationSubProcessesJsonUiSchema(
          { scopePrefix: `${scopePrefix}/properties/subProcesses` },
        ),
      ],
      label: "QuestionAdministration",
      type: "Group",
    };
  }

  export function questionAdministrationJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input:
          QuestionAdministrationInput.questionAdministrationInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          QuestionAdministrationOutput.questionAdministrationOutputJsonZodSchema(),
        ]),
        subProcesses:
          QuestionAdministrationSubProcesses.questionAdministrationSubProcessesJsonZodSchema(),
        type: zod.literal("QuestionAdministration"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionAdministration.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionAdministration.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionAdministration.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("questionAdministration");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministration");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...QuestionAdministrationInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...QuestionAdministrationOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        subject,
      },
      ...QuestionAdministrationSubProcesses.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        variablePrefix: `${variablePrefix}SubProcesses`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("questionAdministration");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "questionAdministration");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#QuestionAdministration",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...QuestionAdministrationInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...QuestionAdministrationOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#subProcesses",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...QuestionAdministrationSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        variablePrefix: `${variablePrefix}SubProcesses`,
      }),
    ];
  }
}
abstract class BaseQuestion extends InformationContentEntity {
  abstract override readonly identifier: rdfjs.NamedNode;
  readonly path: rdfjs.NamedNode;
  readonly promptTemplate: PromptTemplateLike;
  abstract override readonly type:
    | "CategoricalQuestion"
    | "DichotomousQuestion"
    | "RealValuedQuestion"
    | "TextQuestion";

  constructor(
    parameters: {
      readonly path: rdfjs.NamedNode | string;
      readonly promptTemplate: PromptTemplateLike;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.path === "object") {
      this.path = parameters.path;
    } else if (typeof parameters.path === "string") {
      this.path = dataFactory.namedNode(parameters.path);
    } else {
      this.path = parameters.path as never;
    }

    this.promptTemplate = parameters.promptTemplate;
  }

  override equals(other: BaseQuestion): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        booleanEquals(this.path, other.path).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "path",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        PromptTemplateLike.equals(
          this.promptTemplate,
          other.promptTemplate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "promptTemplate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.path.termType);
    _hasher.update(this.path.value);
    this.promptTemplate.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly path: { readonly "@id": string };
    readonly promptTemplate:
      | ReturnType<CompletionMessage["toJson"]>
      | ReturnType<Prompt["toJson"]>
      | ReturnType<PromptMessage["toJson"]>
      | ReturnType<PromptMessageTemplate["toJson"]>
      | ReturnType<PromptTemplate["toJson"]>;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        path: { "@id": this.path.value },
        promptTemplate: this.promptTemplate.toJson(),
      } satisfies ReturnType<BaseQuestion["toJson"]>),
    );
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/ns/shacl#path"),
      this.path,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptTemplateLike",
      ),
      this.promptTemplate.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace BaseQuestion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      path: rdfjs.NamedNode;
      promptTemplate: PromptTemplateLike;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = baseQuestionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const path = dataFactory.namedNode(_jsonObject["path"]["@id"]);
    const promptTemplate = PromptTemplateLike.fromJson(
      _jsonObject["promptTemplate"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, path, promptTemplate });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      path: rdfjs.NamedNode;
      promptTemplate: PromptTemplateLike;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    const _pathEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode
    > = _resource
      .values(dataFactory.namedNode("http://www.w3.org/ns/shacl#path"), {
        unique: true,
      })
      .head()
      .chain((_value) => _value.toIri());
    if (_pathEither.isLeft()) {
      return _pathEither;
    }

    const path = _pathEither.unsafeCoerce();
    const _promptTemplateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      PromptTemplateLike
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptTemplateLike",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        PromptTemplateLike.fromRdf({ ..._context, resource: _resource }),
      );
    if (_promptTemplateEither.isLeft()) {
      return _promptTemplateEither;
    }

    const promptTemplate = _promptTemplateEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, path, promptTemplate });
  }

  export function jsonSchema() {
    return zodToJsonSchema(baseQuestionJsonZodSchema());
  }

  export function baseQuestionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/path`, type: "Control" },
        { scope: `${scopePrefix}/properties/promptTemplate`, type: "Control" },
      ],
      label: "BaseQuestion",
      type: "Group",
    };
  }

  export function baseQuestionJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        path: zod.object({ "@id": zod.string().min(1) }),
        promptTemplate: PromptTemplateLike.jsonZodSchema(),
        type: zod.enum([
          "CategoricalQuestion",
          "DichotomousQuestion",
          "RealValuedQuestion",
          "TextQuestion",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseQuestion.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseQuestion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseQuestion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("baseQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseQuestion");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Path`),
        predicate: dataFactory.namedNode("http://www.w3.org/ns/shacl#path"),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}PromptTemplate`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptTemplateLike",
        ),
        subject,
      },
      ...PromptTemplateLike.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PromptTemplate`),
        variablePrefix: `${variablePrefix}PromptTemplate`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("baseQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseQuestion");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Path`),
            predicate: dataFactory.namedNode("http://www.w3.org/ns/shacl#path"),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}PromptTemplate`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#promptTemplateLike",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...PromptTemplateLike.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PromptTemplate`),
        variablePrefix: `${variablePrefix}PromptTemplate`,
      }),
    ];
  }
}
export class TextQuestion extends BaseQuestion {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "TextQuestion";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseQuestion>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#TextQuestion",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace TextQuestion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseQuestion.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = textQuestionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseQuestion.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TextQuestion> {
    return TextQuestion.propertiesFromJson(json).map(
      (properties) => new TextQuestion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseQuestion.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseQuestion.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#TextQuestion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#TextQuestion",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof TextQuestion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, TextQuestion> {
    return TextQuestion.propertiesFromRdf(parameters).map(
      (properties) => new TextQuestion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#TextQuestion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(textQuestionJsonZodSchema());
  }

  export function textQuestionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [BaseQuestion.baseQuestionJsonUiSchema({ scopePrefix })],
      label: "TextQuestion",
      type: "Group",
    };
  }

  export function textQuestionJsonZodSchema() {
    return BaseQuestion.baseQuestionJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("TextQuestion"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TextQuestion.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        TextQuestion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TextQuestion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("textQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textQuestion");
    return [
      ...BaseQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("textQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textQuestion");
    return [
      ...BaseQuestion.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#TextQuestion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class RealValuedQuestion extends BaseQuestion {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "RealValuedQuestion";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseQuestion>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#RealValuedQuestion",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace RealValuedQuestion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseQuestion.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      realValuedQuestionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseQuestion.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RealValuedQuestion> {
    return RealValuedQuestion.propertiesFromJson(json).map(
      (properties) => new RealValuedQuestion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseQuestion.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseQuestion.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#RealValuedQuestion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#RealValuedQuestion",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof RealValuedQuestion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RealValuedQuestion> {
    return RealValuedQuestion.propertiesFromRdf(parameters).map(
      (properties) => new RealValuedQuestion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#RealValuedQuestion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(realValuedQuestionJsonZodSchema());
  }

  export function realValuedQuestionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [BaseQuestion.baseQuestionJsonUiSchema({ scopePrefix })],
      label: "RealValuedQuestion",
      type: "Group",
    };
  }

  export function realValuedQuestionJsonZodSchema() {
    return BaseQuestion.baseQuestionJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("RealValuedQuestion"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RealValuedQuestion.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RealValuedQuestion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RealValuedQuestion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("realValuedQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "realValuedQuestion");
    return [
      ...BaseQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("realValuedQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "realValuedQuestion");
    return [
      ...BaseQuestion.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#RealValuedQuestion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
/**
 * prompt template
 */
export class PromptTemplate extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly inputValues: readonly PromptInputValue[];
  /**
   * message templates
   */
  readonly messageTemplates: readonly PromptMessageTemplate[];
  override readonly type = "PromptTemplate";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly inputValues?: readonly PromptInputValue[];
      readonly messageTemplates: readonly PromptMessageTemplate[];
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (typeof parameters.inputValues === "undefined") {
      this.inputValues = [];
    } else if (Array.isArray(parameters.inputValues)) {
      this.inputValues = parameters.inputValues;
    } else {
      this.inputValues = parameters.inputValues as never;
    }

    this.messageTemplates = parameters.messageTemplates;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptTemplate): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => arrayEquals(left, right, PromptInputValue.equals))(
          this.inputValues,
          other.inputValues,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inputValues",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, (left, right) => left.equals(right)))(
          this.messageTemplates,
          other.messageTemplates,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "messageTemplates",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _item0 of this.inputValues) {
      _item0.hash(_hasher);
    }

    for (const _element0 of this.messageTemplates) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly inputValues: readonly (
      | ReturnType<PromptLiteralInputValue["toJson"]>
      | ReturnType<PromptSparqlSelectInputValue["toJson"]>
    )[];
    readonly messageTemplates: readonly ReturnType<
      PromptMessageTemplate["toJson"]
    >[];
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        inputValues: this.inputValues.map((_item) => _item.toJson()),
        messageTemplates: this.messageTemplates.map((_item) => _item.toJson()),
      } satisfies ReturnType<PromptTemplate["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptTemplate",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
      ),
      this.inputValues.map((_item) =>
        _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptMessageTemplates",
      ),
      this.messageTemplates.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#PromptMessageTemplateList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.messageTemplates.reduce(
                (_hasher, _item) => {
                  _item.hash(_hasher);
                  return _hasher;
                },
                sha256.create(),
              )}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptTemplate {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      inputValues: readonly PromptInputValue[];
      messageTemplates: readonly PromptMessageTemplate[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = promptTemplateJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const inputValues = _jsonObject["inputValues"].map((_item) =>
      PromptInputValue.fromJson(_item).unsafeCoerce(),
    );
    const messageTemplates = _jsonObject["messageTemplates"].map((_item) =>
      PromptMessageTemplate.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ..._super0,
      identifier,
      inputValues,
      messageTemplates,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptTemplate> {
    return PromptTemplate.propertiesFromJson(json).map(
      (properties) => new PromptTemplate(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      inputValues: readonly PromptInputValue[];
      messageTemplates: readonly PromptMessageTemplate[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptTemplate",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptTemplate",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputValuesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly PromptInputValue[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
          ),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              PromptInputValue.fromRdf({ ..._context, resource: _resource }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_inputValuesEither.isLeft()) {
      return _inputValuesEither;
    }

    const inputValues = _inputValuesEither.unsafeCoerce();
    const _messageTemplatesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly PromptMessageTemplate[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessageTemplates",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              PromptMessageTemplate.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_messageTemplatesEither.isLeft()) {
      return _messageTemplatesEither;
    }

    const messageTemplates = _messageTemplatesEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      inputValues,
      messageTemplates,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof PromptTemplate.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PromptTemplate> {
    return PromptTemplate.propertiesFromRdf(parameters).map(
      (properties) => new PromptTemplate(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptTemplate",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptTemplateJsonZodSchema());
  }

  export function promptTemplateJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/inputValues`, type: "Control" },
        PromptMessageTemplate.promptMessageTemplateJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/messageTemplates`,
        }),
      ],
      label: "prompt template",
      type: "Group",
    };
  }

  export function promptTemplateJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        inputValues: PromptInputValue.jsonZodSchema().array(),
        messageTemplates:
          PromptMessageTemplate.promptMessageTemplateJsonZodSchema().array(),
        type: zod.literal("PromptTemplate"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptTemplate.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptTemplate.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptTemplate.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptTemplate");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "promptTemplate");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}InputValues`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
        ),
        subject,
      },
      ...PromptInputValue.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}InputValues`),
        variablePrefix: `${variablePrefix}InputValues`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}MessageTemplates`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessageTemplates",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}MessageTemplates`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}Item0`,
        ),
      },
      ...PromptMessageTemplate.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}MessageTemplates`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}MessageTemplates`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}Rest0`,
        ),
      },
      {
        subject: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}RestN`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}ItemN`,
        ),
      },
      ...PromptMessageTemplate.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}ItemN`,
        ),
        variablePrefix: `${`${variablePrefix}MessageTemplates`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}RestN`,
        ),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}RestNBasic`,
        ),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptTemplate");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "promptTemplate");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptTemplate",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}InputValues`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...PromptInputValue.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}InputValues`),
            variablePrefix: `${variablePrefix}InputValues`,
          }),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}MessageTemplates`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#promptMessageTemplates",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}MessageTemplates`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}MessageTemplates`}Item0`,
            ),
          },
        ],
      },
      ...PromptMessageTemplate.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(
          `${`${variablePrefix}MessageTemplates`}Item0`,
        ),
        variablePrefix: `${`${variablePrefix}MessageTemplates`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}MessageTemplates`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}MessageTemplates`}Rest0`,
            ),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${variablePrefix}MessageTemplates`,
                ),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}MessageTemplates`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}MessageTemplates`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}MessageTemplates`}ItemN`,
                ),
              },
            ],
          },
          ...PromptMessageTemplate.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}MessageTemplates`}ItemN`,
            ),
            variablePrefix: `${`${variablePrefix}MessageTemplates`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}MessageTemplates`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}MessageTemplates`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class PromptSparqlSelectInputValue extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly sparqlSelect: string;
  override readonly type = "PromptSparqlSelectInputValue";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly sparqlSelect: string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.sparqlSelect = parameters.sparqlSelect;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptSparqlSelectInputValue): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.sparqlSelect, other.sparqlSelect).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "sparqlSelect",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.sparqlSelect);
    return _hasher;
  }

  override toJson(): { readonly sparqlSelect: string } & ReturnType<
    InformationContentEntity["toJson"]
  > {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        sparqlSelect: this.sparqlSelect,
      } satisfies ReturnType<PromptSparqlSelectInputValue["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptSparqlSelectInputValue",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#sparqlSelect",
      ),
      this.sparqlSelect,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptSparqlSelectInputValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; sparqlSelect: string } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      promptSparqlSelectInputValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const sparqlSelect = _jsonObject["sparqlSelect"];
    return purify.Either.of({ ..._super0, identifier, sparqlSelect });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptSparqlSelectInputValue> {
    return PromptSparqlSelectInputValue.propertiesFromJson(json).map(
      (properties) => new PromptSparqlSelectInputValue(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; sparqlSelect: string } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromRdf>
    >
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptSparqlSelectInputValue",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptSparqlSelectInputValue",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _sparqlSelectEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#sparqlSelect",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_sparqlSelectEither.isLeft()) {
      return _sparqlSelectEither;
    }

    const sparqlSelect = _sparqlSelectEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, sparqlSelect });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof PromptSparqlSelectInputValue.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    PromptSparqlSelectInputValue
  > {
    return PromptSparqlSelectInputValue.propertiesFromRdf(parameters).map(
      (properties) => new PromptSparqlSelectInputValue(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptSparqlSelectInputValue",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptSparqlSelectInputValueJsonZodSchema());
  }

  export function promptSparqlSelectInputValueJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/sparqlSelect`, type: "Control" },
      ],
      label: "PromptSparqlSelectInputValue",
      type: "Group",
    };
  }

  export function promptSparqlSelectInputValueJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        sparqlSelect: zod.string(),
        type: zod.literal("PromptSparqlSelectInputValue"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptSparqlSelectInputValue.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptSparqlSelectInputValue.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptSparqlSelectInputValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("promptSparqlSelectInputValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptSparqlSelectInputValue");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}SparqlSelect`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#sparqlSelect",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("promptSparqlSelectInputValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptSparqlSelectInputValue");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptSparqlSelectInputValue",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}SparqlSelect`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#sparqlSelect",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class PromptLiteralInputValue extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  /**
   * has literal form
   */
  readonly literalForm: string;
  override readonly type = "PromptLiteralInputValue";
  readonly variable: string;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly literalForm: string;
      readonly variable: string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.literalForm = parameters.literalForm;
    this.variable = parameters.variable;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptLiteralInputValue): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.literalForm, other.literalForm).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "literalForm",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.variable, other.variable).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "variable",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.literalForm);
    _hasher.update(this.variable);
    return _hasher;
  }

  override toJson(): {
    readonly literalForm: string;
    readonly variable: string;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        literalForm: this.literalForm,
        variable: this.variable,
      } satisfies ReturnType<PromptLiteralInputValue["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptLiteralInputValue",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#literalForm",
      ),
      this.literalForm,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#variable",
      ),
      this.variable,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptLiteralInputValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      literalForm: string;
      variable: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      promptLiteralInputValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const literalForm = _jsonObject["literalForm"];
    const variable = _jsonObject["variable"];
    return purify.Either.of({ ..._super0, identifier, literalForm, variable });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptLiteralInputValue> {
    return PromptLiteralInputValue.propertiesFromJson(json).map(
      (properties) => new PromptLiteralInputValue(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      literalForm: string;
      variable: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptLiteralInputValue",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptLiteralInputValue",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _literalFormEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_literalFormEither.isLeft()) {
      return _literalFormEither;
    }

    const literalForm = _literalFormEither.unsafeCoerce();
    const _variableEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#variable",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_variableEither.isLeft()) {
      return _variableEither;
    }

    const variable = _variableEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, literalForm, variable });
  }

  export function fromRdf(
    parameters: Parameters<typeof PromptLiteralInputValue.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PromptLiteralInputValue> {
    return PromptLiteralInputValue.propertiesFromRdf(parameters).map(
      (properties) => new PromptLiteralInputValue(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptLiteralInputValue",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptLiteralInputValueJsonZodSchema());
  }

  export function promptLiteralInputValueJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        {
          label: "has literal form",
          scope: `${scopePrefix}/properties/literalForm`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/variable`, type: "Control" },
      ],
      label: "PromptLiteralInputValue",
      type: "Group",
    };
  }

  export function promptLiteralInputValueJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        literalForm: zod.string(),
        type: zod.literal("PromptLiteralInputValue"),
        variable: zod.string(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptLiteralInputValue.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptLiteralInputValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptLiteralInputValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptLiteralInputValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptLiteralInputValue");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Variable`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#variable",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptLiteralInputValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptLiteralInputValue");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptLiteralInputValue",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#literalForm",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Variable`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#variable",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class PromptConstructionOutput extends ProcessOutput {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly prompt: Prompt;
  override readonly type = "PromptConstructionOutput";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly prompt: Prompt;
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.prompt = parameters.prompt;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptConstructionOutput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.prompt,
          other.prompt,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "prompt",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.prompt.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly prompt: ReturnType<Prompt["toJson"]>;
  } & ReturnType<ProcessOutput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        prompt: this.prompt.toJson(),
      } satisfies ReturnType<PromptConstructionOutput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptConstructionOutput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#prompt",
      ),
      this.prompt.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptConstructionOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; prompt: Prompt } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      promptConstructionOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const prompt = Prompt.fromJson(_jsonObject["prompt"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, prompt });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptConstructionOutput> {
    return PromptConstructionOutput.propertiesFromJson(json).map(
      (properties) => new PromptConstructionOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; prompt: Prompt } & UnwrapR<
      ReturnType<typeof ProcessOutput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptConstructionOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptConstructionOutput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _promptEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Prompt
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#prompt",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Prompt.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_promptEither.isLeft()) {
      return _promptEither;
    }

    const prompt = _promptEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, prompt });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof PromptConstructionOutput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    PromptConstructionOutput
  > {
    return PromptConstructionOutput.propertiesFromRdf(parameters).map(
      (properties) => new PromptConstructionOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptConstructionOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptConstructionOutputJsonZodSchema());
  }

  export function promptConstructionOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessOutput.processOutputJsonUiSchema({ scopePrefix }),
        Prompt.promptJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/prompt`,
        }),
      ],
      label: "PromptConstructionOutput",
      type: "Group",
    };
  }

  export function promptConstructionOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        prompt: Prompt.promptJsonZodSchema(),
        type: zod.literal("PromptConstructionOutput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptConstructionOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptConstructionOutput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptConstructionOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptConstructionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptConstructionOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Prompt`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#prompt",
        ),
        subject,
      },
      ...Prompt.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Prompt`),
        variablePrefix: `${variablePrefix}Prompt`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptConstructionOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptConstructionOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptConstructionOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Prompt`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#prompt",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Prompt.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Prompt`),
        variablePrefix: `${variablePrefix}Prompt`,
      }),
    ];
  }
}
export class PromptConstructionInput extends ProcessInput {
  readonly concepts: purify.Maybe<readonly ConceptStub[]>;
  readonly document: DocumentStub;
  private _identifier: rdfjs.NamedNode | undefined;
  readonly question: Question;
  override readonly type = "PromptConstructionInput";

  constructor(
    parameters: {
      readonly concepts?:
        | purify.Maybe<readonly ConceptStub[]>
        | readonly ConceptStub[];
      readonly document: DocumentStub;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly question: Question;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.concepts)) {
      this.concepts = parameters.concepts;
    } else if (Array.isArray(parameters.concepts)) {
      this.concepts = purify.Maybe.of(parameters.concepts);
    } else if (typeof parameters.concepts === "undefined") {
      this.concepts = purify.Maybe.empty();
    } else {
      this.concepts = parameters.concepts as never;
    }

    this.document = parameters.document;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.question = parameters.question;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptConstructionInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) =>
            arrayEquals(left, right, ConceptStub.equals),
          ))(this.concepts, other.concepts).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "concepts",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.document,
          other.document,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "document",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        Question.equals(this.question, other.question).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "question",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.concepts.ifJust((_value0) => {
      for (const _element1 of _value0) {
        ConceptStub.hashConceptStub(_element1, _hasher);
      }
    });
    this.document.hash(_hasher);
    this.question.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly concepts:
      | readonly ReturnType<typeof ConceptStub.toJson>[]
      | undefined;
    readonly document: ReturnType<DocumentStub["toJson"]>;
    readonly question:
      | ReturnType<CategoricalQuestion["toJson"]>
      | ReturnType<DichotomousQuestion["toJson"]>
      | ReturnType<RealValuedQuestion["toJson"]>
      | ReturnType<TextQuestion["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        concepts: this.concepts
          .map((_item) => _item.map((_item) => ConceptStub.toJson(_item)))
          .extract(),
        document: this.document.toJson(),
        question: this.question.toJson(),
      } satisfies ReturnType<PromptConstructionInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptConstructionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#concepts",
      ),
      this.concepts.map(
        (_value) =>
          _value.reduce(
            (
              { currentSubListResource, listResource },
              item,
              itemIndex,
              list,
            ) => {
              if (itemIndex === 0) {
                currentSubListResource = listResource;
              } else {
                const newSubListResource = resourceSet.mutableNamedResource({
                  identifier: dataFactory.namedNode(
                    `${listResource.identifier.value}:${itemIndex}`,
                  ),
                  mutateGraph,
                });
                currentSubListResource!.add(
                  dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                  ),
                  newSubListResource.identifier,
                );
                currentSubListResource = newSubListResource;
              }

              currentSubListResource.add(
                dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                ),
                dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#ConceptStubList",
                ),
              );

              currentSubListResource.add(
                dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                ConceptStub.toRdf(item, {
                  mutateGraph: mutateGraph,
                  resourceSet: resourceSet,
                }),
              );

              if (itemIndex + 1 === list.length) {
                currentSubListResource.add(
                  dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                  ),
                  dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
                  ),
                );
              }

              return { currentSubListResource, listResource };
            },
            {
              currentSubListResource: null,
              listResource: resourceSet.mutableNamedResource({
                identifier: dataFactory.namedNode(
                  `urn:shaclmate:list:${_value.reduce((_hasher, _item) => {
                    ConceptStub.hashConceptStub(_item, _hasher);
                    return _hasher;
                  }, sha256.create())}`,
                ),
                mutateGraph,
              }),
            } as {
              currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
              listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
            },
          ).listResource.identifier,
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#document",
      ),
      this.document.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#question",
      ),
      this.question.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptConstructionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      concepts: purify.Maybe<readonly ConceptStub[]>;
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      question: Question;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      promptConstructionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const concepts = purify.Maybe.fromNullable(_jsonObject["concepts"]).map(
      (_item) =>
        _item.map((_item) => ConceptStub.fromJson(_item).unsafeCoerce()),
    );
    const document = DocumentStub.fromJson(
      _jsonObject["document"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const question = Question.fromJson(_jsonObject["question"]).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      concepts,
      document,
      identifier,
      question,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptConstructionInput> {
    return PromptConstructionInput.propertiesFromJson(json).map(
      (properties) => new PromptConstructionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      concepts: purify.Maybe<readonly ConceptStub[]>;
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      question: Question;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptConstructionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptConstructionInput",
          ),
        }),
      );
    }

    const _conceptsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<readonly ConceptStub[]>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#concepts",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toList())
        .map((values) =>
          values.flatMap((_value) =>
            _value
              .toValues()
              .head()
              .chain((value) => value.toNamedResource())
              .chain((_resource) =>
                ConceptStub.fromRdf({
                  ..._context,
                  ignoreRdfType: true,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              )
              .toMaybe()
              .toList(),
          ),
        )
        .toMaybe(),
    );
    if (_conceptsEither.isLeft()) {
      return _conceptsEither;
    }

    const concepts = _conceptsEither.unsafeCoerce();
    const _documentEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_documentEither.isLeft()) {
      return _documentEither;
    }

    const document = _documentEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _questionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Question
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#question",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Question.fromRdf({ ..._context, resource: _resource }),
      );
    if (_questionEither.isLeft()) {
      return _questionEither;
    }

    const question = _questionEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      concepts,
      document,
      identifier,
      question,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof PromptConstructionInput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PromptConstructionInput> {
    return PromptConstructionInput.propertiesFromRdf(parameters).map(
      (properties) => new PromptConstructionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptConstructionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptConstructionInputJsonZodSchema());
  }

  export function promptConstructionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        ConceptStub.conceptStubJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/concepts`,
        }),
        DocumentStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/document`,
        }),
        { scope: `${scopePrefix}/properties/question`, type: "Control" },
      ],
      label: "PromptConstructionInput",
      type: "Group",
    };
  }

  export function promptConstructionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        concepts: ConceptStub.conceptStubJsonZodSchema().array().optional(),
        document: DocumentStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        question: Question.jsonZodSchema(),
        type: zod.literal("PromptConstructionInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptConstructionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptConstructionInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptConstructionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptConstructionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptConstructionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Concepts`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#concepts",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Concepts`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Concepts`}Item0`),
      },
      ...ConceptStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}Item0`),
        variablePrefix: `${`${variablePrefix}Concepts`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Concepts`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Concepts`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Concepts`}ItemN`),
      },
      ...ConceptStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}ItemN`),
        variablePrefix: `${`${variablePrefix}Concepts`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}Concepts`}RestNBasic`,
        ),
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Document`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        subject,
      },
      ...DocumentStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Question`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#question",
        ),
        subject,
      },
      ...Question.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Question`),
        variablePrefix: `${variablePrefix}Question`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptConstructionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptConstructionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptConstructionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Concepts`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#concepts",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Concepts`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}Item0`,
                ),
              },
            ],
          },
          ...ConceptStub.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}Concepts`}Item0`,
            ),
            variablePrefix: `${`${variablePrefix}Concepts`}Item0`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Concepts`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}Rest0`,
                ),
              },
            ],
          },
          {
            type: "optional",
            patterns: [
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(`${variablePrefix}Concepts`),
                    predicate: {
                      type: "path",
                      pathType: "*",
                      items: [
                        dataFactory.namedNode(
                          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                        ),
                      ],
                    },
                    object: dataFactory.variable!(
                      `${`${variablePrefix}Concepts`}RestN`,
                    ),
                  },
                ],
              },
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${`${variablePrefix}Concepts`}RestN`,
                    ),
                    predicate: dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                    ),
                    object: dataFactory.variable!(
                      `${`${variablePrefix}Concepts`}ItemN`,
                    ),
                  },
                ],
              },
              ...ConceptStub.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}ItemN`,
                ),
                variablePrefix: `${`${variablePrefix}Concepts`}ItemN`,
              }),
              {
                type: "bgp",
                triples: [
                  {
                    subject: dataFactory.variable!(
                      `${`${variablePrefix}Concepts`}RestN`,
                    ),
                    predicate: dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                    object: dataFactory.variable!(
                      `${`${variablePrefix}Concepts`}RestNBasic`,
                    ),
                  },
                ],
              },
            ],
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Document`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#document",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Question`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#question",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Question.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Question`),
        variablePrefix: `${variablePrefix}Question`,
      }),
    ];
  }
}
export class PromptConstruction extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: PromptConstructionInput;
  readonly output: Exception | PromptConstructionOutput;
  override readonly type = "PromptConstruction";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: PromptConstructionInput;
      readonly output: Exception | PromptConstructionOutput;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptConstruction): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | PromptConstructionOutput,
          right: Exception | PromptConstructionOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "PromptConstructionOutput" &&
            right.type === "PromptConstructionOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "PromptConstructionOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<PromptConstructionInput["toJson"]>;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<PromptConstructionOutput["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "PromptConstructionOutput"
            ? this.output.toJson()
            : this.output.toJson(),
      } satisfies ReturnType<PromptConstruction["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptConstruction",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "PromptConstructionOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptConstruction {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: PromptConstructionInput;
      output: Exception | PromptConstructionOutput;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      promptConstructionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = PromptConstructionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "PromptConstructionOutput"
        ? PromptConstructionOutput.fromJson(
            _jsonObject["output"],
          ).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input, output });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptConstruction> {
    return PromptConstruction.propertiesFromJson(json).map(
      (properties) => new PromptConstruction(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: PromptConstructionInput;
      output: Exception | PromptConstructionOutput;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptConstruction",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptConstruction",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      PromptConstructionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        PromptConstructionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | PromptConstructionOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | PromptConstructionOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            PromptConstructionOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | PromptConstructionOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input, output });
  }

  export function fromRdf(
    parameters: Parameters<typeof PromptConstruction.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PromptConstruction> {
    return PromptConstruction.propertiesFromRdf(parameters).map(
      (properties) => new PromptConstruction(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptConstruction",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptConstructionJsonZodSchema());
  }

  export function promptConstructionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        PromptConstructionInput.promptConstructionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
      ],
      label: "PromptConstruction",
      type: "Group",
    };
  }

  export function promptConstructionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input: PromptConstructionInput.promptConstructionInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          PromptConstructionOutput.promptConstructionOutputJsonZodSchema(),
        ]),
        type: zod.literal("PromptConstruction"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptConstruction.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptConstruction.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptConstruction.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptConstruction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "promptConstruction");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...PromptConstructionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...PromptConstructionOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptConstruction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "promptConstruction");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptConstruction",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...PromptConstructionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...PromptConstructionOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }
}
abstract class BaseEvent extends Entity {
  abstract override readonly identifier: rdfjs.NamedNode;
  readonly timestamp: Date;
  abstract override readonly type:
    | "PostWorkflowExecutionEvent"
    | "PostWorkflowStepExecutionEvent"
    | "PreWorkflowExecutionEvent"
    | "PreWorkflowStepExecutionEvent";

  constructor(
    parameters: { readonly timestamp: Date } & ConstructorParameters<
      typeof Entity
    >[0],
  ) {
    super(parameters);
    this.timestamp = parameters.timestamp;
  }

  override equals(other: BaseEvent): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        dateEquals(this.timestamp, other.timestamp).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "timestamp",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.timestamp.toISOString());
    return _hasher;
  }

  override toJson(): { readonly timestamp: string } & ReturnType<
    Entity["toJson"]
  > {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        timestamp: this.timestamp.toISOString(),
      } satisfies ReturnType<BaseEvent["toJson"]>),
    );
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#timestamp",
      ),
      this.timestamp,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace BaseEvent {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; timestamp: Date } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = baseEventJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Entity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const timestamp = new Date(_jsonObject["timestamp"]);
    return purify.Either.of({ ..._super0, identifier, timestamp });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; timestamp: Date } & UnwrapR<
      ReturnType<typeof Entity.propertiesFromRdf>
    >
  > {
    const _super0Either = Entity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    const _timestampEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Date
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#timestamp",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toDate());
    if (_timestampEither.isLeft()) {
      return _timestampEither;
    }

    const timestamp = _timestampEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, timestamp });
  }

  export function jsonSchema() {
    return zodToJsonSchema(baseEventJsonZodSchema());
  }

  export function baseEventJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Entity.entityJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/timestamp`, type: "Control" },
      ],
      label: "BaseEvent",
      type: "Group",
    };
  }

  export function baseEventJsonZodSchema() {
    return Entity.entityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        timestamp: zod.string().datetime(),
        type: zod.enum([
          "PostWorkflowExecutionEvent",
          "PostWorkflowStepExecutionEvent",
          "PreWorkflowExecutionEvent",
          "PreWorkflowStepExecutionEvent",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseEvent.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseEvent.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseEvent.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("baseEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseEvent");
    return [
      ...Entity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Timestamp`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#timestamp",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("baseEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseEvent");
    return [
      ...Entity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Timestamp`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#timestamp",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class PreWorkflowStepExecutionEvent extends BaseEvent {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly payload: WorkflowStepExecutionInput;
  override readonly type = "PreWorkflowStepExecutionEvent";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly payload: WorkflowStepExecutionInput;
    } & ConstructorParameters<typeof BaseEvent>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.payload = parameters.payload;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PreWorkflowStepExecutionEvent): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        WorkflowStepExecutionInput.equals(this.payload, other.payload).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "payload",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.payload.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly payload: ReturnType<
      WorkflowQuestionnaireStepExecutionInput["toJson"]
    >;
  } & ReturnType<BaseEvent["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        payload: this.payload.toJson(),
      } satisfies ReturnType<PreWorkflowStepExecutionEvent["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PreWorkflowStepExecutionEvent",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#eventPayload",
      ),
      this.payload.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PreWorkflowStepExecutionEvent {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      payload: WorkflowStepExecutionInput;
    } & UnwrapR<ReturnType<typeof BaseEvent.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      preWorkflowStepExecutionEventJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseEvent.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const payload = WorkflowStepExecutionInput.fromJson(
      _jsonObject["payload"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PreWorkflowStepExecutionEvent> {
    return PreWorkflowStepExecutionEvent.propertiesFromJson(json).map(
      (properties) => new PreWorkflowStepExecutionEvent(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      payload: WorkflowStepExecutionInput;
    } & UnwrapR<ReturnType<typeof BaseEvent.propertiesFromRdf>>
  > {
    const _super0Either = BaseEvent.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PreWorkflowStepExecutionEvent",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PreWorkflowStepExecutionEvent",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _payloadEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStepExecutionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowStepExecutionInput.fromRdf({
          ..._context,
          resource: _resource,
        }),
      );
    if (_payloadEither.isLeft()) {
      return _payloadEither;
    }

    const payload = _payloadEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof PreWorkflowStepExecutionEvent.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    PreWorkflowStepExecutionEvent
  > {
    return PreWorkflowStepExecutionEvent.propertiesFromRdf(parameters).map(
      (properties) => new PreWorkflowStepExecutionEvent(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PreWorkflowStepExecutionEvent",
  );

  export function jsonSchema() {
    return zodToJsonSchema(preWorkflowStepExecutionEventJsonZodSchema());
  }

  export function preWorkflowStepExecutionEventJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseEvent.baseEventJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/payload`, type: "Control" },
      ],
      label: "PreWorkflowStepExecutionEvent",
      type: "Group",
    };
  }

  export function preWorkflowStepExecutionEventJsonZodSchema() {
    return BaseEvent.baseEventJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        payload: WorkflowStepExecutionInput.jsonZodSchema(),
        type: zod.literal("PreWorkflowStepExecutionEvent"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PreWorkflowStepExecutionEvent.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PreWorkflowStepExecutionEvent.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PreWorkflowStepExecutionEvent.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("preWorkflowStepExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "preWorkflowStepExecutionEvent");
    return [
      ...BaseEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Payload`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        subject,
      },
      ...WorkflowStepExecutionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("preWorkflowStepExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "preWorkflowStepExecutionEvent");
    return [
      ...BaseEvent.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PreWorkflowStepExecutionEvent",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Payload`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#eventPayload",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowStepExecutionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }
}
export class WorkflowExecutionInput extends ProcessInput {
  readonly document: DocumentStub;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "WorkflowExecutionInput";
  readonly workflow: WorkflowStub;

  constructor(
    parameters: {
      readonly document: DocumentStub;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly workflow: WorkflowStub;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.document = parameters.document;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.workflow = parameters.workflow;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowExecutionInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.document,
          other.document,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "document",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.workflow,
          other.workflow,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "workflow",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.document.hash(_hasher);
    this.workflow.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly document: ReturnType<DocumentStub["toJson"]>;
    readonly workflow: ReturnType<WorkflowStub["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        document: this.document.toJson(),
        workflow: this.workflow.toJson(),
      } satisfies ReturnType<WorkflowExecutionInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#document",
      ),
      this.document.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#workflow",
      ),
      this.workflow.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowExecutionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      workflow: WorkflowStub;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowExecutionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const document = DocumentStub.fromJson(
      _jsonObject["document"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const workflow = WorkflowStub.fromJson(
      _jsonObject["workflow"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, document, identifier, workflow });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowExecutionInput> {
    return WorkflowExecutionInput.propertiesFromJson(json).map(
      (properties) => new WorkflowExecutionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      document: DocumentStub;
      identifier: rdfjs.NamedNode;
      workflow: WorkflowStub;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionInput",
          ),
        }),
      );
    }

    const _documentEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_documentEither.isLeft()) {
      return _documentEither;
    }

    const document = _documentEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _workflowEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflow",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_workflowEither.isLeft()) {
      return _workflowEither;
    }

    const workflow = _workflowEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, document, identifier, workflow });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowExecutionInput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowExecutionInput> {
    return WorkflowExecutionInput.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowExecutionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowExecutionInputJsonZodSchema());
  }

  export function workflowExecutionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        DocumentStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/document`,
        }),
        WorkflowStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/workflow`,
        }),
      ],
      label: "WorkflowExecutionInput",
      type: "Group",
    };
  }

  export function workflowExecutionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        document: DocumentStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("WorkflowExecutionInput"),
        workflow: WorkflowStub.jsonZodSchema(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowExecutionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowExecutionInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowExecutionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecutionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Document`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        subject,
      },
      ...DocumentStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Workflow`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#workflow",
        ),
        subject,
      },
      ...WorkflowStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Workflow`),
        variablePrefix: `${variablePrefix}Workflow`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecutionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "workflowExecutionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecutionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Document`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#document",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Workflow`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#workflow",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Workflow`),
        variablePrefix: `${variablePrefix}Workflow`,
      }),
    ];
  }
}
export class PreWorkflowExecutionEvent extends BaseEvent {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly payload: WorkflowExecutionInput;
  override readonly type = "PreWorkflowExecutionEvent";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly payload: WorkflowExecutionInput;
    } & ConstructorParameters<typeof BaseEvent>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.payload = parameters.payload;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PreWorkflowExecutionEvent): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.payload,
          other.payload,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "payload",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.payload.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly payload: ReturnType<WorkflowExecutionInput["toJson"]>;
  } & ReturnType<BaseEvent["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        payload: this.payload.toJson(),
      } satisfies ReturnType<PreWorkflowExecutionEvent["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PreWorkflowExecutionEvent",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#eventPayload",
      ),
      this.payload.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PreWorkflowExecutionEvent {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; payload: WorkflowExecutionInput } & UnwrapR<
      ReturnType<typeof BaseEvent.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      preWorkflowExecutionEventJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseEvent.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const payload = WorkflowExecutionInput.fromJson(
      _jsonObject["payload"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PreWorkflowExecutionEvent> {
    return PreWorkflowExecutionEvent.propertiesFromJson(json).map(
      (properties) => new PreWorkflowExecutionEvent(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; payload: WorkflowExecutionInput } & UnwrapR<
      ReturnType<typeof BaseEvent.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseEvent.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PreWorkflowExecutionEvent",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PreWorkflowExecutionEvent",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _payloadEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowExecutionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowExecutionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_payloadEither.isLeft()) {
      return _payloadEither;
    }

    const payload = _payloadEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof PreWorkflowExecutionEvent.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    PreWorkflowExecutionEvent
  > {
    return PreWorkflowExecutionEvent.propertiesFromRdf(parameters).map(
      (properties) => new PreWorkflowExecutionEvent(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PreWorkflowExecutionEvent",
  );

  export function jsonSchema() {
    return zodToJsonSchema(preWorkflowExecutionEventJsonZodSchema());
  }

  export function preWorkflowExecutionEventJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseEvent.baseEventJsonUiSchema({ scopePrefix }),
        WorkflowExecutionInput.workflowExecutionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/payload`,
        }),
      ],
      label: "PreWorkflowExecutionEvent",
      type: "Group",
    };
  }

  export function preWorkflowExecutionEventJsonZodSchema() {
    return BaseEvent.baseEventJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        payload: WorkflowExecutionInput.workflowExecutionInputJsonZodSchema(),
        type: zod.literal("PreWorkflowExecutionEvent"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PreWorkflowExecutionEvent.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PreWorkflowExecutionEvent.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PreWorkflowExecutionEvent.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("preWorkflowExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "preWorkflowExecutionEvent");
    return [
      ...BaseEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Payload`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        subject,
      },
      ...WorkflowExecutionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("preWorkflowExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "preWorkflowExecutionEvent");
    return [
      ...BaseEvent.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PreWorkflowExecutionEvent",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Payload`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#eventPayload",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowExecutionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }
}
export class PostWorkflowStepExecutionEvent extends BaseEvent {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly payload: WorkflowStepExecution;
  override readonly type = "PostWorkflowStepExecutionEvent";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly payload: WorkflowStepExecution;
    } & ConstructorParameters<typeof BaseEvent>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.payload = parameters.payload;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PostWorkflowStepExecutionEvent): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        WorkflowStepExecution.equals(this.payload, other.payload).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "payload",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.payload.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly payload: ReturnType<WorkflowQuestionnaireStepExecution["toJson"]>;
  } & ReturnType<BaseEvent["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        payload: this.payload.toJson(),
      } satisfies ReturnType<PostWorkflowStepExecutionEvent["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PostWorkflowStepExecutionEvent",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#eventPayload",
      ),
      this.payload.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PostWorkflowStepExecutionEvent {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; payload: WorkflowStepExecution } & UnwrapR<
      ReturnType<typeof BaseEvent.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      postWorkflowStepExecutionEventJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseEvent.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const payload = WorkflowStepExecution.fromJson(
      _jsonObject["payload"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PostWorkflowStepExecutionEvent> {
    return PostWorkflowStepExecutionEvent.propertiesFromJson(json).map(
      (properties) => new PostWorkflowStepExecutionEvent(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; payload: WorkflowStepExecution } & UnwrapR<
      ReturnType<typeof BaseEvent.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseEvent.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PostWorkflowStepExecutionEvent",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PostWorkflowStepExecutionEvent",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _payloadEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStepExecution
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowStepExecution.fromRdf({ ..._context, resource: _resource }),
      );
    if (_payloadEither.isLeft()) {
      return _payloadEither;
    }

    const payload = _payloadEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof PostWorkflowStepExecutionEvent.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    PostWorkflowStepExecutionEvent
  > {
    return PostWorkflowStepExecutionEvent.propertiesFromRdf(parameters).map(
      (properties) => new PostWorkflowStepExecutionEvent(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PostWorkflowStepExecutionEvent",
  );

  export function jsonSchema() {
    return zodToJsonSchema(postWorkflowStepExecutionEventJsonZodSchema());
  }

  export function postWorkflowStepExecutionEventJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseEvent.baseEventJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/payload`, type: "Control" },
      ],
      label: "PostWorkflowStepExecutionEvent",
      type: "Group",
    };
  }

  export function postWorkflowStepExecutionEventJsonZodSchema() {
    return BaseEvent.baseEventJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        payload: WorkflowStepExecution.jsonZodSchema(),
        type: zod.literal("PostWorkflowStepExecutionEvent"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PostWorkflowStepExecutionEvent.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PostWorkflowStepExecutionEvent.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PostWorkflowStepExecutionEvent.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("postWorkflowStepExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "postWorkflowStepExecutionEvent");
    return [
      ...BaseEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Payload`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        subject,
      },
      ...WorkflowStepExecution.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("postWorkflowStepExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "postWorkflowStepExecutionEvent");
    return [
      ...BaseEvent.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PostWorkflowStepExecutionEvent",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Payload`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#eventPayload",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowStepExecution.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }
}
export class WorkflowExecution extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: WorkflowExecutionInput;
  readonly output: Exception | WorkflowExecutionOutput;
  readonly subProcesses: WorkflowExecutionSubProcesses;
  override readonly type = "WorkflowExecution";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: WorkflowExecutionInput;
      readonly output: Exception | WorkflowExecutionOutput;
      readonly subProcesses: WorkflowExecutionSubProcesses;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
    this.subProcesses = parameters.subProcesses;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: WorkflowExecution): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | WorkflowExecutionOutput,
          right: Exception | WorkflowExecutionOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "WorkflowExecutionOutput" &&
            right.type === "WorkflowExecutionOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.subProcesses,
          other.subProcesses,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "subProcesses",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "WorkflowExecutionOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    this.subProcesses.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<WorkflowExecutionInput["toJson"]>;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<WorkflowExecutionOutput["toJson"]>;
    readonly subProcesses: ReturnType<WorkflowExecutionSubProcesses["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "WorkflowExecutionOutput"
            ? this.output.toJson()
            : this.output.toJson(),
        subProcesses: this.subProcesses.toJson(),
      } satisfies ReturnType<WorkflowExecution["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "WorkflowExecutionOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#subProcesses",
      ),
      this.subProcesses.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace WorkflowExecution {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: WorkflowExecutionInput;
      output: Exception | WorkflowExecutionOutput;
      subProcesses: WorkflowExecutionSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      workflowExecutionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = WorkflowExecutionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "WorkflowExecutionOutput"
        ? WorkflowExecutionOutput.fromJson(_jsonObject["output"]).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    const subProcesses = WorkflowExecutionSubProcesses.fromJson(
      _jsonObject["subProcesses"],
    ).unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowExecution> {
    return WorkflowExecution.propertiesFromJson(json).map(
      (properties) => new WorkflowExecution(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: WorkflowExecutionInput;
      output: Exception | WorkflowExecutionOutput;
      subProcesses: WorkflowExecutionSubProcesses;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowExecutionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowExecutionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | WorkflowExecutionOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | WorkflowExecutionOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            WorkflowExecutionOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | WorkflowExecutionOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    const _subProcessesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowExecutionSubProcesses
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowExecutionSubProcesses.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_subProcessesEither.isLeft()) {
      return _subProcessesEither;
    }

    const subProcesses = _subProcessesEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      input,
      output,
      subProcesses,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof WorkflowExecution.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, WorkflowExecution> {
    return WorkflowExecution.propertiesFromRdf(parameters).map(
      (properties) => new WorkflowExecution(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
  );

  export function jsonSchema() {
    return zodToJsonSchema(workflowExecutionJsonZodSchema());
  }

  export function workflowExecutionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        WorkflowExecutionInput.workflowExecutionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
        WorkflowExecutionSubProcesses.workflowExecutionSubProcessesJsonUiSchema(
          { scopePrefix: `${scopePrefix}/properties/subProcesses` },
        ),
      ],
      label: "WorkflowExecution",
      type: "Group",
    };
  }

  export function workflowExecutionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input: WorkflowExecutionInput.workflowExecutionInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          WorkflowExecutionOutput.workflowExecutionOutputJsonZodSchema(),
        ]),
        subProcesses:
          WorkflowExecutionSubProcesses.workflowExecutionSubProcessesJsonZodSchema(),
        type: zod.literal("WorkflowExecution"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowExecution.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowExecution.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowExecution.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecution");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflowExecution");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...WorkflowExecutionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...WorkflowExecutionOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#subProcesses",
        ),
        subject,
      },
      ...WorkflowExecutionSubProcesses.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        variablePrefix: `${variablePrefix}SubProcesses`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("workflowExecution");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "workflowExecution");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#WorkflowExecution",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowExecutionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...WorkflowExecutionOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}SubProcesses`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#subProcesses",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowExecutionSubProcesses.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubProcesses`),
        variablePrefix: `${variablePrefix}SubProcesses`,
      }),
    ];
  }
}
export class PostWorkflowExecutionEvent extends BaseEvent {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly payload: WorkflowExecution;
  override readonly type = "PostWorkflowExecutionEvent";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly payload: WorkflowExecution;
    } & ConstructorParameters<typeof BaseEvent>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.payload = parameters.payload;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PostWorkflowExecutionEvent): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.payload,
          other.payload,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "payload",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.payload.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly payload: ReturnType<WorkflowExecution["toJson"]>;
  } & ReturnType<BaseEvent["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        payload: this.payload.toJson(),
      } satisfies ReturnType<PostWorkflowExecutionEvent["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PostWorkflowExecutionEvent",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#eventPayload",
      ),
      this.payload.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PostWorkflowExecutionEvent {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; payload: WorkflowExecution } & UnwrapR<
      ReturnType<typeof BaseEvent.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      postWorkflowExecutionEventJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseEvent.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const payload = WorkflowExecution.fromJson(
      _jsonObject["payload"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PostWorkflowExecutionEvent> {
    return PostWorkflowExecutionEvent.propertiesFromJson(json).map(
      (properties) => new PostWorkflowExecutionEvent(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; payload: WorkflowExecution } & UnwrapR<
      ReturnType<typeof BaseEvent.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseEvent.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PostWorkflowExecutionEvent",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PostWorkflowExecutionEvent",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _payloadEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowExecution
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        WorkflowExecution.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_payloadEither.isLeft()) {
      return _payloadEither;
    }

    const payload = _payloadEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, payload });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof PostWorkflowExecutionEvent.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    PostWorkflowExecutionEvent
  > {
    return PostWorkflowExecutionEvent.propertiesFromRdf(parameters).map(
      (properties) => new PostWorkflowExecutionEvent(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PostWorkflowExecutionEvent",
  );

  export function jsonSchema() {
    return zodToJsonSchema(postWorkflowExecutionEventJsonZodSchema());
  }

  export function postWorkflowExecutionEventJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseEvent.baseEventJsonUiSchema({ scopePrefix }),
        WorkflowExecution.workflowExecutionJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/payload`,
        }),
      ],
      label: "PostWorkflowExecutionEvent",
      type: "Group",
    };
  }

  export function postWorkflowExecutionEventJsonZodSchema() {
    return BaseEvent.baseEventJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        payload: WorkflowExecution.workflowExecutionJsonZodSchema(),
        type: zod.literal("PostWorkflowExecutionEvent"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PostWorkflowExecutionEvent.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PostWorkflowExecutionEvent.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PostWorkflowExecutionEvent.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("postWorkflowExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "postWorkflowExecutionEvent");
    return [
      ...BaseEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Payload`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#eventPayload",
        ),
        subject,
      },
      ...WorkflowExecution.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("postWorkflowExecutionEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "postWorkflowExecutionEvent");
    return [
      ...BaseEvent.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PostWorkflowExecutionEvent",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Payload`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#eventPayload",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...WorkflowExecution.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Payload`),
        variablePrefix: `${variablePrefix}Payload`,
      }),
    ];
  }
}
export class LanguageModelSpecification extends InformationContentEntity {
  readonly apiIdentifier: string;
  readonly contextWindow: number;
  readonly family: LanguageModelFamily;
  private _identifier: rdfjs.NamedNode | undefined;
  /**
   * has label
   */
  readonly label: string;
  override readonly type = "LanguageModelSpecification";

  constructor(
    parameters: {
      readonly apiIdentifier: string;
      readonly contextWindow: number;
      readonly family: LanguageModelFamily;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly label: string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    this.apiIdentifier = parameters.apiIdentifier;
    this.contextWindow = parameters.contextWindow;
    this.family = parameters.family;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.label = parameters.label;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: LanguageModelSpecification): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.apiIdentifier, other.apiIdentifier).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "apiIdentifier",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.contextWindow, other.contextWindow).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "contextWindow",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.family,
          other.family,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "family",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.label, other.label).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "label",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.apiIdentifier);
    _hasher.update(this.contextWindow.toString());
    this.family.hash(_hasher);
    _hasher.update(this.label);
    return _hasher;
  }

  override toJson(): {
    readonly apiIdentifier: string;
    readonly contextWindow: number;
    readonly family: ReturnType<LanguageModelFamily["toJson"]>;
    readonly label: string;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        apiIdentifier: this.apiIdentifier,
        contextWindow: this.contextWindow,
        family: this.family.toJson(),
        label: this.label,
      } satisfies ReturnType<LanguageModelSpecification["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModelApiIdentifier",
      ),
      this.apiIdentifier,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModelContextWindow",
      ),
      this.contextWindow,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModelFamily",
      ),
      this.family.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelSpecification {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      apiIdentifier: string;
      contextWindow: number;
      family: LanguageModelFamily;
      identifier: rdfjs.NamedNode;
      label: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      languageModelSpecificationJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const apiIdentifier = _jsonObject["apiIdentifier"];
    const contextWindow = _jsonObject["contextWindow"];
    const family = LanguageModelFamily.fromJson(
      _jsonObject["family"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = _jsonObject["label"];
    return purify.Either.of({
      ..._super0,
      apiIdentifier,
      contextWindow,
      family,
      identifier,
      label,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelSpecification> {
    return LanguageModelSpecification.propertiesFromJson(json).map(
      (properties) => new LanguageModelSpecification(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      apiIdentifier: string;
      contextWindow: number;
      family: LanguageModelFamily;
      identifier: rdfjs.NamedNode;
      label: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
          ),
        }),
      );
    }

    const _apiIdentifierEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelApiIdentifier",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_apiIdentifierEither.isLeft()) {
      return _apiIdentifierEither;
    }

    const apiIdentifier = _apiIdentifierEither.unsafeCoerce();
    const _contextWindowEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      number
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelContextWindow",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toNumber());
    if (_contextWindowEither.isLeft()) {
      return _contextWindowEither;
    }

    const contextWindow = _contextWindowEither.unsafeCoerce();
    const _familyEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      LanguageModelFamily
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelFamily",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        LanguageModelFamily.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_familyEither.isLeft()) {
      return _familyEither;
    }

    const family = _familyEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      apiIdentifier,
      contextWindow,
      family,
      identifier,
      label,
    });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof LanguageModelSpecification.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    LanguageModelSpecification
  > {
    return LanguageModelSpecification.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelSpecification(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
  );

  export function jsonSchema() {
    return zodToJsonSchema(languageModelSpecificationJsonZodSchema());
  }

  export function languageModelSpecificationJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/apiIdentifier`, type: "Control" },
        { scope: `${scopePrefix}/properties/contextWindow`, type: "Control" },
        LanguageModelFamily.languageModelFamilyJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/family`,
        }),
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
      ],
      label: "LanguageModelSpecification",
      type: "Group",
    };
  }

  export function languageModelSpecificationJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        apiIdentifier: zod.string(),
        contextWindow: zod.number(),
        family: LanguageModelFamily.languageModelFamilyJsonZodSchema(),
        "@id": zod.string().min(1),
        label: zod.string(),
        type: zod.literal("LanguageModelSpecification"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelSpecification.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelSpecification.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelSpecification.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelSpecification");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelSpecification");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}ApiIdentifier`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelApiIdentifier",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}ContextWindow`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelContextWindow",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Family`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelFamily",
        ),
        subject,
      },
      ...LanguageModelFamily.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Family`),
        variablePrefix: `${variablePrefix}Family`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelSpecification");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelSpecification");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}ApiIdentifier`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModelApiIdentifier",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}ContextWindow`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModelContextWindow",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Family`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModelFamily",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...LanguageModelFamily.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Family`),
        variablePrefix: `${variablePrefix}Family`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Label`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/2000/01/rdf-schema#label",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
/**
 * prompt
 */
export class Prompt extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  /**
   * messages
   */
  readonly messages: readonly PromptMessage[];
  override readonly type = "Prompt";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly messages: readonly PromptMessage[];
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.messages = parameters.messages;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Prompt): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, (left, right) => left.equals(right)))(
          this.messages,
          other.messages,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "messages",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.messages) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly messages: readonly ReturnType<PromptMessage["toJson"]>[];
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        messages: this.messages.map((_item) => _item.toJson()),
      } satisfies ReturnType<Prompt["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Prompt",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptMessages",
      ),
      this.messages.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#PromptMessageList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.messages.reduce((_hasher, _item) => {
                _item.hash(_hasher);
                return _hasher;
              }, sha256.create())}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Prompt {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      messages: readonly PromptMessage[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = promptJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const messages = _jsonObject["messages"].map((_item) =>
      PromptMessage.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ..._super0, identifier, messages });
  }

  export function fromJson(json: unknown): purify.Either<zod.ZodError, Prompt> {
    return Prompt.propertiesFromJson(json).map(
      (properties) => new Prompt(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      messages: readonly PromptMessage[];
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Prompt",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Prompt",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _messagesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly PromptMessage[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessages",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              PromptMessage.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_messagesEither.isLeft()) {
      return _messagesEither;
    }

    const messages = _messagesEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, messages });
  }

  export function fromRdf(
    parameters: Parameters<typeof Prompt.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Prompt> {
    return Prompt.propertiesFromRdf(parameters).map(
      (properties) => new Prompt(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Prompt",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptJsonZodSchema());
  }

  export function promptJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        PromptMessage.promptMessageJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/messages`,
        }),
      ],
      label: "prompt",
      type: "Group",
    };
  }

  export function promptJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        messages: PromptMessage.promptMessageJsonZodSchema().array(),
        type: zod.literal("Prompt"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Prompt.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Prompt.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Prompt.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("prompt");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "prompt");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Messages`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessages",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Messages`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Messages`}Item0`),
      },
      ...PromptMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Messages`}Item0`),
        variablePrefix: `${`${variablePrefix}Messages`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Messages`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Messages`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Messages`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Messages`}ItemN`),
      },
      ...PromptMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Messages`}ItemN`),
        variablePrefix: `${`${variablePrefix}Messages`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Messages`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}Messages`}RestNBasic`,
        ),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("prompt");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "prompt");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Prompt",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Messages`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#promptMessages",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Messages`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}Messages`}Item0`,
            ),
          },
        ],
      },
      ...PromptMessage.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Messages`}Item0`),
        variablePrefix: `${`${variablePrefix}Messages`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Messages`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}Messages`}Rest0`,
            ),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Messages`),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}Messages`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Messages`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Messages`}ItemN`,
                ),
              },
            ],
          },
          ...PromptMessage.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}Messages`}ItemN`,
            ),
            variablePrefix: `${`${variablePrefix}Messages`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Messages`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Messages`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export class LanguageModelSpecificationStub {
  readonly identifier: rdfjs.NamedNode;
  /**
   * has label
   */
  readonly label: purify.Maybe<string>;
  readonly type = "LanguageModelSpecificationStub";

  constructor(parameters: {
    readonly identifier: rdfjs.NamedNode | string;
    readonly label?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters.identifier === "object") {
      this.identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this.identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this.identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.label)) {
      this.label = parameters.label;
    } else if (typeof parameters.label === "string") {
      this.label = purify.Maybe.of(parameters.label);
    } else if (typeof parameters.label === "undefined") {
      this.label = purify.Maybe.empty();
    } else {
      this.label = parameters.label as never;
    }
  }

  equals(other: LanguageModelSpecificationStub): EqualsResult {
    return booleanEquals(this.identifier, other.identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        ((left, right) => maybeEquals(left, right, strictEquals))(
          this.label,
          other.label,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "label",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.label.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  toJson(): {
    readonly "@id": string;
    readonly label: string | undefined;
    readonly type: "LanguageModelSpecificationStub";
  } {
    return JSON.parse(
      JSON.stringify({
        "@id": this.identifier.value,
        label: this.label.map((_item) => _item).extract(),
        type: this.type,
      } satisfies ReturnType<LanguageModelSpecificationStub["toJson"]>),
    );
  }

  toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelSpecificationStub {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; label: purify.Maybe<string> }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = purify.Maybe.fromNullable(_jsonObject["label"]);
    return purify.Either.of({ identifier, label });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelSpecificationStub> {
    return LanguageModelSpecificationStub.propertiesFromJson(json).map(
      (properties) => new LanguageModelSpecificationStub(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; label: purify.Maybe<string> }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
          { unique: true },
        )
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    return purify.Either.of({ identifier, label });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof LanguageModelSpecificationStub.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    LanguageModelSpecificationStub
  > {
    return LanguageModelSpecificationStub.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelSpecificationStub(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LanguageModelSpecificationStub" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "LanguageModelSpecificationStub",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      label: zod.string().optional(),
      type: zod.literal("LanguageModelSpecificationStub"),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelSpecificationStub.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelSpecificationStub.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelSpecificationStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelSpecificationStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelSpecificationStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelSpecificationStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelSpecificationStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelSpecification",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Label`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2000/01/rdf-schema#label",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class LanguageModelInvocationOutput extends ProcessOutput {
  readonly completionMessage: CompletionMessage;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "LanguageModelInvocationOutput";

  constructor(
    parameters: {
      readonly completionMessage: CompletionMessage;
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessOutput>[0],
  ) {
    super(parameters);
    this.completionMessage = parameters.completionMessage;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: LanguageModelInvocationOutput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.completionMessage,
          other.completionMessage,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "completionMessage",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.completionMessage.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly completionMessage: ReturnType<CompletionMessage["toJson"]>;
  } & ReturnType<ProcessOutput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        completionMessage: this.completionMessage.toJson(),
      } satisfies ReturnType<LanguageModelInvocationOutput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationOutput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#completionMessage",
      ),
      this.completionMessage.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelInvocationOutput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      completionMessage: CompletionMessage;
      identifier: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof ProcessOutput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      languageModelInvocationOutputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessOutput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const completionMessage = CompletionMessage.fromJson(
      _jsonObject["completionMessage"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, completionMessage, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelInvocationOutput> {
    return LanguageModelInvocationOutput.propertiesFromJson(json).map(
      (properties) => new LanguageModelInvocationOutput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      completionMessage: CompletionMessage;
      identifier: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof ProcessOutput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessOutput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationOutput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationOutput",
          ),
        }),
      );
    }

    const _completionMessageEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CompletionMessage
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#completionMessage",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        CompletionMessage.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_completionMessageEither.isLeft()) {
      return _completionMessageEither;
    }

    const completionMessage = _completionMessageEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, completionMessage, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof LanguageModelInvocationOutput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    LanguageModelInvocationOutput
  > {
    return LanguageModelInvocationOutput.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelInvocationOutput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationOutput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(languageModelInvocationOutputJsonZodSchema());
  }

  export function languageModelInvocationOutputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessOutput.processOutputJsonUiSchema({ scopePrefix }),
        CompletionMessage.completionMessageJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/completionMessage`,
        }),
      ],
      label: "LanguageModelInvocationOutput",
      type: "Group",
    };
  }

  export function languageModelInvocationOutputJsonZodSchema() {
    return ProcessOutput.processOutputJsonZodSchema().merge(
      zod.object({
        completionMessage: CompletionMessage.completionMessageJsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("LanguageModelInvocationOutput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelInvocationOutput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelInvocationOutput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelInvocationOutput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelInvocationOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelInvocationOutput");
    return [
      ...ProcessOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#completionMessage",
        ),
        subject,
      },
      ...CompletionMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
        variablePrefix: `${variablePrefix}CompletionMessage`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelInvocationOutput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelInvocationOutput");
    return [
      ...ProcessOutput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationOutput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#completionMessage",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...CompletionMessage.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}CompletionMessage`),
        variablePrefix: `${variablePrefix}CompletionMessage`,
      }),
    ];
  }
}
export class LanguageModelInvocationInput extends ProcessInput {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly languageModel: LanguageModelSpecificationStub;
  readonly prompt: Prompt;
  override readonly type = "LanguageModelInvocationInput";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly languageModel: LanguageModelSpecificationStub;
      readonly prompt: Prompt;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.languageModel = parameters.languageModel;
    this.prompt = parameters.prompt;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: LanguageModelInvocationInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.languageModel,
          other.languageModel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "languageModel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.prompt,
          other.prompt,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "prompt",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.languageModel.hash(_hasher);
    this.prompt.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly languageModel: ReturnType<
      LanguageModelSpecificationStub["toJson"]
    >;
    readonly prompt: ReturnType<Prompt["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        languageModel: this.languageModel.toJson(),
        prompt: this.prompt.toJson(),
      } satisfies ReturnType<LanguageModelInvocationInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModel",
      ),
      this.languageModel.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#prompt",
      ),
      this.prompt.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelInvocationInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      languageModel: LanguageModelSpecificationStub;
      prompt: Prompt;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      languageModelInvocationInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const languageModel = LanguageModelSpecificationStub.fromJson(
      _jsonObject["languageModel"],
    ).unsafeCoerce();
    const prompt = Prompt.fromJson(_jsonObject["prompt"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, languageModel, prompt });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelInvocationInput> {
    return LanguageModelInvocationInput.propertiesFromJson(json).map(
      (properties) => new LanguageModelInvocationInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      languageModel: LanguageModelSpecificationStub;
      prompt: Prompt;
    } & UnwrapR<ReturnType<typeof ProcessInput.propertiesFromRdf>>
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationInput",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _languageModelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      LanguageModelSpecificationStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        LanguageModelSpecificationStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_languageModelEither.isLeft()) {
      return _languageModelEither;
    }

    const languageModel = _languageModelEither.unsafeCoerce();
    const _promptEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Prompt
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#prompt",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Prompt.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_promptEither.isLeft()) {
      return _promptEither;
    }

    const prompt = _promptEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, languageModel, prompt });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof LanguageModelInvocationInput.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    LanguageModelInvocationInput
  > {
    return LanguageModelInvocationInput.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelInvocationInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(languageModelInvocationInputJsonZodSchema());
  }

  export function languageModelInvocationInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        LanguageModelSpecificationStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/languageModel`,
        }),
        Prompt.promptJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/prompt`,
        }),
      ],
      label: "LanguageModelInvocationInput",
      type: "Group",
    };
  }

  export function languageModelInvocationInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        languageModel: LanguageModelSpecificationStub.jsonZodSchema(),
        prompt: Prompt.promptJsonZodSchema(),
        type: zod.literal("LanguageModelInvocationInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelInvocationInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelInvocationInput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelInvocationInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelInvocationInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelInvocationInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModel",
        ),
        subject,
      },
      ...LanguageModelSpecificationStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Prompt`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#prompt",
        ),
        subject,
      },
      ...Prompt.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Prompt`),
        variablePrefix: `${variablePrefix}Prompt`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("languageModelInvocationInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelInvocationInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocationInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LanguageModel`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModel",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...LanguageModelSpecificationStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}LanguageModel`),
        variablePrefix: `${variablePrefix}LanguageModel`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Prompt`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#prompt",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Prompt.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Prompt`),
        variablePrefix: `${variablePrefix}Prompt`,
      }),
    ];
  }
}
export class LanguageModelInvocation extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: LanguageModelInvocationInput;
  readonly output: Exception | LanguageModelInvocationOutput;
  override readonly type = "LanguageModelInvocation";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: LanguageModelInvocationInput;
      readonly output: Exception | LanguageModelInvocationOutput;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
    this.output = parameters.output;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: LanguageModelInvocation): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((
          left: Exception | LanguageModelInvocationOutput,
          right: Exception | LanguageModelInvocationOutput,
        ) => {
          if (left.type === "Exception" && right.type === "Exception") {
            return ((left, right) => left.equals(right))(left, right);
          }
          if (
            left.type === "LanguageModelInvocationOutput" &&
            right.type === "LanguageModelInvocationOutput"
          ) {
            return ((left, right) => left.equals(right))(left, right);
          }

          return purify.Left({
            left,
            right,
            propertyName: "type",
            propertyValuesUnequal: {
              left: typeof left,
              right: typeof right,
              type: "BooleanEquals" as const,
            },
            type: "Property" as const,
          });
        })(this.output, other.output).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "output",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    switch (this.output.type) {
      case "Exception": {
        this.output.hash(_hasher);
        break;
      }
      case "LanguageModelInvocationOutput": {
        this.output.hash(_hasher);
        break;
      }
    }

    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<LanguageModelInvocationInput["toJson"]>;
    readonly output:
      | ReturnType<Exception["toJson"]>
      | ReturnType<LanguageModelInvocationOutput["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
        output:
          this.output.type === "LanguageModelInvocationOutput"
            ? this.output.toJson()
            : this.output.toJson(),
      } satisfies ReturnType<LanguageModelInvocation["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocation",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processOutput",
      ),
      this.output.type === "LanguageModelInvocationOutput"
        ? this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.output.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelInvocation {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      input: LanguageModelInvocationInput;
      output: Exception | LanguageModelInvocationOutput;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      languageModelInvocationJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = LanguageModelInvocationInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    const output =
      _jsonObject["output"].type === "LanguageModelInvocationOutput"
        ? LanguageModelInvocationOutput.fromJson(
            _jsonObject["output"],
          ).unsafeCoerce()
        : Exception.fromJson(_jsonObject["output"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input, output });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelInvocation> {
    return LanguageModelInvocation.propertiesFromJson(json).map(
      (properties) => new LanguageModelInvocation(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      input: LanguageModelInvocationInput;
      output: Exception | LanguageModelInvocationOutput;
    } & UnwrapR<ReturnType<typeof Process.propertiesFromRdf>>
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocation",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocation",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      LanguageModelInvocationInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        LanguageModelInvocationInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    const _outputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Exception | LanguageModelInvocationOutput
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#processOutput",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          Exception.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Exception | LanguageModelInvocationOutput
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processOutput",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            LanguageModelInvocationOutput.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Exception | LanguageModelInvocationOutput
        >,
    );
    if (_outputEither.isLeft()) {
      return _outputEither;
    }

    const output = _outputEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input, output });
  }

  export function fromRdf(
    parameters: Parameters<typeof LanguageModelInvocation.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, LanguageModelInvocation> {
    return LanguageModelInvocation.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelInvocation(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocation",
  );

  export function jsonSchema() {
    return zodToJsonSchema(languageModelInvocationJsonZodSchema());
  }

  export function languageModelInvocationJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        LanguageModelInvocationInput.languageModelInvocationInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
        { scope: `${scopePrefix}/properties/output`, type: "Control" },
      ],
      label: "LanguageModelInvocation",
      type: "Group",
    };
  }

  export function languageModelInvocationJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input:
          LanguageModelInvocationInput.languageModelInvocationInputJsonZodSchema(),
        output: zod.discriminatedUnion("type", [
          Exception.exceptionJsonZodSchema(),
          LanguageModelInvocationOutput.languageModelInvocationOutputJsonZodSchema(),
        ]),
        type: zod.literal("LanguageModelInvocation"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelInvocation.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelInvocation.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelInvocation.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageModelInvocation");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelInvocation");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...LanguageModelInvocationInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...Exception.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Output`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processOutput",
        ),
        subject,
      },
      ...LanguageModelInvocationOutput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Output`),
        variablePrefix: `${variablePrefix}Output`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageModelInvocation");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelInvocation");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelInvocation",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...LanguageModelInvocationInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...Exception.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(`${variablePrefix}Output`),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#processOutput",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...LanguageModelInvocationOutput.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(`${variablePrefix}Output`),
                variablePrefix: `${variablePrefix}Output`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }
}
export class LanguageModelFamily extends InformationContentEntity {
  readonly creator: LanguageModelCreator;
  private _identifier: rdfjs.NamedNode | undefined;
  /**
   * has label
   */
  readonly label: string;
  override readonly type = "LanguageModelFamily";

  constructor(
    parameters: {
      readonly creator: LanguageModelCreator;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly label: string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    this.creator = parameters.creator;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.label = parameters.label;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: LanguageModelFamily): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.creator,
          other.creator,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "creator",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.label, other.label).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "label",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.creator.hash(_hasher);
    _hasher.update(this.label);
    return _hasher;
  }

  override toJson(): {
    readonly creator: ReturnType<LanguageModelCreator["toJson"]>;
    readonly label: string;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        creator: this.creator.toJson(),
        label: this.label,
      } satisfies ReturnType<LanguageModelFamily["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelFamily",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#languageModelCreator",
      ),
      this.creator.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelFamily {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      creator: LanguageModelCreator;
      identifier: rdfjs.NamedNode;
      label: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      languageModelFamilyJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const creator = LanguageModelCreator.fromJson(
      _jsonObject["creator"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = _jsonObject["label"];
    return purify.Either.of({ ..._super0, creator, identifier, label });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelFamily> {
    return LanguageModelFamily.propertiesFromJson(json).map(
      (properties) => new LanguageModelFamily(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      creator: LanguageModelCreator;
      identifier: rdfjs.NamedNode;
      label: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelFamily",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelFamily",
          ),
        }),
      );
    }

    const _creatorEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      LanguageModelCreator
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelCreator",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        LanguageModelCreator.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_creatorEither.isLeft()) {
      return _creatorEither;
    }

    const creator = _creatorEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, creator, identifier, label });
  }

  export function fromRdf(
    parameters: Parameters<typeof LanguageModelFamily.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, LanguageModelFamily> {
    return LanguageModelFamily.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelFamily(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelFamily",
  );

  export function jsonSchema() {
    return zodToJsonSchema(languageModelFamilyJsonZodSchema());
  }

  export function languageModelFamilyJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        LanguageModelCreator.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/creator`,
        }),
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
      ],
      label: "LanguageModelFamily",
      type: "Group",
    };
  }

  export function languageModelFamilyJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        creator: LanguageModelCreator.jsonZodSchema(),
        "@id": zod.string().min(1),
        label: zod.string(),
        type: zod.literal("LanguageModelFamily"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelFamily.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelFamily.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelFamily.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageModelFamily");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "languageModelFamily");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Creator`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#languageModelCreator",
        ),
        subject,
      },
      ...LanguageModelCreator.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Creator`),
        variablePrefix: `${variablePrefix}Creator`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageModelFamily");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "languageModelFamily");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelFamily",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Creator`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#languageModelCreator",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...LanguageModelCreator.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Creator`),
        variablePrefix: `${variablePrefix}Creator`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Label`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/2000/01/rdf-schema#label",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class LanguageModelCreator {
  readonly identifier: rdfjs.NamedNode<"http://openai.com/">;
  /**
   * has label
   */
  readonly label: string;
  readonly type = "LanguageModelCreator";

  constructor(parameters: {
    readonly identifier:
      | "http://openai.com/"
      | rdfjs.NamedNode<"http://openai.com/">;
    readonly label: string;
  }) {
    if (typeof parameters.identifier === "object") {
      this.identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this.identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this.identifier = parameters.identifier as never;
    }

    this.label = parameters.label;
  }

  equals(other: LanguageModelCreator): EqualsResult {
    return booleanEquals(this.identifier, other.identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        strictEquals(this.label, other.label).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "label",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.label);
    return _hasher;
  }

  toJson(): {
    readonly "@id": string;
    readonly label: string;
    readonly type: "LanguageModelCreator";
  } {
    return JSON.parse(
      JSON.stringify({
        "@id": this.identifier.value,
        label: this.label,
        type: this.type,
      } satisfies ReturnType<LanguageModelCreator["toJson"]>),
    );
  }

  toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelCreator",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace LanguageModelCreator {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode<"http://openai.com/">; label: string }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = _jsonObject["label"];
    return purify.Either.of({ identifier, label });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, LanguageModelCreator> {
    return LanguageModelCreator.propertiesFromJson(json).map(
      (properties) => new LanguageModelCreator(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode<"http://openai.com/">; label: string }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#LanguageModelCreator",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#LanguageModelCreator",
          ),
        }),
      );
    }

    let identifier: rdfjs.NamedNode<"http://openai.com/">;
    switch (_resource.identifier.value) {
      case "http://openai.com/":
        identifier = dataFactory.namedNode("http://openai.com/");
        break;
      default:
        return purify.Left(
          new rdfjsResource.Resource.MistypedValueError({
            actualValue: _resource.identifier,
            expectedValueType: 'rdfjs.NamedNode<"http://openai.com/">',
            focusResource: _resource,
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
            ),
          }),
        );
    }

    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    return purify.Either.of({ identifier, label });
  }

  export function fromRdf(
    parameters: Parameters<typeof LanguageModelCreator.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, LanguageModelCreator> {
    return LanguageModelCreator.propertiesFromRdf(parameters).map(
      (properties) => new LanguageModelCreator(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#LanguageModelCreator",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "LanguageModelCreator" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "LanguageModelCreator",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      "@id": zod.enum(["http://openai.com/"]),
      label: zod.string(),
      type: zod.literal("LanguageModelCreator"),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        LanguageModelCreator.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        LanguageModelCreator.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      LanguageModelCreator.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageModelCreator");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelCreator");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("languageModelCreator");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "languageModelCreator");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#LanguageModelCreator",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Label`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/2000/01/rdf-schema#label",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
/**
 * message template
 */
export class PromptMessageTemplate extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly inputValues: readonly PromptInputValue[];
  /**
   * has literal form
   */
  readonly literalForm: string;
  /**
   * has role
   */
  readonly role: rdfjs.NamedNode<
    | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
    | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
    | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
  >;
  override readonly type = "PromptMessageTemplate";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly inputValues?: readonly PromptInputValue[];
      readonly literalForm: string;
      readonly role?:
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
        | rdfjs.NamedNode<
            | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
            | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
            | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
          >;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (typeof parameters.inputValues === "undefined") {
      this.inputValues = [];
    } else if (Array.isArray(parameters.inputValues)) {
      this.inputValues = parameters.inputValues;
    } else {
      this.inputValues = parameters.inputValues as never;
    }

    this.literalForm = parameters.literalForm;
    if (typeof parameters.role === "undefined") {
      this.role = dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
      );
    } else if (typeof parameters.role === "object") {
      this.role = parameters.role;
    } else if (typeof parameters.role === "string") {
      this.role = dataFactory.namedNode(parameters.role);
    } else {
      this.role = parameters.role as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptMessageTemplate): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => arrayEquals(left, right, PromptInputValue.equals))(
          this.inputValues,
          other.inputValues,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inputValues",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.literalForm, other.literalForm).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "literalForm",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        booleanEquals(this.role, other.role).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "role",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _item0 of this.inputValues) {
      _item0.hash(_hasher);
    }

    _hasher.update(this.literalForm);
    _hasher.update(this.role.termType);
    _hasher.update(this.role.value);
    return _hasher;
  }

  override toJson(): {
    readonly inputValues: readonly (
      | ReturnType<PromptLiteralInputValue["toJson"]>
      | ReturnType<PromptSparqlSelectInputValue["toJson"]>
    )[];
    readonly literalForm: string;
    readonly role: {
      readonly "@id":
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System";
    };
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        inputValues: this.inputValues.map((_item) => _item.toJson()),
        literalForm: this.literalForm,
        role: { "@id": this.role.value },
      } satisfies ReturnType<PromptMessageTemplate["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptMessageTemplate",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
      ),
      this.inputValues.map((_item) =>
        _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#literalForm",
      ),
      this.literalForm,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
      ),
      !this.role.equals(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
        ),
      )
        ? this.role
        : undefined,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptMessageTemplate {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      inputValues: readonly PromptInputValue[];
      literalForm: string;
      role: rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
      >;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      promptMessageTemplateJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const inputValues = _jsonObject["inputValues"].map((_item) =>
      PromptInputValue.fromJson(_item).unsafeCoerce(),
    );
    const literalForm = _jsonObject["literalForm"];
    const role = dataFactory.namedNode(_jsonObject["role"]["@id"]);
    return purify.Either.of({
      ..._super0,
      identifier,
      inputValues,
      literalForm,
      role,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptMessageTemplate> {
    return PromptMessageTemplate.propertiesFromJson(json).map(
      (properties) => new PromptMessageTemplate(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      inputValues: readonly PromptInputValue[];
      literalForm: string;
      role: rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
      >;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptMessageTemplate",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptMessageTemplate",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputValuesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly PromptInputValue[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
          ),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              PromptInputValue.fromRdf({ ..._context, resource: _resource }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_inputValuesEither.isLeft()) {
      return _inputValuesEither;
    }

    const inputValues = _inputValuesEither.unsafeCoerce();
    const _literalFormEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_literalFormEither.isLeft()) {
      return _literalFormEither;
    }

    const literalForm = _literalFormEither.unsafeCoerce();
    const _roleEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
      >
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
            ),
            object: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
            ),
          }),
        ),
      )
      .chain((_value) =>
        _value.toIri().chain((iri) => {
          switch (iri.value) {
            case "http://purl.archive.org/purl/knextract/cbox#_Role_AI":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_AI">,
              );
            case "http://purl.archive.org/purl/knextract/cbox#_Role_Human":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_Human">,
              );
            case "http://purl.archive.org/purl/knextract/cbox#_Role_System":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_System">,
              );
            default:
              return purify.Left(
                new rdfjsResource.Resource.MistypedValueError({
                  actualValue: iri,
                  expectedValueType:
                    'rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_AI" | "http://purl.archive.org/purl/knextract/cbox#_Role_Human" | "http://purl.archive.org/purl/knextract/cbox#_Role_System">',
                  focusResource: _resource,
                  predicate: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
                  ),
                }),
              );
          }
        }),
      );
    if (_roleEither.isLeft()) {
      return _roleEither;
    }

    const role = _roleEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      identifier,
      inputValues,
      literalForm,
      role,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof PromptMessageTemplate.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PromptMessageTemplate> {
    return PromptMessageTemplate.propertiesFromRdf(parameters).map(
      (properties) => new PromptMessageTemplate(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptMessageTemplate",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptMessageTemplateJsonZodSchema());
  }

  export function promptMessageTemplateJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/inputValues`, type: "Control" },
        {
          label: "has literal form",
          scope: `${scopePrefix}/properties/literalForm`,
          type: "Control",
        },
        {
          label: "has role",
          scope: `${scopePrefix}/properties/role`,
          type: "Control",
        },
      ],
      label: "message template",
      type: "Group",
    };
  }

  export function promptMessageTemplateJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        inputValues: PromptInputValue.jsonZodSchema().array(),
        literalForm: zod.string(),
        role: zod.object({
          "@id": zod.enum([
            "http://purl.archive.org/purl/knextract/cbox#_Role_AI",
            "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
            "http://purl.archive.org/purl/knextract/cbox#_Role_System",
          ]),
        }),
        type: zod.literal("PromptMessageTemplate"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptMessageTemplate.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptMessageTemplate.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptMessageTemplate.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptMessageTemplate");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptMessageTemplate");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}InputValues`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
        ),
        subject,
      },
      ...PromptInputValue.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}InputValues`),
        variablePrefix: `${variablePrefix}InputValues`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Role`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptMessageTemplate");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "promptMessageTemplate");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptMessageTemplate",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}InputValues`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#promptInputValue",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...PromptInputValue.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}InputValues`),
            variablePrefix: `${variablePrefix}InputValues`,
          }),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#literalForm",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Role`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class Instruction extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly promptMessage: PromptMessage | PromptMessageTemplate;
  override readonly type = "Instruction";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly promptMessage: PromptMessage | PromptMessageTemplate;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.promptMessage = parameters.promptMessage;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Instruction): EqualsResult {
    return super.equals(other).chain(() =>
      ((
        left: PromptMessage | PromptMessageTemplate,
        right: PromptMessage | PromptMessageTemplate,
      ) => {
        if (left.type === "PromptMessage" && right.type === "PromptMessage") {
          return ((left, right) => left.equals(right))(left, right);
        }
        if (
          left.type === "PromptMessageTemplate" &&
          right.type === "PromptMessageTemplate"
        ) {
          return ((left, right) => left.equals(right))(left, right);
        }

        return purify.Left({
          left,
          right,
          propertyName: "type",
          propertyValuesUnequal: {
            left: typeof left,
            right: typeof right,
            type: "BooleanEquals" as const,
          },
          type: "Property" as const,
        });
      })(this.promptMessage, other.promptMessage).mapLeft(
        (propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "promptMessage",
          propertyValuesUnequal,
          type: "Property" as const,
        }),
      ),
    );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    switch (this.promptMessage.type) {
      case "PromptMessage": {
        this.promptMessage.hash(_hasher);
        break;
      }
      case "PromptMessageTemplate": {
        this.promptMessage.hash(_hasher);
        break;
      }
    }

    return _hasher;
  }

  override toJson(): {
    readonly promptMessage:
      | ReturnType<PromptMessage["toJson"]>
      | ReturnType<PromptMessageTemplate["toJson"]>;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        promptMessage:
          this.promptMessage.type === "PromptMessageTemplate"
            ? this.promptMessage.toJson()
            : this.promptMessage.toJson(),
      } satisfies ReturnType<Instruction["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Instruction",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
      ),
      this.promptMessage.type === "PromptMessageTemplate"
        ? this.promptMessage.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          })
        : this.promptMessage.toRdf({
            mutateGraph: mutateGraph,
            resourceSet: resourceSet,
          }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Instruction {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      promptMessage: PromptMessage | PromptMessageTemplate;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = instructionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const promptMessage =
      _jsonObject["promptMessage"].type === "PromptMessageTemplate"
        ? PromptMessageTemplate.fromJson(
            _jsonObject["promptMessage"],
          ).unsafeCoerce()
        : PromptMessage.fromJson(_jsonObject["promptMessage"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, promptMessage });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Instruction> {
    return Instruction.propertiesFromJson(json).map(
      (properties) => new Instruction(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      promptMessage: PromptMessage | PromptMessageTemplate;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Instruction",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Instruction",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _promptMessageEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      PromptMessage | PromptMessageTemplate
    > = (
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          PromptMessage.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        ) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PromptMessage | PromptMessageTemplate
      >
    ).altLazy(
      () =>
        _resource
          .values(
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
            ),
            { unique: true },
          )
          .head()
          .chain((value) => value.toNamedResource())
          .chain((_resource) =>
            PromptMessageTemplate.fromRdf({
              ..._context,
              ignoreRdfType: true,
              languageIn: _languageIn,
              resource: _resource,
            }),
          ) as purify.Either<
          rdfjsResource.Resource.ValueError,
          PromptMessage | PromptMessageTemplate
        >,
    );
    if (_promptMessageEither.isLeft()) {
      return _promptMessageEither;
    }

    const promptMessage = _promptMessageEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, promptMessage });
  }

  export function fromRdf(
    parameters: Parameters<typeof Instruction.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Instruction> {
    return Instruction.propertiesFromRdf(parameters).map(
      (properties) => new Instruction(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Instruction",
  );

  export function jsonSchema() {
    return zodToJsonSchema(instructionJsonZodSchema());
  }

  export function instructionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/promptMessage`, type: "Control" },
      ],
      label: "Instruction",
      type: "Group",
    };
  }

  export function instructionJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        promptMessage: zod.discriminatedUnion("type", [
          PromptMessage.promptMessageJsonZodSchema(),
          PromptMessageTemplate.promptMessageTemplateJsonZodSchema(),
        ]),
        type: zod.literal("Instruction"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Instruction.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Instruction.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Instruction.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("instruction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "instruction");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}PromptMessage`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
        ),
        subject,
      },
      ...PromptMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PromptMessage`),
        variablePrefix: `${variablePrefix}PromptMessage`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}PromptMessage`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
        ),
        subject,
      },
      ...PromptMessageTemplate.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PromptMessage`),
        variablePrefix: `${variablePrefix}PromptMessage`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("instruction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "instruction");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Instruction",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(
                      `${variablePrefix}PromptMessage`,
                    ),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...PromptMessage.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(
                  `${variablePrefix}PromptMessage`,
                ),
                variablePrefix: `${variablePrefix}PromptMessage`,
              }),
            ],
            type: "group",
          },
          {
            patterns: [
              {
                triples: [
                  {
                    object: dataFactory.variable!(
                      `${variablePrefix}PromptMessage`,
                    ),
                    predicate: dataFactory.namedNode(
                      "http://purl.archive.org/purl/knextract/ontology#instructionPromptMessage",
                    ),
                    subject,
                  },
                ],
                type: "bgp",
              },
              ...PromptMessageTemplate.sparqlWherePatterns({
                ignoreRdfType: true,
                subject: dataFactory.variable!(
                  `${variablePrefix}PromptMessage`,
                ),
                variablePrefix: `${variablePrefix}PromptMessage`,
              }),
            ],
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }
}
export class Exception extends InformationContentEntity {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly message: string;
  override readonly type = "Exception";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly message: string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.message = parameters.message;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Exception): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.message, other.message).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "message",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.message);
    return _hasher;
  }

  override toJson(): { readonly message: string } & ReturnType<
    InformationContentEntity["toJson"]
  > {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        message: this.message,
      } satisfies ReturnType<Exception["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Exception",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#exceptionMessage",
      ),
      this.message,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Exception {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; message: string } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = exceptionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const message = _jsonObject["message"];
    return purify.Either.of({ ..._super0, identifier, message });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Exception> {
    return Exception.propertiesFromJson(json).map(
      (properties) => new Exception(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; message: string } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromRdf>
    >
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Exception",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Exception",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _messageEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#exceptionMessage",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_messageEither.isLeft()) {
      return _messageEither;
    }

    const message = _messageEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, message });
  }

  export function fromRdf(
    parameters: Parameters<typeof Exception.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Exception> {
    return Exception.propertiesFromRdf(parameters).map(
      (properties) => new Exception(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Exception",
  );

  export function jsonSchema() {
    return zodToJsonSchema(exceptionJsonZodSchema());
  }

  export function exceptionJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/message`, type: "Control" },
      ],
      label: "Exception",
      type: "Group",
    };
  }

  export function exceptionJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        message: zod.string(),
        type: zod.literal("Exception"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Exception.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Exception.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Exception.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("exception");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "exception");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Message`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#exceptionMessage",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("exception");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "exception");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Exception",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Message`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#exceptionMessage",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class DocumentStub {
  /**
   * deleted
   */
  readonly deleted: boolean;
  readonly identifier: rdfjs.NamedNode;
  readonly title: purify.Maybe<DocumentTitle>;
  readonly type = "DocumentStub";

  constructor(parameters: {
    readonly deleted?: boolean;
    readonly identifier: rdfjs.NamedNode | string;
    readonly title?: DocumentTitle | purify.Maybe<DocumentTitle>;
  }) {
    if (typeof parameters.deleted === "boolean") {
      this.deleted = parameters.deleted;
    } else if (typeof parameters.deleted === "undefined") {
      this.deleted = false;
    } else {
      this.deleted = parameters.deleted as never;
    }

    if (typeof parameters.identifier === "object") {
      this.identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this.identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this.identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.title)) {
      this.title = parameters.title;
    } else if (
      typeof parameters.title === "object" &&
      parameters.title instanceof DocumentTitle
    ) {
      this.title = purify.Maybe.of(parameters.title);
    } else if (typeof parameters.title === "undefined") {
      this.title = purify.Maybe.empty();
    } else {
      this.title = parameters.title as never;
    }
  }

  equals(other: DocumentStub): EqualsResult {
    return strictEquals(this.deleted, other.deleted)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "deleted",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        booleanEquals(this.identifier, other.identifier).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "identifier",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.title,
          other.title,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "title",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.deleted.toString());
    this.title.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    return _hasher;
  }

  toJson(): {
    readonly deleted: boolean;
    readonly "@id": string;
    readonly title: ReturnType<DocumentTitle["toJson"]> | undefined;
    readonly type: "DocumentStub";
  } {
    return JSON.parse(
      JSON.stringify({
        deleted: this.deleted,
        "@id": this.identifier.value,
        title: this.title.map((_item) => _item.toJson()).extract(),
        type: this.type,
      } satisfies ReturnType<DocumentStub["toJson"]>),
    );
  }

  toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Document",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#deleted",
      ),
      this.deleted ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#title",
      ),
      this.title.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace DocumentStub {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      title: purify.Maybe<DocumentTitle>;
    }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const deleted = _jsonObject["deleted"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const title = purify.Maybe.fromNullable(_jsonObject["title"]).map((_item) =>
      DocumentTitle.fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ deleted, identifier, title });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DocumentStub> {
    return DocumentStub.propertiesFromJson(json).map(
      (properties) => new DocumentStub(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      title: purify.Maybe<DocumentTitle>;
    }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Document",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Document",
          ),
        }),
      );
    }

    const _deletedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#deleted",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_deletedEither.isLeft()) {
      return _deletedEither;
    }

    const deleted = _deletedEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _titleEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<DocumentTitle>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#title",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          DocumentTitle.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_titleEither.isLeft()) {
      return _titleEither;
    }

    const title = _titleEither.unsafeCoerce();
    return purify.Either.of({ deleted, identifier, title });
  }

  export function fromRdf(
    parameters: Parameters<typeof DocumentStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, DocumentStub> {
    return DocumentStub.propertiesFromRdf(parameters).map(
      (properties) => new DocumentStub(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Document",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "deleted",
          scope: `${scopePrefix}/properties/deleted`,
          type: "Control",
        },
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        DocumentTitle.documentTitleJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/title`,
        }),
        {
          rule: {
            condition: {
              schema: { const: "DocumentStub" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "DocumentStub",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      deleted: zod.boolean(),
      "@id": zod.string().min(1),
      title: DocumentTitle.documentTitleJsonZodSchema().optional(),
      type: zod.literal("DocumentStub"),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DocumentStub.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DocumentStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DocumentStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "documentStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Deleted`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Title`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#title",
        ),
        subject,
      },
      ...DocumentTitle.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Title`),
        variablePrefix: `${variablePrefix}Title`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "documentStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Document",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Deleted`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#deleted",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Title`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#title",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...DocumentTitle.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Title`),
            variablePrefix: `${variablePrefix}Title`,
          }),
        ],
        type: "optional",
      },
    ];
  }
}
export class DocumentDeletionInput extends ProcessInput {
  readonly document: DocumentStub;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "DocumentDeletionInput";

  constructor(
    parameters: {
      readonly document: DocumentStub;
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.document = parameters.document;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: DocumentDeletionInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.document,
          other.document,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "document",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.document.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly document: ReturnType<DocumentStub["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        document: this.document.toJson(),
      } satisfies ReturnType<DocumentDeletionInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DocumentDeletionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#document",
      ),
      this.document.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace DocumentDeletionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { document: DocumentStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessInput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      documentDeletionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const document = DocumentStub.fromJson(
      _jsonObject["document"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, document, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DocumentDeletionInput> {
    return DocumentDeletionInput.propertiesFromJson(json).map(
      (properties) => new DocumentDeletionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { document: DocumentStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessInput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DocumentDeletionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#DocumentDeletionInput",
          ),
        }),
      );
    }

    const _documentEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_documentEither.isLeft()) {
      return _documentEither;
    }

    const document = _documentEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, document, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof DocumentDeletionInput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, DocumentDeletionInput> {
    return DocumentDeletionInput.propertiesFromRdf(parameters).map(
      (properties) => new DocumentDeletionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#DocumentDeletionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(documentDeletionInputJsonZodSchema());
  }

  export function documentDeletionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        DocumentStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/document`,
        }),
      ],
      label: "DocumentDeletionInput",
      type: "Group",
    };
  }

  export function documentDeletionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        document: DocumentStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("DocumentDeletionInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DocumentDeletionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DocumentDeletionInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DocumentDeletionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentDeletionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "documentDeletionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Document`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#document",
        ),
        subject,
      },
      ...DocumentStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentDeletionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "documentDeletionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#DocumentDeletionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Document`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#document",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Document`),
        variablePrefix: `${variablePrefix}Document`,
      }),
    ];
  }
}
export class DocumentDeletion extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: DocumentDeletionInput;
  override readonly type = "DocumentDeletion";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: DocumentDeletionInput;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: DocumentDeletion): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<DocumentDeletionInput["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
      } satisfies ReturnType<DocumentDeletion["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DocumentDeletion",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace DocumentDeletion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; input: DocumentDeletionInput } & UnwrapR<
      ReturnType<typeof Process.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      documentDeletionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = DocumentDeletionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DocumentDeletion> {
    return DocumentDeletion.propertiesFromJson(json).map(
      (properties) => new DocumentDeletion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; input: DocumentDeletionInput } & UnwrapR<
      ReturnType<typeof Process.propertiesFromRdf>
    >
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DocumentDeletion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#DocumentDeletion",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      DocumentDeletionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        DocumentDeletionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input });
  }

  export function fromRdf(
    parameters: Parameters<typeof DocumentDeletion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, DocumentDeletion> {
    return DocumentDeletion.propertiesFromRdf(parameters).map(
      (properties) => new DocumentDeletion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#DocumentDeletion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(documentDeletionJsonZodSchema());
  }

  export function documentDeletionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        DocumentDeletionInput.documentDeletionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
      ],
      label: "DocumentDeletion",
      type: "Group",
    };
  }

  export function documentDeletionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input: DocumentDeletionInput.documentDeletionInputJsonZodSchema(),
        type: zod.literal("DocumentDeletion"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DocumentDeletion.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DocumentDeletion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DocumentDeletion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentDeletion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "documentDeletion");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...DocumentDeletionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentDeletion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "documentDeletion");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#DocumentDeletion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...DocumentDeletionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
    ];
  }
}
export class TextualEntity extends InformationContentEntity {
  /**
   * has encoding type
   */
  readonly encodingType: rdfjs.NamedNode<
    | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
    | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
  >;
  protected _identifier: rdfjs.NamedNode | undefined;
  /**
   * has literal form
   */
  readonly literalForm: string;
  override readonly type: "DocumentTitle" | "TextualEntity" = "TextualEntity";

  constructor(
    parameters: {
      readonly encodingType:
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
        | rdfjs.NamedNode<
            | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
            | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
          >;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly literalForm: string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.encodingType === "object") {
      this.encodingType = parameters.encodingType;
    } else if (typeof parameters.encodingType === "string") {
      this.encodingType = dataFactory.namedNode(parameters.encodingType);
    } else {
      this.encodingType = parameters.encodingType as never;
    }

    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.literalForm = parameters.literalForm;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: TextualEntity): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        booleanEquals(this.encodingType, other.encodingType).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "encodingType",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.literalForm, other.literalForm).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "literalForm",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.encodingType.termType);
    _hasher.update(this.encodingType.value);
    _hasher.update(this.literalForm);
    return _hasher;
  }

  override toJson(): {
    readonly encodingType: {
      readonly "@id":
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain";
    };
    readonly literalForm: string;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        encodingType: { "@id": this.encodingType.value },
        literalForm: this.literalForm,
      } satisfies ReturnType<TextualEntity["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#TextualEntity",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#encodingType",
      ),
      this.encodingType,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#literalForm",
      ),
      this.literalForm,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace TextualEntity {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      encodingType: rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
      >;
      identifier: rdfjs.NamedNode;
      literalForm: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = textualEntityJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const encodingType = dataFactory.namedNode(
      _jsonObject["encodingType"]["@id"],
    );
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const literalForm = _jsonObject["literalForm"];
    return purify.Either.of({
      ..._super0,
      encodingType,
      identifier,
      literalForm,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TextualEntity> {
    return TextualEntity.propertiesFromJson(json).map(
      (properties) => new TextualEntity(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      encodingType: rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
      >;
      identifier: rdfjs.NamedNode;
      literalForm: string;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#TextualEntity",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#TextualEntity",
          ),
        }),
      );
    }

    const _encodingTypeEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
        | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
      >
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#encodingType",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) =>
        _value.toIri().chain((iri) => {
          switch (iri.value) {
            case "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
                  | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml">,
              );
            case "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml"
                  | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain">,
              );
            default:
              return purify.Left(
                new rdfjsResource.Resource.MistypedValueError({
                  actualValue: iri,
                  expectedValueType:
                    'rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml" | "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain">',
                  focusResource: _resource,
                  predicate: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#encodingType",
                  ),
                }),
              );
          }
        }),
      );
    if (_encodingTypeEither.isLeft()) {
      return _encodingTypeEither;
    }

    const encodingType = _encodingTypeEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _literalFormEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_literalFormEither.isLeft()) {
      return _literalFormEither;
    }

    const literalForm = _literalFormEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      encodingType,
      identifier,
      literalForm,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof TextualEntity.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, TextualEntity> {
    return TextualEntity.propertiesFromRdf(parameters).map(
      (properties) => new TextualEntity(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#TextualEntity",
  );

  export function jsonSchema() {
    return zodToJsonSchema(textualEntityJsonZodSchema());
  }

  export function textualEntityJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        {
          label: "has encoding type",
          scope: `${scopePrefix}/properties/encodingType`,
          type: "Control",
        },
        {
          label: "has literal form",
          scope: `${scopePrefix}/properties/literalForm`,
          type: "Control",
        },
      ],
      label: "TextualEntity",
      type: "Group",
    };
  }

  export function textualEntityJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        encodingType: zod.object({
          "@id": zod.enum([
            "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextHtml",
            "http://purl.archive.org/purl/knextract/cbox#_EncodingType_TextPlain",
          ]),
        }),
        "@id": zod.string().min(1),
        literalForm: zod.string(),
        type: zod.enum(["DocumentTitle", "TextualEntity"]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TextualEntity.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        TextualEntity.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TextualEntity.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("textualEntity");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textualEntity");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}EncodingType`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#encodingType",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("textualEntity");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textualEntity");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#TextualEntity",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}EncodingType`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#encodingType",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#literalForm",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class DocumentTitle extends TextualEntity {
  override readonly type = "DocumentTitle";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof TextualEntity>[0],
  ) {
    super(parameters);
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DocumentTitle",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace DocumentTitle {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof TextualEntity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = documentTitleJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = TextualEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DocumentTitle> {
    return DocumentTitle.propertiesFromJson(json).map(
      (properties) => new DocumentTitle(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof TextualEntity.propertiesFromRdf>
    >
  > {
    const _super0Either = TextualEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DocumentTitle",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#DocumentTitle",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof DocumentTitle.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, DocumentTitle> {
    return DocumentTitle.propertiesFromRdf(parameters).map(
      (properties) => new DocumentTitle(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#DocumentTitle",
  );

  export function jsonSchema() {
    return zodToJsonSchema(documentTitleJsonZodSchema());
  }

  export function documentTitleJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [TextualEntity.textualEntityJsonUiSchema({ scopePrefix })],
      label: "DocumentTitle",
      type: "Group",
    };
  }

  export function documentTitleJsonZodSchema() {
    return TextualEntity.textualEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("DocumentTitle"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DocumentTitle.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DocumentTitle.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DocumentTitle.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentTitle");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "documentTitle");
    return [
      ...TextualEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("documentTitle");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "documentTitle");
    return [
      ...TextualEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#DocumentTitle",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class Image extends InformationContentEntity {
  readonly heightPx: number;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "Image";
  readonly url: string;
  readonly widthPx: number;

  constructor(
    parameters: {
      readonly heightPx: number;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly url: string;
      readonly widthPx: number;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    this.heightPx = parameters.heightPx;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.url = parameters.url;
    this.widthPx = parameters.widthPx;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Image): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.heightPx, other.heightPx).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "heightPx",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.url, other.url).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "url",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.widthPx, other.widthPx).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "widthPx",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.heightPx.toString());
    _hasher.update(this.url);
    _hasher.update(this.widthPx.toString());
    return _hasher;
  }

  override toJson(): {
    readonly heightPx: number;
    readonly url: string;
    readonly widthPx: number;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        heightPx: this.heightPx,
        url: this.url,
        widthPx: this.widthPx,
      } satisfies ReturnType<Image["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Image",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#imageHeightPx",
      ),
      this.heightPx,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#url",
      ),
      this.url,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#imageWidthPx",
      ),
      this.widthPx,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Image {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      heightPx: number;
      identifier: rdfjs.NamedNode;
      url: string;
      widthPx: number;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = imageJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const heightPx = _jsonObject["heightPx"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const url = _jsonObject["url"];
    const widthPx = _jsonObject["widthPx"];
    return purify.Either.of({ ..._super0, heightPx, identifier, url, widthPx });
  }

  export function fromJson(json: unknown): purify.Either<zod.ZodError, Image> {
    return Image.propertiesFromJson(json).map(
      (properties) => new Image(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      heightPx: number;
      identifier: rdfjs.NamedNode;
      url: string;
      widthPx: number;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Image",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Image",
          ),
        }),
      );
    }

    const _heightPxEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      number
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#imageHeightPx",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toNumber());
    if (_heightPxEither.isLeft()) {
      return _heightPxEither;
    }

    const heightPx = _heightPxEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _urlEither: purify.Either<rdfjsResource.Resource.ValueError, string> =
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#url",
          ),
          { unique: true },
        )
        .head()
        .chain((_value) => _value.toString());
    if (_urlEither.isLeft()) {
      return _urlEither;
    }

    const url = _urlEither.unsafeCoerce();
    const _widthPxEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      number
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#imageWidthPx",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toNumber());
    if (_widthPxEither.isLeft()) {
      return _widthPxEither;
    }

    const widthPx = _widthPxEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, heightPx, identifier, url, widthPx });
  }

  export function fromRdf(
    parameters: Parameters<typeof Image.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Image> {
    return Image.propertiesFromRdf(parameters).map(
      (properties) => new Image(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Image",
  );

  export function jsonSchema() {
    return zodToJsonSchema(imageJsonZodSchema());
  }

  export function imageJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/heightPx`, type: "Control" },
        { scope: `${scopePrefix}/properties/url`, type: "Control" },
        { scope: `${scopePrefix}/properties/widthPx`, type: "Control" },
      ],
      label: "Image",
      type: "Group",
    };
  }

  export function imageJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        heightPx: zod.number(),
        "@id": zod.string().min(1),
        type: zod.literal("Image"),
        url: zod.string(),
        widthPx: zod.number(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Image.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Image.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Image.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("image");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "image");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}HeightPx`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#imageHeightPx",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Url`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#url",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}WidthPx`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#imageWidthPx",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("image");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "image");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Image",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}HeightPx`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#imageHeightPx",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Url`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#url",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}WidthPx`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#imageWidthPx",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class Document extends InformationContentEntity {
  /**
   * deleted
   */
  readonly deleted: boolean;
  private _identifier: rdfjs.NamedNode | undefined;
  readonly images: readonly Image[];
  readonly memberOfCorpus: CorpusStub;
  /**
   * mutable
   */
  readonly mutable: boolean;
  readonly textualEntities: readonly TextualEntity[];
  readonly title: purify.Maybe<DocumentTitle>;
  override readonly type = "Document";
  readonly url: purify.Maybe<string>;

  constructor(
    parameters: {
      readonly deleted?: boolean;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly images?: readonly Image[];
      readonly memberOfCorpus: CorpusStub;
      readonly mutable?: boolean;
      readonly textualEntities?: readonly TextualEntity[];
      readonly title?: DocumentTitle | purify.Maybe<DocumentTitle>;
      readonly url?: purify.Maybe<string> | string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.deleted === "boolean") {
      this.deleted = parameters.deleted;
    } else if (typeof parameters.deleted === "undefined") {
      this.deleted = false;
    } else {
      this.deleted = parameters.deleted as never;
    }

    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (typeof parameters.images === "undefined") {
      this.images = [];
    } else if (Array.isArray(parameters.images)) {
      this.images = parameters.images;
    } else {
      this.images = parameters.images as never;
    }

    this.memberOfCorpus = parameters.memberOfCorpus;
    if (typeof parameters.mutable === "boolean") {
      this.mutable = parameters.mutable;
    } else if (typeof parameters.mutable === "undefined") {
      this.mutable = false;
    } else {
      this.mutable = parameters.mutable as never;
    }

    if (typeof parameters.textualEntities === "undefined") {
      this.textualEntities = [];
    } else if (Array.isArray(parameters.textualEntities)) {
      this.textualEntities = parameters.textualEntities;
    } else {
      this.textualEntities = parameters.textualEntities as never;
    }

    if (purify.Maybe.isMaybe(parameters.title)) {
      this.title = parameters.title;
    } else if (
      typeof parameters.title === "object" &&
      parameters.title instanceof DocumentTitle
    ) {
      this.title = purify.Maybe.of(parameters.title);
    } else if (typeof parameters.title === "undefined") {
      this.title = purify.Maybe.empty();
    } else {
      this.title = parameters.title as never;
    }

    if (purify.Maybe.isMaybe(parameters.url)) {
      this.url = parameters.url;
    } else if (typeof parameters.url === "string") {
      this.url = purify.Maybe.of(parameters.url);
    } else if (typeof parameters.url === "undefined") {
      this.url = purify.Maybe.empty();
    } else {
      this.url = parameters.url as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${uuid.v4()}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Document): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.deleted, other.deleted).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "deleted",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, (left, right) => left.equals(right)))(
          this.images,
          other.images,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "images",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.memberOfCorpus,
          other.memberOfCorpus,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "memberOfCorpus",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.mutable, other.mutable).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "mutable",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, (left, right) => left.equals(right)))(
          this.textualEntities,
          other.textualEntities,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "textualEntities",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          maybeEquals(left, right, (left, right) => left.equals(right)))(
          this.title,
          other.title,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "title",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => maybeEquals(left, right, strictEquals))(
          this.url,
          other.url,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "url",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.deleted.toString());
    for (const _item0 of this.images) {
      _item0.hash(_hasher);
    }

    this.memberOfCorpus.hash(_hasher);
    _hasher.update(this.mutable.toString());
    for (const _item0 of this.textualEntities) {
      _item0.hash(_hasher);
    }

    this.title.ifJust((_value0) => {
      _value0.hash(_hasher);
    });
    this.url.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  override toJson(): {
    readonly deleted: boolean;
    readonly images: readonly ReturnType<Image["toJson"]>[];
    readonly memberOfCorpus: ReturnType<CorpusStub["toJson"]>;
    readonly mutable: boolean;
    readonly textualEntities: readonly ReturnType<TextualEntity["toJson"]>[];
    readonly title: ReturnType<DocumentTitle["toJson"]> | undefined;
    readonly url: string | undefined;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        deleted: this.deleted,
        images: this.images.map((_item) => _item.toJson()),
        memberOfCorpus: this.memberOfCorpus.toJson(),
        mutable: this.mutable,
        textualEntities: this.textualEntities.map((_item) => _item.toJson()),
        title: this.title.map((_item) => _item.toJson()).extract(),
        url: this.url.map((_item) => _item).extract(),
      } satisfies ReturnType<Document["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Document",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#deleted",
      ),
      this.deleted ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#image",
      ),
      this.images.map((_item) =>
        _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#memberOfCorpus",
      ),
      this.memberOfCorpus.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#mutable",
      ),
      this.mutable ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#textualEntity",
      ),
      this.textualEntities.map((_item) =>
        _item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#title",
      ),
      this.title.map((_value) =>
        _value.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#url",
      ),
      this.url,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Document {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      images: readonly Image[];
      memberOfCorpus: CorpusStub;
      mutable: boolean;
      textualEntities: readonly TextualEntity[];
      title: purify.Maybe<DocumentTitle>;
      url: purify.Maybe<string>;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = documentJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const deleted = _jsonObject["deleted"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const images = _jsonObject["images"].map((_item) =>
      Image.fromJson(_item).unsafeCoerce(),
    );
    const memberOfCorpus = CorpusStub.fromJson(
      _jsonObject["memberOfCorpus"],
    ).unsafeCoerce();
    const mutable = _jsonObject["mutable"];
    const textualEntities = _jsonObject["textualEntities"].map((_item) =>
      TextualEntity.fromJson(_item).unsafeCoerce(),
    );
    const title = purify.Maybe.fromNullable(_jsonObject["title"]).map((_item) =>
      DocumentTitle.fromJson(_item).unsafeCoerce(),
    );
    const url = purify.Maybe.fromNullable(_jsonObject["url"]);
    return purify.Either.of({
      ..._super0,
      deleted,
      identifier,
      images,
      memberOfCorpus,
      mutable,
      textualEntities,
      title,
      url,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Document> {
    return Document.propertiesFromJson(json).map(
      (properties) => new Document(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      images: readonly Image[];
      memberOfCorpus: CorpusStub;
      mutable: boolean;
      textualEntities: readonly TextualEntity[];
      title: purify.Maybe<DocumentTitle>;
      url: purify.Maybe<string>;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Document",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Document",
          ),
        }),
      );
    }

    const _deletedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#deleted",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_deletedEither.isLeft()) {
      return _deletedEither;
    }

    const deleted = _deletedEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _imagesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly Image[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#image",
          ),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              Image.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_imagesEither.isLeft()) {
      return _imagesEither;
    }

    const images = _imagesEither.unsafeCoerce();
    const _memberOfCorpusEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CorpusStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#memberOfCorpus",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        CorpusStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_memberOfCorpusEither.isLeft()) {
      return _memberOfCorpusEither;
    }

    const memberOfCorpus = _memberOfCorpusEither.unsafeCoerce();
    const _mutableEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#mutable",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#mutable",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_mutableEither.isLeft()) {
      return _mutableEither;
    }

    const mutable = _mutableEither.unsafeCoerce();
    const _textualEntitiesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly TextualEntity[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#textualEntity",
          ),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              TextualEntity.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_textualEntitiesEither.isLeft()) {
      return _textualEntitiesEither;
    }

    const textualEntities = _textualEntitiesEither.unsafeCoerce();
    const _titleEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<DocumentTitle>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#title",
          ),
          { unique: true },
        )
        .head()
        .chain((value) => value.toNamedResource())
        .chain((_resource) =>
          DocumentTitle.fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_titleEither.isLeft()) {
      return _titleEither;
    }

    const title = _titleEither.unsafeCoerce();
    const _urlEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#url",
          ),
          { unique: true },
        )
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_urlEither.isLeft()) {
      return _urlEither;
    }

    const url = _urlEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      deleted,
      identifier,
      images,
      memberOfCorpus,
      mutable,
      textualEntities,
      title,
      url,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof Document.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Document> {
    return Document.propertiesFromRdf(parameters).map(
      (properties) => new Document(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Document",
  );

  export function jsonSchema() {
    return zodToJsonSchema(documentJsonZodSchema());
  }

  export function documentJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        {
          label: "deleted",
          scope: `${scopePrefix}/properties/deleted`,
          type: "Control",
        },
        Image.imageJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/images`,
        }),
        CorpusStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/memberOfCorpus`,
        }),
        {
          label: "mutable",
          scope: `${scopePrefix}/properties/mutable`,
          type: "Control",
        },
        TextualEntity.textualEntityJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/textualEntities`,
        }),
        DocumentTitle.documentTitleJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/title`,
        }),
        { scope: `${scopePrefix}/properties/url`, type: "Control" },
      ],
      label: "Document",
      type: "Group",
    };
  }

  export function documentJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        deleted: zod.boolean(),
        "@id": zod.string().min(1),
        images: Image.imageJsonZodSchema().array(),
        memberOfCorpus: CorpusStub.jsonZodSchema(),
        mutable: zod.boolean(),
        textualEntities: TextualEntity.textualEntityJsonZodSchema().array(),
        title: DocumentTitle.documentTitleJsonZodSchema().optional(),
        type: zod.literal("Document"),
        url: zod.string().optional(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Document.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Document.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Document.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("document");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "document");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Deleted`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Images`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#image",
        ),
        subject,
      },
      ...Image.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Images`),
        variablePrefix: `${variablePrefix}Images`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}MemberOfCorpus`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#memberOfCorpus",
        ),
        subject,
      },
      ...CorpusStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}MemberOfCorpus`),
        variablePrefix: `${variablePrefix}MemberOfCorpus`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Mutable`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#mutable",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}TextualEntities`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#textualEntity",
        ),
        subject,
      },
      ...TextualEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}TextualEntities`),
        variablePrefix: `${variablePrefix}TextualEntities`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Title`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#title",
        ),
        subject,
      },
      ...DocumentTitle.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Title`),
        variablePrefix: `${variablePrefix}Title`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Url`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#url",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("document");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "document");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Document",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Deleted`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#deleted",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Images`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#image",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...Image.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Images`),
            variablePrefix: `${variablePrefix}Images`,
          }),
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}MemberOfCorpus`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#memberOfCorpus",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...CorpusStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}MemberOfCorpus`),
        variablePrefix: `${variablePrefix}MemberOfCorpus`,
      }),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Mutable`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#mutable",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}TextualEntities`,
                ),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#textualEntity",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...TextualEntity.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}TextualEntities`),
            variablePrefix: `${variablePrefix}TextualEntities`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Title`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#title",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
          ...DocumentTitle.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Title`),
            variablePrefix: `${variablePrefix}Title`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Url`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#url",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class DichotomousQuestion extends BaseQuestion {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly noLabel: purify.Maybe<rdfjs.Literal>;
  override readonly type = "DichotomousQuestion";
  readonly yesLabel: purify.Maybe<rdfjs.Literal>;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly noLabel?:
        | rdfjs.Literal
        | Date
        | boolean
        | number
        | purify.Maybe<rdfjs.Literal>
        | string;
      readonly yesLabel?:
        | rdfjs.Literal
        | Date
        | boolean
        | number
        | purify.Maybe<rdfjs.Literal>
        | string;
    } & ConstructorParameters<typeof BaseQuestion>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.noLabel)) {
      this.noLabel = parameters.noLabel;
    } else if (typeof parameters.noLabel === "boolean") {
      this.noLabel = purify.Maybe.of(rdfLiteral.toRdf(parameters.noLabel));
    } else if (
      typeof parameters.noLabel === "object" &&
      parameters.noLabel instanceof Date
    ) {
      this.noLabel = purify.Maybe.of(rdfLiteral.toRdf(parameters.noLabel));
    } else if (typeof parameters.noLabel === "number") {
      this.noLabel = purify.Maybe.of(rdfLiteral.toRdf(parameters.noLabel));
    } else if (typeof parameters.noLabel === "string") {
      this.noLabel = purify.Maybe.of(dataFactory.literal(parameters.noLabel));
    } else if (typeof parameters.noLabel === "object") {
      this.noLabel = purify.Maybe.of(parameters.noLabel);
    } else if (typeof parameters.noLabel === "undefined") {
      this.noLabel = purify.Maybe.empty();
    } else {
      this.noLabel = parameters.noLabel as never;
    }

    if (purify.Maybe.isMaybe(parameters.yesLabel)) {
      this.yesLabel = parameters.yesLabel;
    } else if (typeof parameters.yesLabel === "boolean") {
      this.yesLabel = purify.Maybe.of(rdfLiteral.toRdf(parameters.yesLabel));
    } else if (
      typeof parameters.yesLabel === "object" &&
      parameters.yesLabel instanceof Date
    ) {
      this.yesLabel = purify.Maybe.of(rdfLiteral.toRdf(parameters.yesLabel));
    } else if (typeof parameters.yesLabel === "number") {
      this.yesLabel = purify.Maybe.of(rdfLiteral.toRdf(parameters.yesLabel));
    } else if (typeof parameters.yesLabel === "string") {
      this.yesLabel = purify.Maybe.of(dataFactory.literal(parameters.yesLabel));
    } else if (typeof parameters.yesLabel === "object") {
      this.yesLabel = purify.Maybe.of(parameters.yesLabel);
    } else if (typeof parameters.yesLabel === "undefined") {
      this.yesLabel = purify.Maybe.empty();
    } else {
      this.yesLabel = parameters.yesLabel as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: DichotomousQuestion): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => maybeEquals(left, right, booleanEquals))(
          this.noLabel,
          other.noLabel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "noLabel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => maybeEquals(left, right, booleanEquals))(
          this.yesLabel,
          other.yesLabel,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "yesLabel",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.noLabel.ifJust((_value0) => {
      _hasher.update(_value0.datatype.value);
      _hasher.update(_value0.language);
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    this.yesLabel.ifJust((_value0) => {
      _hasher.update(_value0.datatype.value);
      _hasher.update(_value0.language);
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    return _hasher;
  }

  override toJson(): {
    readonly noLabel:
      | {
          readonly "@language": string | undefined;
          readonly "@type": string | undefined;
          readonly "@value": string;
        }
      | undefined;
    readonly yesLabel:
      | {
          readonly "@language": string | undefined;
          readonly "@type": string | undefined;
          readonly "@value": string;
        }
      | undefined;
  } & ReturnType<BaseQuestion["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        noLabel: this.noLabel
          .map((_item) => ({
            "@language": _item.language.length > 0 ? _item.language : undefined,
            "@type":
              _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? _item.datatype.value
                : undefined,
            "@value": _item.value,
          }))
          .extract(),
        yesLabel: this.yesLabel
          .map((_item) => ({
            "@language": _item.language.length > 0 ? _item.language : undefined,
            "@type":
              _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
                ? _item.datatype.value
                : undefined,
            "@value": _item.value,
          }))
          .extract(),
      } satisfies ReturnType<DichotomousQuestion["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DichotomousQuestion",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#noLabel",
      ),
      this.noLabel,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#yesLabel",
      ),
      this.yesLabel,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace DichotomousQuestion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      noLabel: purify.Maybe<rdfjs.Literal>;
      yesLabel: purify.Maybe<rdfjs.Literal>;
    } & UnwrapR<ReturnType<typeof BaseQuestion.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      dichotomousQuestionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseQuestion.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const noLabel = purify.Maybe.fromNullable(_jsonObject["noLabel"]).map(
      (_item) =>
        dataFactory.literal(
          _item["@value"],
          typeof _item["@language"] !== "undefined"
            ? _item["@language"]
            : typeof _item["@type"] !== "undefined"
              ? dataFactory.namedNode(_item["@type"])
              : undefined,
        ),
    );
    const yesLabel = purify.Maybe.fromNullable(_jsonObject["yesLabel"]).map(
      (_item) =>
        dataFactory.literal(
          _item["@value"],
          typeof _item["@language"] !== "undefined"
            ? _item["@language"]
            : typeof _item["@type"] !== "undefined"
              ? dataFactory.namedNode(_item["@type"])
              : undefined,
        ),
    );
    return purify.Either.of({ ..._super0, identifier, noLabel, yesLabel });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, DichotomousQuestion> {
    return DichotomousQuestion.propertiesFromJson(json).map(
      (properties) => new DichotomousQuestion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      noLabel: purify.Maybe<rdfjs.Literal>;
      yesLabel: purify.Maybe<rdfjs.Literal>;
    } & UnwrapR<ReturnType<typeof BaseQuestion.propertiesFromRdf>>
  > {
    const _super0Either = BaseQuestion.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#DichotomousQuestion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#DichotomousQuestion",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _noLabelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#noLabel",
          ),
          { unique: true },
        )
        .filter((_value) => {
          const _languageInOrDefault = _languageIn ?? [];
          if (_languageInOrDefault.length === 0) {
            return true;
          }
          const _valueLiteral = _value.toLiteral().toMaybe().extract();
          if (typeof _valueLiteral === "undefined") {
            return false;
          }
          return _languageInOrDefault.some(
            (_languageIn) => _languageIn === _valueLiteral.language,
          );
        })
        .head()
        .chain((_value) => _value.toLiteral())
        .toMaybe(),
    );
    if (_noLabelEither.isLeft()) {
      return _noLabelEither;
    }

    const noLabel = _noLabelEither.unsafeCoerce();
    const _yesLabelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.Literal>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#yesLabel",
          ),
          { unique: true },
        )
        .filter((_value) => {
          const _languageInOrDefault = _languageIn ?? [];
          if (_languageInOrDefault.length === 0) {
            return true;
          }
          const _valueLiteral = _value.toLiteral().toMaybe().extract();
          if (typeof _valueLiteral === "undefined") {
            return false;
          }
          return _languageInOrDefault.some(
            (_languageIn) => _languageIn === _valueLiteral.language,
          );
        })
        .head()
        .chain((_value) => _value.toLiteral())
        .toMaybe(),
    );
    if (_yesLabelEither.isLeft()) {
      return _yesLabelEither;
    }

    const yesLabel = _yesLabelEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, noLabel, yesLabel });
  }

  export function fromRdf(
    parameters: Parameters<typeof DichotomousQuestion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, DichotomousQuestion> {
    return DichotomousQuestion.propertiesFromRdf(parameters).map(
      (properties) => new DichotomousQuestion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#DichotomousQuestion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(dichotomousQuestionJsonZodSchema());
  }

  export function dichotomousQuestionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseQuestion.baseQuestionJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/noLabel`, type: "Control" },
        { scope: `${scopePrefix}/properties/yesLabel`, type: "Control" },
      ],
      label: "DichotomousQuestion",
      type: "Group",
    };
  }

  export function dichotomousQuestionJsonZodSchema() {
    return BaseQuestion.baseQuestionJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        noLabel: zod
          .object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          })
          .optional(),
        type: zod.literal("DichotomousQuestion"),
        yesLabel: zod
          .object({
            "@language": zod.string().optional(),
            "@type": zod.string().optional(),
            "@value": zod.string(),
          })
          .optional(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        DichotomousQuestion.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        DichotomousQuestion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      DichotomousQuestion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("dichotomousQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "dichotomousQuestion");
    return [
      ...BaseQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}NoLabel`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#noLabel",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}YesLabel`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#yesLabel",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("dichotomousQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "dichotomousQuestion");
    return [
      ...BaseQuestion.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#DichotomousQuestion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}NoLabel`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#noLabel",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}YesLabel`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#yesLabel",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class CorpusStub {
  /**
   * deleted
   */
  readonly deleted: boolean;
  readonly identifier: rdfjs.NamedNode;
  /**
   * has label
   */
  readonly label: purify.Maybe<string>;
  readonly type = "CorpusStub";

  constructor(parameters: {
    readonly deleted?: boolean;
    readonly identifier: rdfjs.NamedNode | string;
    readonly label?: purify.Maybe<string> | string;
  }) {
    if (typeof parameters.deleted === "boolean") {
      this.deleted = parameters.deleted;
    } else if (typeof parameters.deleted === "undefined") {
      this.deleted = false;
    } else {
      this.deleted = parameters.deleted as never;
    }

    if (typeof parameters.identifier === "object") {
      this.identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this.identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this.identifier = parameters.identifier as never;
    }

    if (purify.Maybe.isMaybe(parameters.label)) {
      this.label = parameters.label;
    } else if (typeof parameters.label === "string") {
      this.label = purify.Maybe.of(parameters.label);
    } else if (typeof parameters.label === "undefined") {
      this.label = purify.Maybe.empty();
    } else {
      this.label = parameters.label as never;
    }
  }

  equals(other: CorpusStub): EqualsResult {
    return strictEquals(this.deleted, other.deleted)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "deleted",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        booleanEquals(this.identifier, other.identifier).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "identifier",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => maybeEquals(left, right, strictEquals))(
          this.label,
          other.label,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "label",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.deleted.toString());
    this.label.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  toJson(): {
    readonly deleted: boolean;
    readonly "@id": string;
    readonly label: string | undefined;
    readonly type: "CorpusStub";
  } {
    return JSON.parse(
      JSON.stringify({
        deleted: this.deleted,
        "@id": this.identifier.value,
        label: this.label.map((_item) => _item).extract(),
        type: this.type,
      } satisfies ReturnType<CorpusStub["toJson"]>),
    );
  }

  toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Corpus",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#deleted",
      ),
      this.deleted ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace CorpusStub {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: purify.Maybe<string>;
    }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const deleted = _jsonObject["deleted"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = purify.Maybe.fromNullable(_jsonObject["label"]);
    return purify.Either.of({ deleted, identifier, label });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CorpusStub> {
    return CorpusStub.propertiesFromJson(json).map(
      (properties) => new CorpusStub(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: purify.Maybe<string>;
    }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Corpus",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Corpus",
          ),
        }),
      );
    }

    const _deletedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#deleted",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_deletedEither.isLeft()) {
      return _deletedEither;
    }

    const deleted = _deletedEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values(
          dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
          { unique: true },
        )
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    return purify.Either.of({ deleted, identifier, label });
  }

  export function fromRdf(
    parameters: Parameters<typeof CorpusStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CorpusStub> {
    return CorpusStub.propertiesFromRdf(parameters).map(
      (properties) => new CorpusStub(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Corpus",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "deleted",
          scope: `${scopePrefix}/properties/deleted`,
          type: "Control",
        },
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "CorpusStub" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "CorpusStub",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      deleted: zod.boolean(),
      "@id": zod.string().min(1),
      label: zod.string().optional(),
      type: zod.literal("CorpusStub"),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CorpusStub.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CorpusStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CorpusStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("corpusStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpusStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Deleted`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("corpusStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpusStub");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Corpus",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Deleted`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#deleted",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Label`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2000/01/rdf-schema#label",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class CorpusDeletionInput extends ProcessInput {
  readonly corpus: CorpusStub;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "CorpusDeletionInput";

  constructor(
    parameters: {
      readonly corpus: CorpusStub;
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof ProcessInput>[0],
  ) {
    super(parameters);
    this.corpus = parameters.corpus;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: CorpusDeletionInput): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(
          this.corpus,
          other.corpus,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "corpus",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.corpus.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly corpus: ReturnType<CorpusStub["toJson"]>;
  } & ReturnType<ProcessInput["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        corpus: this.corpus.toJson(),
      } satisfies ReturnType<CorpusDeletionInput["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CorpusDeletionInput",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#corpus",
      ),
      this.corpus.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace CorpusDeletionInput {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { corpus: CorpusStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessInput.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      corpusDeletionInputJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = ProcessInput.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const corpus = CorpusStub.fromJson(_jsonObject["corpus"]).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, corpus, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CorpusDeletionInput> {
    return CorpusDeletionInput.propertiesFromJson(json).map(
      (properties) => new CorpusDeletionInput(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { corpus: CorpusStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof ProcessInput.propertiesFromRdf>
    >
  > {
    const _super0Either = ProcessInput.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CorpusDeletionInput",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#CorpusDeletionInput",
          ),
        }),
      );
    }

    const _corpusEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CorpusStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#corpus",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        CorpusStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_corpusEither.isLeft()) {
      return _corpusEither;
    }

    const corpus = _corpusEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, corpus, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof CorpusDeletionInput.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CorpusDeletionInput> {
    return CorpusDeletionInput.propertiesFromRdf(parameters).map(
      (properties) => new CorpusDeletionInput(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#CorpusDeletionInput",
  );

  export function jsonSchema() {
    return zodToJsonSchema(corpusDeletionInputJsonZodSchema());
  }

  export function corpusDeletionInputJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ProcessInput.processInputJsonUiSchema({ scopePrefix }),
        CorpusStub.jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/corpus`,
        }),
      ],
      label: "CorpusDeletionInput",
      type: "Group",
    };
  }

  export function corpusDeletionInputJsonZodSchema() {
    return ProcessInput.processInputJsonZodSchema().merge(
      zod.object({
        corpus: CorpusStub.jsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("CorpusDeletionInput"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CorpusDeletionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CorpusDeletionInput.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CorpusDeletionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("corpusDeletionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpusDeletionInput");
    return [
      ...ProcessInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Corpus`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#corpus",
        ),
        subject,
      },
      ...CorpusStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Corpus`),
        variablePrefix: `${variablePrefix}Corpus`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("corpusDeletionInput");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpusDeletionInput");
    return [
      ...ProcessInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#CorpusDeletionInput",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Corpus`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#corpus",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...CorpusStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Corpus`),
        variablePrefix: `${variablePrefix}Corpus`,
      }),
    ];
  }
}
export class CorpusDeletion extends Process {
  private _identifier: rdfjs.NamedNode | undefined;
  readonly input: CorpusDeletionInput;
  override readonly type = "CorpusDeletion";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly input: CorpusDeletionInput;
    } & ConstructorParameters<typeof Process>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.input = parameters.input;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: CorpusDeletion): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => left.equals(right))(this.input, other.input).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "input",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    this.input.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly input: ReturnType<CorpusDeletionInput["toJson"]>;
  } & ReturnType<Process["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        input: this.input.toJson(),
      } satisfies ReturnType<CorpusDeletion["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CorpusDeletion",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#processInput",
      ),
      this.input.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace CorpusDeletion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; input: CorpusDeletionInput } & UnwrapR<
      ReturnType<typeof Process.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = corpusDeletionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = Process.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const input = CorpusDeletionInput.fromJson(
      _jsonObject["input"],
    ).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CorpusDeletion> {
    return CorpusDeletion.propertiesFromJson(json).map(
      (properties) => new CorpusDeletion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; input: CorpusDeletionInput } & UnwrapR<
      ReturnType<typeof Process.propertiesFromRdf>
    >
  > {
    const _super0Either = Process.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CorpusDeletion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#CorpusDeletion",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _inputEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CorpusDeletionInput
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        CorpusDeletionInput.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_inputEither.isLeft()) {
      return _inputEither;
    }

    const input = _inputEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, input });
  }

  export function fromRdf(
    parameters: Parameters<typeof CorpusDeletion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CorpusDeletion> {
    return CorpusDeletion.propertiesFromRdf(parameters).map(
      (properties) => new CorpusDeletion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#CorpusDeletion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(corpusDeletionJsonZodSchema());
  }

  export function corpusDeletionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        Process.processJsonUiSchema({ scopePrefix }),
        CorpusDeletionInput.corpusDeletionInputJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/input`,
        }),
      ],
      label: "CorpusDeletion",
      type: "Group",
    };
  }

  export function corpusDeletionJsonZodSchema() {
    return Process.processJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        input: CorpusDeletionInput.corpusDeletionInputJsonZodSchema(),
        type: zod.literal("CorpusDeletion"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CorpusDeletion.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CorpusDeletion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CorpusDeletion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("corpusDeletion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpusDeletion");
    return [
      ...Process.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Input`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#processInput",
        ),
        subject,
      },
      ...CorpusDeletionInput.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("corpusDeletion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpusDeletion");
    return [
      ...Process.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#CorpusDeletion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Input`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#processInput",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...CorpusDeletionInput.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Input`),
        variablePrefix: `${variablePrefix}Input`,
      }),
    ];
  }
}
export class Corpus extends InformationContentEntity {
  /**
   * deleted
   */
  readonly deleted: boolean;
  private _identifier: rdfjs.NamedNode | undefined;
  /**
   * has label
   */
  readonly label: string;
  /**
   * mutable
   */
  readonly mutable: boolean;
  override readonly type = "Corpus";

  constructor(
    parameters: {
      readonly deleted?: boolean;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly label: string;
      readonly mutable?: boolean;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.deleted === "boolean") {
      this.deleted = parameters.deleted;
    } else if (typeof parameters.deleted === "undefined") {
      this.deleted = false;
    } else {
      this.deleted = parameters.deleted as never;
    }

    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.label = parameters.label;
    if (typeof parameters.mutable === "boolean") {
      this.mutable = parameters.mutable;
    } else if (typeof parameters.mutable === "undefined") {
      this.mutable = false;
    } else {
      this.mutable = parameters.mutable as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${uuid.v4()}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Corpus): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.deleted, other.deleted).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "deleted",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.label, other.label).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "label",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        strictEquals(this.mutable, other.mutable).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "mutable",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.deleted.toString());
    _hasher.update(this.label);
    _hasher.update(this.mutable.toString());
    return _hasher;
  }

  override toJson(): {
    readonly deleted: boolean;
    readonly label: string;
    readonly mutable: boolean;
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        deleted: this.deleted,
        label: this.label,
        mutable: this.mutable,
      } satisfies ReturnType<Corpus["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Corpus",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#deleted",
      ),
      this.deleted ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.label,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#mutable",
      ),
      this.mutable ? true : undefined,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Corpus {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: string;
      mutable: boolean;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = corpusJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const deleted = _jsonObject["deleted"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const label = _jsonObject["label"];
    const mutable = _jsonObject["mutable"];
    return purify.Either.of({
      ..._super0,
      deleted,
      identifier,
      label,
      mutable,
    });
  }

  export function fromJson(json: unknown): purify.Either<zod.ZodError, Corpus> {
    return Corpus.propertiesFromJson(json).map(
      (properties) => new Corpus(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      deleted: boolean;
      identifier: rdfjs.NamedNode;
      label: string;
      mutable: boolean;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Corpus",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Corpus",
          ),
        }),
      );
    }

    const _deletedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#deleted",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_deletedEither.isLeft()) {
      return _deletedEither;
    }

    const deleted = _deletedEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_labelEither.isLeft()) {
      return _labelEither;
    }

    const label = _labelEither.unsafeCoerce();
    const _mutableEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#mutable",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#mutable",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_mutableEither.isLeft()) {
      return _mutableEither;
    }

    const mutable = _mutableEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      deleted,
      identifier,
      label,
      mutable,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof Corpus.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Corpus> {
    return Corpus.propertiesFromRdf(parameters).map(
      (properties) => new Corpus(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Corpus",
  );

  export function jsonSchema() {
    return zodToJsonSchema(corpusJsonZodSchema());
  }

  export function corpusJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        {
          label: "deleted",
          scope: `${scopePrefix}/properties/deleted`,
          type: "Control",
        },
        {
          label: "has label",
          scope: `${scopePrefix}/properties/label`,
          type: "Control",
        },
        {
          label: "mutable",
          scope: `${scopePrefix}/properties/mutable`,
          type: "Control",
        },
      ],
      label: "Corpus",
      type: "Group",
    };
  }

  export function corpusJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        deleted: zod.boolean(),
        "@id": zod.string().min(1),
        label: zod.string(),
        mutable: zod.boolean(),
        type: zod.literal("Corpus"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Corpus.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Corpus.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Corpus.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("corpus");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpus");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Deleted`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#deleted",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Label`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Mutable`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#mutable",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("corpus");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "corpus");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Corpus",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Deleted`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#deleted",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Label`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/2000/01/rdf-schema#label",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Mutable`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#mutable",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
abstract class BaseConceptSelector extends InformationContentEntity {
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "ConceptSchemeConceptSelector"
    | "ConceptSchemeTopConceptSelector"
    | "EnumeratedConceptSelector"
    | "NarrowerConceptSelector"
    | "NarrowerTransitiveConceptSelector";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace BaseConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      baseConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromRdf>
    >
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(baseConceptSelectorJsonZodSchema());
  }

  export function baseConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
      ],
      label: "BaseConceptSelector",
      type: "Group",
    };
  }

  export function baseConceptSelectorJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.enum([
          "ConceptSchemeConceptSelector",
          "ConceptSchemeTopConceptSelector",
          "EnumeratedConceptSelector",
          "NarrowerConceptSelector",
          "NarrowerTransitiveConceptSelector",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseConceptSelector.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("baseConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseConceptSelector");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("baseConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "baseConceptSelector");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    ];
  }
}
abstract class BaseFocusConceptSelector extends BaseConceptSelector {
  readonly focusConcept: ConceptStub;
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "NarrowerConceptSelector"
    | "NarrowerTransitiveConceptSelector";

  constructor(
    parameters: { readonly focusConcept: ConceptStub } & ConstructorParameters<
      typeof BaseConceptSelector
    >[0],
  ) {
    super(parameters);
    this.focusConcept = parameters.focusConcept;
  }

  override equals(other: BaseFocusConceptSelector): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ConceptStub.equals(this.focusConcept, other.focusConcept).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "focusConcept",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    ConceptStub.hashConceptStub(this.focusConcept, _hasher);
    return _hasher;
  }

  override toJson(): {
    readonly focusConcept: ReturnType<typeof ConceptStub.toJson>;
  } & ReturnType<BaseConceptSelector["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        focusConcept: ConceptStub.toJson(this.focusConcept),
      } satisfies ReturnType<BaseFocusConceptSelector["toJson"]>),
    );
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#focusConcept",
      ),
      ConceptStub.toRdf(this.focusConcept, {
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace BaseFocusConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { focusConcept: ConceptStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      baseFocusConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const focusConcept = ConceptStub.fromJson(
      _jsonObject["focusConcept"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, focusConcept, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { focusConcept: ConceptStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const _focusConceptEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ConceptStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#focusConcept",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        ConceptStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_focusConceptEither.isLeft()) {
      return _focusConceptEither;
    }

    const focusConcept = _focusConceptEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, focusConcept, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(baseFocusConceptSelectorJsonZodSchema());
  }

  export function baseFocusConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseConceptSelector.baseConceptSelectorJsonUiSchema({ scopePrefix }),
        ConceptStub.conceptStubJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/focusConcept`,
        }),
      ],
      label: "BaseFocusConceptSelector",
      type: "Group",
    };
  }

  export function baseFocusConceptSelectorJsonZodSchema() {
    return BaseConceptSelector.baseConceptSelectorJsonZodSchema().merge(
      zod.object({
        focusConcept: ConceptStub.conceptStubJsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.enum([
          "NarrowerConceptSelector",
          "NarrowerTransitiveConceptSelector",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseFocusConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseFocusConceptSelector.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseFocusConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("baseFocusConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseFocusConceptSelector");
    return [
      ...BaseConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}FocusConcept`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#focusConcept",
        ),
        subject,
      },
      ...ConceptStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}FocusConcept`),
        variablePrefix: `${variablePrefix}FocusConcept`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("baseFocusConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseFocusConceptSelector");
    return [
      ...BaseConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}FocusConcept`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#focusConcept",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...ConceptStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}FocusConcept`),
        variablePrefix: `${variablePrefix}FocusConcept`,
      }),
    ];
  }
}
export class NarrowerTransitiveConceptSelector extends BaseFocusConceptSelector {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "NarrowerTransitiveConceptSelector";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseFocusConceptSelector>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#NarrowerTransitiveConceptSelector",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace NarrowerTransitiveConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseFocusConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      narrowerTransitiveConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      BaseFocusConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NarrowerTransitiveConceptSelector> {
    return NarrowerTransitiveConceptSelector.propertiesFromJson(json).map(
      (properties) => new NarrowerTransitiveConceptSelector(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseFocusConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseFocusConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#NarrowerTransitiveConceptSelector",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#NarrowerTransitiveConceptSelector",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof NarrowerTransitiveConceptSelector.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    NarrowerTransitiveConceptSelector
  > {
    return NarrowerTransitiveConceptSelector.propertiesFromRdf(parameters).map(
      (properties) => new NarrowerTransitiveConceptSelector(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#NarrowerTransitiveConceptSelector",
  );

  export function jsonSchema() {
    return zodToJsonSchema(narrowerTransitiveConceptSelectorJsonZodSchema());
  }

  export function narrowerTransitiveConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseFocusConceptSelector.baseFocusConceptSelectorJsonUiSchema({
          scopePrefix,
        }),
      ],
      label: "NarrowerTransitiveConceptSelector",
      type: "Group",
    };
  }

  export function narrowerTransitiveConceptSelectorJsonZodSchema() {
    return BaseFocusConceptSelector.baseFocusConceptSelectorJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("NarrowerTransitiveConceptSelector"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NarrowerTransitiveConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        NarrowerTransitiveConceptSelector.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NarrowerTransitiveConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("narrowerTransitiveConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "narrowerTransitiveConceptSelector");
    return [
      ...BaseFocusConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("narrowerTransitiveConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "narrowerTransitiveConceptSelector");
    return [
      ...BaseFocusConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#NarrowerTransitiveConceptSelector",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class NarrowerConceptSelector extends BaseFocusConceptSelector {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "NarrowerConceptSelector";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseFocusConceptSelector>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#NarrowerConceptSelector",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace NarrowerConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseFocusConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      narrowerConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      BaseFocusConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, NarrowerConceptSelector> {
    return NarrowerConceptSelector.propertiesFromJson(json).map(
      (properties) => new NarrowerConceptSelector(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseFocusConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseFocusConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#NarrowerConceptSelector",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#NarrowerConceptSelector",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof NarrowerConceptSelector.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, NarrowerConceptSelector> {
    return NarrowerConceptSelector.propertiesFromRdf(parameters).map(
      (properties) => new NarrowerConceptSelector(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#NarrowerConceptSelector",
  );

  export function jsonSchema() {
    return zodToJsonSchema(narrowerConceptSelectorJsonZodSchema());
  }

  export function narrowerConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseFocusConceptSelector.baseFocusConceptSelectorJsonUiSchema({
          scopePrefix,
        }),
      ],
      label: "NarrowerConceptSelector",
      type: "Group",
    };
  }

  export function narrowerConceptSelectorJsonZodSchema() {
    return BaseFocusConceptSelector.baseFocusConceptSelectorJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("NarrowerConceptSelector"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        NarrowerConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        NarrowerConceptSelector.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      NarrowerConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("narrowerConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "narrowerConceptSelector");
    return [
      ...BaseFocusConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("narrowerConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "narrowerConceptSelector");
    return [
      ...BaseFocusConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#NarrowerConceptSelector",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class EnumeratedConceptSelector extends BaseConceptSelector {
  readonly concepts: readonly ConceptStub[];
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "EnumeratedConceptSelector";

  constructor(
    parameters: {
      readonly concepts: readonly ConceptStub[];
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseConceptSelector>[0],
  ) {
    super(parameters);
    this.concepts = parameters.concepts;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: EnumeratedConceptSelector): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) => arrayEquals(left, right, ConceptStub.equals))(
          this.concepts,
          other.concepts,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "concepts",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.concepts) {
      ConceptStub.hashConceptStub(_element0, _hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly concepts: readonly ReturnType<typeof ConceptStub.toJson>[];
  } & ReturnType<BaseConceptSelector["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        concepts: this.concepts.map((_item) => ConceptStub.toJson(_item)),
      } satisfies ReturnType<EnumeratedConceptSelector["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#EnumeratedConceptSelector",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#enumeratedConcepts",
      ),
      this.concepts.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#ConceptStubList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            ConceptStub.toRdf(item, {
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.concepts.reduce((_hasher, _item) => {
                ConceptStub.hashConceptStub(_item, _hasher);
                return _hasher;
              }, sha256.create())}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace EnumeratedConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { concepts: readonly ConceptStub[]; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      enumeratedConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const concepts = _jsonObject["concepts"].map((_item) =>
      ConceptStub.fromJson(_item).unsafeCoerce(),
    );
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, concepts, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, EnumeratedConceptSelector> {
    return EnumeratedConceptSelector.propertiesFromJson(json).map(
      (properties) => new EnumeratedConceptSelector(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { concepts: readonly ConceptStub[]; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#EnumeratedConceptSelector",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#EnumeratedConceptSelector",
          ),
        }),
      );
    }

    const _conceptsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly ConceptStub[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#enumeratedConcepts",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              ConceptStub.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_conceptsEither.isLeft()) {
      return _conceptsEither;
    }

    const concepts = _conceptsEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, concepts, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof EnumeratedConceptSelector.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    EnumeratedConceptSelector
  > {
    return EnumeratedConceptSelector.propertiesFromRdf(parameters).map(
      (properties) => new EnumeratedConceptSelector(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#EnumeratedConceptSelector",
  );

  export function jsonSchema() {
    return zodToJsonSchema(enumeratedConceptSelectorJsonZodSchema());
  }

  export function enumeratedConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseConceptSelector.baseConceptSelectorJsonUiSchema({ scopePrefix }),
        ConceptStub.conceptStubJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/concepts`,
        }),
      ],
      label: "EnumeratedConceptSelector",
      type: "Group",
    };
  }

  export function enumeratedConceptSelectorJsonZodSchema() {
    return BaseConceptSelector.baseConceptSelectorJsonZodSchema().merge(
      zod.object({
        concepts: ConceptStub.conceptStubJsonZodSchema().array(),
        "@id": zod.string().min(1),
        type: zod.literal("EnumeratedConceptSelector"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        EnumeratedConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        EnumeratedConceptSelector.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      EnumeratedConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("enumeratedConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "enumeratedConceptSelector");
    return [
      ...BaseConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Concepts`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#enumeratedConcepts",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Concepts`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Concepts`}Item0`),
      },
      ...ConceptStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}Item0`),
        variablePrefix: `${`${variablePrefix}Concepts`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Concepts`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Concepts`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Concepts`}ItemN`),
      },
      ...ConceptStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}ItemN`),
        variablePrefix: `${`${variablePrefix}Concepts`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(
          `${`${variablePrefix}Concepts`}RestNBasic`,
        ),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("enumeratedConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "enumeratedConceptSelector");
    return [
      ...BaseConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#EnumeratedConceptSelector",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Concepts`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#enumeratedConcepts",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Concepts`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}Concepts`}Item0`,
            ),
          },
        ],
      },
      ...ConceptStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Concepts`}Item0`),
        variablePrefix: `${`${variablePrefix}Concepts`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Concepts`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(
              `${`${variablePrefix}Concepts`}Rest0`,
            ),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Concepts`),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}ItemN`,
                ),
              },
            ],
          },
          ...ConceptStub.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${`${variablePrefix}Concepts`}ItemN`,
            ),
            variablePrefix: `${`${variablePrefix}Concepts`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Concepts`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
abstract class BaseConceptSchemeConceptSelector extends BaseConceptSelector {
  readonly conceptScheme: ConceptSchemeStub;
  abstract override readonly identifier: rdfjs.NamedNode;
  abstract override readonly type:
    | "ConceptSchemeConceptSelector"
    | "ConceptSchemeTopConceptSelector";

  constructor(
    parameters: {
      readonly conceptScheme: ConceptSchemeStub;
    } & ConstructorParameters<typeof BaseConceptSelector>[0],
  ) {
    super(parameters);
    this.conceptScheme = parameters.conceptScheme;
  }

  override equals(other: BaseConceptSchemeConceptSelector): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ConceptSchemeStub.equals(
          this.conceptScheme,
          other.conceptScheme,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "conceptScheme",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    ConceptSchemeStub.hashConceptSchemeStub(this.conceptScheme, _hasher);
    return _hasher;
  }

  override toJson(): {
    readonly conceptScheme: ReturnType<typeof ConceptSchemeStub.toJson>;
  } & ReturnType<BaseConceptSelector["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        conceptScheme: ConceptSchemeStub.toJson(this.conceptScheme),
      } satisfies ReturnType<BaseConceptSchemeConceptSelector["toJson"]>),
    );
  }

  override toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#conceptScheme",
      ),
      ConceptSchemeStub.toRdf(this.conceptScheme, {
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

namespace BaseConceptSchemeConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { conceptScheme: ConceptSchemeStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      baseConceptSchemeConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const conceptScheme = ConceptSchemeStub.fromJson(
      _jsonObject["conceptScheme"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, conceptScheme, identifier });
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { conceptScheme: ConceptSchemeStub; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const _conceptSchemeEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ConceptSchemeStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#conceptScheme",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        ConceptSchemeStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_conceptSchemeEither.isLeft()) {
      return _conceptSchemeEither;
    }

    const conceptScheme = _conceptSchemeEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, conceptScheme, identifier });
  }

  export function jsonSchema() {
    return zodToJsonSchema(baseConceptSchemeConceptSelectorJsonZodSchema());
  }

  export function baseConceptSchemeConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseConceptSelector.baseConceptSelectorJsonUiSchema({ scopePrefix }),
        ConceptSchemeStub.conceptSchemeStubJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/conceptScheme`,
        }),
      ],
      label: "BaseConceptSchemeConceptSelector",
      type: "Group",
    };
  }

  export function baseConceptSchemeConceptSelectorJsonZodSchema() {
    return BaseConceptSelector.baseConceptSelectorJsonZodSchema().merge(
      zod.object({
        conceptScheme: ConceptSchemeStub.conceptSchemeStubJsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.enum([
          "ConceptSchemeConceptSelector",
          "ConceptSchemeTopConceptSelector",
        ]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BaseConceptSchemeConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BaseConceptSchemeConceptSelector.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BaseConceptSchemeConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseConceptSchemeConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseConceptSchemeConceptSelector");
    return [
      ...BaseConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}ConceptScheme`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#conceptScheme",
        ),
        subject,
      },
      ...ConceptSchemeStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ConceptScheme`),
        variablePrefix: `${variablePrefix}ConceptScheme`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("baseConceptSchemeConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "baseConceptSchemeConceptSelector");
    return [
      ...BaseConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}ConceptScheme`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#conceptScheme",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...ConceptSchemeStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ConceptScheme`),
        variablePrefix: `${variablePrefix}ConceptScheme`,
      }),
    ];
  }
}
export class ConceptSchemeTopConceptSelector extends BaseConceptSchemeConceptSelector {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "ConceptSchemeTopConceptSelector";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseConceptSchemeConceptSelector>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeTopConceptSelector",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ConceptSchemeTopConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSchemeConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      conceptSchemeTopConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      BaseConceptSchemeConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConceptSchemeTopConceptSelector> {
    return ConceptSchemeTopConceptSelector.propertiesFromJson(json).map(
      (properties) => new ConceptSchemeTopConceptSelector(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSchemeConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseConceptSchemeConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeTopConceptSelector",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeTopConceptSelector",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof ConceptSchemeTopConceptSelector.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    ConceptSchemeTopConceptSelector
  > {
    return ConceptSchemeTopConceptSelector.propertiesFromRdf(parameters).map(
      (properties) => new ConceptSchemeTopConceptSelector(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeTopConceptSelector",
  );

  export function jsonSchema() {
    return zodToJsonSchema(conceptSchemeTopConceptSelectorJsonZodSchema());
  }

  export function conceptSchemeTopConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseConceptSchemeConceptSelector.baseConceptSchemeConceptSelectorJsonUiSchema(
          { scopePrefix },
        ),
      ],
      label: "ConceptSchemeTopConceptSelector",
      type: "Group",
    };
  }

  export function conceptSchemeTopConceptSelectorJsonZodSchema() {
    return BaseConceptSchemeConceptSelector.baseConceptSchemeConceptSelectorJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("ConceptSchemeTopConceptSelector"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConceptSchemeTopConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConceptSchemeTopConceptSelector.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConceptSchemeTopConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("conceptSchemeTopConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "conceptSchemeTopConceptSelector");
    return [
      ...BaseConceptSchemeConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("conceptSchemeTopConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "conceptSchemeTopConceptSelector");
    return [
      ...BaseConceptSchemeConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeTopConceptSelector",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class ConceptSchemeConceptSelector extends BaseConceptSchemeConceptSelector {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "ConceptSchemeConceptSelector";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseConceptSchemeConceptSelector>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeConceptSelector",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ConceptSchemeConceptSelector {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSchemeConceptSelector.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      conceptSchemeConceptSelectorJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      BaseConceptSchemeConceptSelector.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConceptSchemeConceptSelector> {
    return ConceptSchemeConceptSelector.propertiesFromJson(json).map(
      (properties) => new ConceptSchemeConceptSelector(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof BaseConceptSchemeConceptSelector.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseConceptSchemeConceptSelector.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeConceptSelector",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeConceptSelector",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<
      typeof ConceptSchemeConceptSelector.propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    ConceptSchemeConceptSelector
  > {
    return ConceptSchemeConceptSelector.propertiesFromRdf(parameters).map(
      (properties) => new ConceptSchemeConceptSelector(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeConceptSelector",
  );

  export function jsonSchema() {
    return zodToJsonSchema(conceptSchemeConceptSelectorJsonZodSchema());
  }

  export function conceptSchemeConceptSelectorJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseConceptSchemeConceptSelector.baseConceptSchemeConceptSelectorJsonUiSchema(
          { scopePrefix },
        ),
      ],
      label: "ConceptSchemeConceptSelector",
      type: "Group",
    };
  }

  export function conceptSchemeConceptSelectorJsonZodSchema() {
    return BaseConceptSchemeConceptSelector.baseConceptSchemeConceptSelectorJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("ConceptSchemeConceptSelector"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConceptSchemeConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConceptSchemeConceptSelector.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConceptSchemeConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("conceptSchemeConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "conceptSchemeConceptSelector");
    return [
      ...BaseConceptSchemeConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ??
      dataFactory.variable!("conceptSchemeConceptSelector");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "conceptSchemeConceptSelector");
    return [
      ...BaseConceptSchemeConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#ConceptSchemeConceptSelector",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
/**
 * prompt message
 */
export class PromptMessage extends InformationContentEntity {
  protected _identifier: rdfjs.NamedNode | undefined;
  /**
   * has literal form
   */
  readonly literalForm: string;
  /**
   * has role
   */
  readonly role: rdfjs.NamedNode<
    | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
    | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
    | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
  >;
  override readonly type: "CompletionMessage" | "PromptMessage" =
    "PromptMessage";

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly literalForm: string;
      readonly role?:
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
        | rdfjs.NamedNode<
            | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
            | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
            | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
          >;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.literalForm = parameters.literalForm;
    if (typeof parameters.role === "undefined") {
      this.role = dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
      );
    } else if (typeof parameters.role === "object") {
      this.role = parameters.role;
    } else if (typeof parameters.role === "string") {
      this.role = dataFactory.namedNode(parameters.role);
    } else {
      this.role = parameters.role as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: PromptMessage): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.literalForm, other.literalForm).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "literalForm",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        booleanEquals(this.role, other.role).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "role",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.literalForm);
    _hasher.update(this.role.termType);
    _hasher.update(this.role.value);
    return _hasher;
  }

  override toJson(): {
    readonly literalForm: string;
    readonly role: {
      readonly "@id":
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System";
    };
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        literalForm: this.literalForm,
        role: { "@id": this.role.value },
      } satisfies ReturnType<PromptMessage["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptMessage",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#literalForm",
      ),
      this.literalForm,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
      ),
      !this.role.equals(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
        ),
      )
        ? this.role
        : undefined,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace PromptMessage {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      identifier: rdfjs.NamedNode;
      literalForm: string;
      role: rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
      >;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = promptMessageJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const literalForm = _jsonObject["literalForm"];
    const role = dataFactory.namedNode(_jsonObject["role"]["@id"]);
    return purify.Either.of({ ..._super0, identifier, literalForm, role });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptMessage> {
    return PromptMessage.propertiesFromJson(json).map(
      (properties) => new PromptMessage(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      identifier: rdfjs.NamedNode;
      literalForm: string;
      role: rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
      >;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#PromptMessage",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#PromptMessage",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _literalFormEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      string
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toString());
    if (_literalFormEither.isLeft()) {
      return _literalFormEither;
    }

    const literalForm = _literalFormEither.unsafeCoerce();
    const _roleEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode<
        | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
        | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
      >
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
            ),
            object: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
            ),
          }),
        ),
      )
      .chain((_value) =>
        _value.toIri().chain((iri) => {
          switch (iri.value) {
            case "http://purl.archive.org/purl/knextract/cbox#_Role_AI":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_AI">,
              );
            case "http://purl.archive.org/purl/knextract/cbox#_Role_Human":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_Human">,
              );
            case "http://purl.archive.org/purl/knextract/cbox#_Role_System":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_AI"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_Human"
                  | "http://purl.archive.org/purl/knextract/cbox#_Role_System"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_System">,
              );
            default:
              return purify.Left(
                new rdfjsResource.Resource.MistypedValueError({
                  actualValue: iri,
                  expectedValueType:
                    'rdfjs.NamedNode<"http://purl.archive.org/purl/knextract/cbox#_Role_AI" | "http://purl.archive.org/purl/knextract/cbox#_Role_Human" | "http://purl.archive.org/purl/knextract/cbox#_Role_System">',
                  focusResource: _resource,
                  predicate: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
                  ),
                }),
              );
          }
        }),
      );
    if (_roleEither.isLeft()) {
      return _roleEither;
    }

    const role = _roleEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, literalForm, role });
  }

  export function fromRdf(
    parameters: Parameters<typeof PromptMessage.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PromptMessage> {
    return PromptMessage.propertiesFromRdf(parameters).map(
      (properties) => new PromptMessage(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#PromptMessage",
  );

  export function jsonSchema() {
    return zodToJsonSchema(promptMessageJsonZodSchema());
  }

  export function promptMessageJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        {
          label: "has literal form",
          scope: `${scopePrefix}/properties/literalForm`,
          type: "Control",
        },
        {
          label: "has role",
          scope: `${scopePrefix}/properties/role`,
          type: "Control",
        },
      ],
      label: "prompt message",
      type: "Group",
    };
  }

  export function promptMessageJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        literalForm: zod.string(),
        role: zod.object({
          "@id": zod.enum([
            "http://purl.archive.org/purl/knextract/cbox#_Role_AI",
            "http://purl.archive.org/purl/knextract/cbox#_Role_Human",
            "http://purl.archive.org/purl/knextract/cbox#_Role_System",
          ]),
        }),
        type: zod.enum(["CompletionMessage", "PromptMessage"]),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptMessage.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptMessage.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptMessage.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptMessage");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "promptMessage");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#literalForm",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Role`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("promptMessage");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "promptMessage");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#PromptMessage",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}LiteralForm`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#literalForm",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Role`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#promptMessageRole",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class CompletionMessage extends PromptMessage {
  override readonly type = "CompletionMessage";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof PromptMessage>[0],
  ) {
    super(parameters);
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CompletionMessage",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace CompletionMessage {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof PromptMessage.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      completionMessageJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = PromptMessage.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CompletionMessage> {
    return CompletionMessage.propertiesFromJson(json).map(
      (properties) => new CompletionMessage(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof PromptMessage.propertiesFromRdf>
    >
  > {
    const _super0Either = PromptMessage.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CompletionMessage",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#CompletionMessage",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof CompletionMessage.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CompletionMessage> {
    return CompletionMessage.propertiesFromRdf(parameters).map(
      (properties) => new CompletionMessage(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#CompletionMessage",
  );

  export function jsonSchema() {
    return zodToJsonSchema(completionMessageJsonZodSchema());
  }

  export function completionMessageJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [PromptMessage.promptMessageJsonUiSchema({ scopePrefix })],
      label: "CompletionMessage",
      type: "Group",
    };
  }

  export function completionMessageJsonZodSchema() {
    return PromptMessage.promptMessageJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("CompletionMessage"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CompletionMessage.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CompletionMessage.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CompletionMessage.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("completionMessage");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "completionMessage");
    return [
      ...PromptMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("completionMessage");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "completionMessage");
    return [
      ...PromptMessage.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#CompletionMessage",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }
}
export class ClaimProperty {
  readonly comments: readonly rdfjs.Literal[];
  readonly identifier: rdfjs.NamedNode;
  readonly labels: readonly rdfjs.Literal[];
  readonly type = "ClaimProperty";

  constructor(parameters: {
    readonly comments?: readonly rdfjs.Literal[];
    readonly identifier: rdfjs.NamedNode | string;
    readonly labels?: readonly rdfjs.Literal[];
  }) {
    if (typeof parameters.comments === "undefined") {
      this.comments = [];
    } else if (Array.isArray(parameters.comments)) {
      this.comments = parameters.comments;
    } else {
      this.comments = parameters.comments as never;
    }

    if (typeof parameters.identifier === "object") {
      this.identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this.identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this.identifier = parameters.identifier as never;
    }

    if (typeof parameters.labels === "undefined") {
      this.labels = [];
    } else if (Array.isArray(parameters.labels)) {
      this.labels = parameters.labels;
    } else {
      this.labels = parameters.labels as never;
    }
  }

  equals(other: ClaimProperty): EqualsResult {
    return ((left, right) => arrayEquals(left, right, booleanEquals))(
      this.comments,
      other.comments,
    )
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "comments",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        booleanEquals(this.identifier, other.identifier).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "identifier",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => arrayEquals(left, right, booleanEquals))(
          this.labels,
          other.labels,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "labels",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        strictEquals(this.type, other.type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    for (const _item0 of this.comments) {
      _hasher.update(_item0.datatype.value);
      _hasher.update(_item0.language);
      _hasher.update(_item0.termType);
      _hasher.update(_item0.value);
    }

    for (const _item0 of this.labels) {
      _hasher.update(_item0.datatype.value);
      _hasher.update(_item0.language);
      _hasher.update(_item0.termType);
      _hasher.update(_item0.value);
    }

    return _hasher;
  }

  toJson(): {
    readonly comments: readonly {
      readonly "@language": string | undefined;
      readonly "@type": string | undefined;
      readonly "@value": string;
    }[];
    readonly "@id": string;
    readonly labels: readonly {
      readonly "@language": string | undefined;
      readonly "@type": string | undefined;
      readonly "@value": string;
    }[];
    readonly type: "ClaimProperty";
  } {
    return JSON.parse(
      JSON.stringify({
        comments: this.comments.map((_item) => ({
          "@language": _item.language.length > 0 ? _item.language : undefined,
          "@type":
            _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
              ? _item.datatype.value
              : undefined,
          "@value": _item.value,
        })),
        "@id": this.identifier.value,
        labels: this.labels.map((_item) => ({
          "@language": _item.language.length > 0 ? _item.language : undefined,
          "@type":
            _item.datatype.value !== "http://www.w3.org/2001/XMLSchema#string"
              ? _item.datatype.value
              : undefined,
          "@value": _item.value,
        })),
        type: this.type,
      } satisfies ReturnType<ClaimProperty["toJson"]>),
    );
  }

  toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = resourceSet.mutableNamedResource({
      identifier: this.identifier,
      mutateGraph,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#comment"),
      this.comments.map((_item) => _item),
    );
    _resource.add(
      dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
      this.labels.map((_item) => _item),
    );
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace ClaimProperty {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      comments: readonly rdfjs.Literal[];
      identifier: rdfjs.NamedNode;
      labels: readonly rdfjs.Literal[];
    }
  > {
    const _jsonSafeParseResult = jsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const comments = _jsonObject["comments"].map((_item) =>
      dataFactory.literal(
        _item["@value"],
        typeof _item["@language"] !== "undefined"
          ? _item["@language"]
          : typeof _item["@type"] !== "undefined"
            ? dataFactory.namedNode(_item["@type"])
            : undefined,
      ),
    );
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const labels = _jsonObject["labels"].map((_item) =>
      dataFactory.literal(
        _item["@value"],
        typeof _item["@language"] !== "undefined"
          ? _item["@language"]
          : typeof _item["@type"] !== "undefined"
            ? dataFactory.namedNode(_item["@type"])
            : undefined,
      ),
    );
    return purify.Either.of({ comments, identifier, labels });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ClaimProperty> {
    return ClaimProperty.propertiesFromJson(json).map(
      (properties) => new ClaimProperty(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      comments: readonly rdfjs.Literal[];
      identifier: rdfjs.NamedNode;
      labels: readonly rdfjs.Literal[];
    }
  > {
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
          ),
        }),
      );
    }

    const _commentsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly rdfjs.Literal[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#comment"),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .filter((_value) => {
              const _languageInOrDefault = _languageIn ?? [];
              if (_languageInOrDefault.length === 0) {
                return true;
              }
              const _valueLiteral = _value.toLiteral().toMaybe().extract();
              if (typeof _valueLiteral === "undefined") {
                return false;
              }
              return _languageInOrDefault.some(
                (_languageIn) => _languageIn === _valueLiteral.language,
              );
            })
            .head()
            .chain((_value) => _value.toLiteral())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_commentsEither.isLeft()) {
      return _commentsEither;
    }

    const comments = _commentsEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _labelsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly rdfjs.Literal[]
    > = purify.Either.of([
      ..._resource
        .values(
          dataFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label"),
          { unique: true },
        )
        .flatMap((_item) =>
          _item
            .toValues()
            .filter((_value) => {
              const _languageInOrDefault = _languageIn ?? [];
              if (_languageInOrDefault.length === 0) {
                return true;
              }
              const _valueLiteral = _value.toLiteral().toMaybe().extract();
              if (typeof _valueLiteral === "undefined") {
                return false;
              }
              return _languageInOrDefault.some(
                (_languageIn) => _languageIn === _valueLiteral.language,
              );
            })
            .head()
            .chain((_value) => _value.toLiteral())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_labelsEither.isLeft()) {
      return _labelsEither;
    }

    const labels = _labelsEither.unsafeCoerce();
    return purify.Either.of({ comments, identifier, labels });
  }

  export function fromRdf(
    parameters: Parameters<typeof ClaimProperty.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ClaimProperty> {
    return ClaimProperty.propertiesFromRdf(parameters).map(
      (properties) => new ClaimProperty(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
  );

  export function jsonSchema() {
    return zodToJsonSchema(jsonZodSchema());
  }

  export function jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        { scope: `${scopePrefix}/properties/comments`, type: "Control" },
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/labels`, type: "Control" },
        {
          rule: {
            condition: {
              schema: { const: "ClaimProperty" },
              scope: `${scopePrefix}/properties/type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/type`,
          type: "Control",
        },
      ],
      label: "ClaimProperty",
      type: "Group",
    };
  }

  export function jsonZodSchema() {
    return zod.object({
      comments: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array(),
      "@id": zod.string().min(1),
      labels: zod
        .object({
          "@language": zod.string().optional(),
          "@type": zod.string().optional(),
          "@value": zod.string(),
        })
        .array(),
      type: zod.literal("ClaimProperty"),
    });
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ClaimProperty.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ClaimProperty.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ClaimProperty.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("claimProperty");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "claimProperty");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Comments`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#comment",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Labels`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/2000/01/rdf-schema#label",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("claimProperty");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "claimProperty");
    return [
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Comments`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2000/01/rdf-schema#comment",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Labels`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/2000/01/rdf-schema#label",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
  }
}
export class Claim extends InformationContentEntity {
  readonly gold: boolean;
  private _identifier: rdfjs.NamedNode | undefined;
  readonly object: Value;
  readonly predicate: rdfjs.NamedNode;
  readonly subject: rdfjs.NamedNode;
  override readonly type = "Claim";

  constructor(
    parameters: {
      readonly gold?: boolean;
      readonly identifier?: rdfjs.NamedNode | string;
      readonly object: Value;
      readonly predicate: rdfjs.NamedNode | string;
      readonly subject: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    if (typeof parameters.gold === "boolean") {
      this.gold = parameters.gold;
    } else if (typeof parameters.gold === "undefined") {
      this.gold = false;
    } else {
      this.gold = parameters.gold as never;
    }

    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.object = parameters.object;
    if (typeof parameters.predicate === "object") {
      this.predicate = parameters.predicate;
    } else if (typeof parameters.predicate === "string") {
      this.predicate = dataFactory.namedNode(parameters.predicate);
    } else {
      this.predicate = parameters.predicate as never;
    }

    if (typeof parameters.subject === "object") {
      this.subject = parameters.subject;
    } else if (typeof parameters.subject === "string") {
      this.subject = dataFactory.namedNode(parameters.subject);
    } else {
      this.subject = parameters.subject as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Claim): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.gold, other.gold).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "gold",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        Value.equals(this.object, other.object).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "object",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        booleanEquals(this.predicate, other.predicate).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "predicate",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        booleanEquals(this.subject, other.subject).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "subject",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.gold.toString());
    this.object.hash(_hasher);
    _hasher.update(this.predicate.termType);
    _hasher.update(this.predicate.value);
    _hasher.update(this.subject.termType);
    _hasher.update(this.subject.value);
    return _hasher;
  }

  override toJson(): {
    readonly gold: boolean;
    readonly object:
      | ReturnType<BooleanValue["toJson"]>
      | ReturnType<CategoricalValue["toJson"]>
      | ReturnType<RealValue["toJson"]>
      | ReturnType<TextValue["toJson"]>;
    readonly predicate: { readonly "@id": string };
    readonly subject: { readonly "@id": string };
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        gold: this.gold,
        object: this.object.toJson(),
        predicate: { "@id": this.predicate.value },
        subject: { "@id": this.subject.value },
      } satisfies ReturnType<Claim["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement",
        ),
      );
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Claim",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#gold",
      ),
      this.gold ? true : undefined,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
      ),
      this.object.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      dataFactory.namedNode(
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
      ),
      this.predicate,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
      ),
      this.subject,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Claim {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      gold: boolean;
      identifier: rdfjs.NamedNode;
      object: Value;
      predicate: rdfjs.NamedNode;
      subject: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromJson>>
  > {
    const _jsonSafeParseResult = claimJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const gold = _jsonObject["gold"];
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const object = Value.fromJson(_jsonObject["object"]).unsafeCoerce();
    const predicate = dataFactory.namedNode(_jsonObject["predicate"]["@id"]);
    const subject = dataFactory.namedNode(_jsonObject["subject"]["@id"]);
    return purify.Either.of({
      ..._super0,
      gold,
      identifier,
      object,
      predicate,
      subject,
    });
  }

  export function fromJson(json: unknown): purify.Either<zod.ZodError, Claim> {
    return Claim.propertiesFromJson(json).map(
      (properties) => new Claim(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      gold: boolean;
      identifier: rdfjs.NamedNode;
      object: Value;
      predicate: rdfjs.NamedNode;
      subject: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof InformationContentEntity.propertiesFromRdf>>
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Claim",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Claim",
          ),
        }),
      );
    }

    const _goldEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#gold",
        ),
        { unique: true },
      )
      .head()
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#gold",
            ),
            object: dataFactory.literal(
              "false",
              dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
            ),
          }),
        ),
      )
      .chain((_value) => _value.toBoolean());
    if (_goldEither.isLeft()) {
      return _goldEither;
    }

    const gold = _goldEither.unsafeCoerce();
    const identifier = _resource.identifier;
    const _objectEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      Value
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        Value.fromRdf({ ..._context, resource: _resource }),
      );
    if (_objectEither.isLeft()) {
      return _objectEither;
    }

    const object = _objectEither.unsafeCoerce();
    const _predicateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toIri());
    if (_predicateEither.isLeft()) {
      return _predicateEither;
    }

    const predicate = _predicateEither.unsafeCoerce();
    const _subjectEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toIri());
    if (_subjectEither.isLeft()) {
      return _subjectEither;
    }

    const subject = _subjectEither.unsafeCoerce();
    return purify.Either.of({
      ..._super0,
      gold,
      identifier,
      object,
      predicate,
      subject,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof Claim.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Claim> {
    return Claim.propertiesFromRdf(parameters).map(
      (properties) => new Claim(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Claim",
  );

  export function jsonSchema() {
    return zodToJsonSchema(claimJsonZodSchema());
  }

  export function claimJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        { scope: `${scopePrefix}/properties/gold`, type: "Control" },
        { scope: `${scopePrefix}/properties/object`, type: "Control" },
        { scope: `${scopePrefix}/properties/predicate`, type: "Control" },
        { scope: `${scopePrefix}/properties/subject`, type: "Control" },
      ],
      label: "Claim",
      type: "Group",
    };
  }

  export function claimJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        gold: zod.boolean(),
        "@id": zod.string().min(1),
        object: Value.jsonZodSchema(),
        predicate: zod.object({ "@id": zod.string().min(1) }),
        subject: zod.object({ "@id": zod.string().min(1) }),
        type: zod.literal("Claim"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Claim.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Claim.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Claim.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("claim");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "claim");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Gold`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#gold",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Object`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
        ),
        subject,
      },
      ...Value.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Object`),
        variablePrefix: `${variablePrefix}Object`,
      }),
      {
        object: dataFactory.variable!(`${variablePrefix}Predicate`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
        ),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}Subject`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("claim");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "claim");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Claim",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Gold`),
                predicate: dataFactory.namedNode(
                  "http://purl.archive.org/purl/knextract/ontology#gold",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Object`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...Value.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Object`),
        variablePrefix: `${variablePrefix}Object`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Predicate`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Subject`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export class CategoricalValue extends BaseValue {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "CategoricalValue";
  readonly value: ConceptStub;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly value: ConceptStub;
    } & ConstructorParameters<typeof BaseValue>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.value = parameters.value;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: CategoricalValue): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ConceptStub.equals(this.value, other.value).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "value",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    ConceptStub.hashConceptStub(this.value, _hasher);
    return _hasher;
  }

  override toJson(): {
    readonly value: ReturnType<typeof ConceptStub.toJson>;
  } & ReturnType<BaseValue["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        value: ConceptStub.toJson(this.value),
      } satisfies ReturnType<CategoricalValue["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CategoricalValue",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#value"),
      ConceptStub.toRdf(this.value, {
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace CategoricalValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; value: ConceptStub } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      categoricalValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseValue.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const value = ConceptStub.fromJson(_jsonObject["value"]).unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CategoricalValue> {
    return CategoricalValue.propertiesFromJson(json).map(
      (properties) => new CategoricalValue(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; value: ConceptStub } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseValue.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CategoricalValue",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#CategoricalValue",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ConceptStub
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        ConceptStub.fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromRdf(
    parameters: Parameters<typeof CategoricalValue.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CategoricalValue> {
    return CategoricalValue.propertiesFromRdf(parameters).map(
      (properties) => new CategoricalValue(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#CategoricalValue",
  );

  export function jsonSchema() {
    return zodToJsonSchema(categoricalValueJsonZodSchema());
  }

  export function categoricalValueJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseValue.baseValueJsonUiSchema({ scopePrefix }),
        ConceptStub.conceptStubJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/value`,
        }),
      ],
      label: "CategoricalValue",
      type: "Group",
    };
  }

  export function categoricalValueJsonZodSchema() {
    return BaseValue.baseValueJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("CategoricalValue"),
        value: ConceptStub.conceptStubJsonZodSchema(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CategoricalValue.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CategoricalValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CategoricalValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("categoricalValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "categoricalValue");
    return [
      ...BaseValue.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Value`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        subject,
      },
      ...ConceptStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Value`),
        variablePrefix: `${variablePrefix}Value`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("categoricalValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "categoricalValue");
    return [
      ...BaseValue.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#CategoricalValue",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Value`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...ConceptStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Value`),
        variablePrefix: `${variablePrefix}Value`,
      }),
    ];
  }
}
export class CategoricalQuestion extends BaseQuestion {
  readonly class_: rdfjs.NamedNode;
  readonly conceptSelector: ConceptSelector;
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "CategoricalQuestion";

  constructor(
    parameters: {
      readonly class_?: rdfjs.NamedNode | string;
      readonly conceptSelector: ConceptSelector;
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof BaseQuestion>[0],
  ) {
    super(parameters);
    if (typeof parameters.class_ === "undefined") {
      this.class_ = dataFactory.namedNode(
        "http://www.w3.org/2004/02/skos/core#Concept",
      );
    } else if (typeof parameters.class_ === "object") {
      this.class_ = parameters.class_;
    } else if (typeof parameters.class_ === "string") {
      this.class_ = dataFactory.namedNode(parameters.class_);
    } else {
      this.class_ = parameters.class_ as never;
    }

    this.conceptSelector = parameters.conceptSelector;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: CategoricalQuestion): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        booleanEquals(this.class_, other.class_).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "class_",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ConceptSelector.equals(
          this.conceptSelector,
          other.conceptSelector,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "conceptSelector",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.class_.termType);
    _hasher.update(this.class_.value);
    this.conceptSelector.hash(_hasher);
    return _hasher;
  }

  override toJson(): {
    readonly class_: { readonly "@id": string };
    readonly conceptSelector:
      | ReturnType<ConceptSchemeConceptSelector["toJson"]>
      | ReturnType<ConceptSchemeTopConceptSelector["toJson"]>
      | ReturnType<EnumeratedConceptSelector["toJson"]>
      | ReturnType<NarrowerConceptSelector["toJson"]>
      | ReturnType<NarrowerTransitiveConceptSelector["toJson"]>;
  } & ReturnType<BaseQuestion["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        class_: { "@id": this.class_.value },
        conceptSelector: this.conceptSelector.toJson(),
      } satisfies ReturnType<CategoricalQuestion["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CategoricalQuestion",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/ns/shacl#class"),
      !this.class_.equals(
        dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#Concept"),
      )
        ? this.class_
        : undefined,
    );
    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#conceptSelector",
      ),
      this.conceptSelector.toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace CategoricalQuestion {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      class_: rdfjs.NamedNode;
      conceptSelector: ConceptSelector;
      identifier: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof BaseQuestion.propertiesFromJson>>
  > {
    const _jsonSafeParseResult =
      categoricalQuestionJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseQuestion.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const class_ = dataFactory.namedNode(_jsonObject["class_"]["@id"]);
    const conceptSelector = ConceptSelector.fromJson(
      _jsonObject["conceptSelector"],
    ).unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({
      ..._super0,
      class_,
      conceptSelector,
      identifier,
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CategoricalQuestion> {
    return CategoricalQuestion.propertiesFromJson(json).map(
      (properties) => new CategoricalQuestion(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      class_: rdfjs.NamedNode;
      conceptSelector: ConceptSelector;
      identifier: rdfjs.NamedNode;
    } & UnwrapR<ReturnType<typeof BaseQuestion.propertiesFromRdf>>
  > {
    const _super0Either = BaseQuestion.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#CategoricalQuestion",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#CategoricalQuestion",
          ),
        }),
      );
    }

    const _class_Either: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode
    > = _resource
      .values(dataFactory.namedNode("http://www.w3.org/ns/shacl#class"), {
        unique: true,
      })
      .find((_value) =>
        _value
          .toTerm()
          .equals(
            dataFactory.namedNode(
              "http://www.w3.org/2004/02/skos/core#Concept",
            ),
          ),
      )
      .alt(
        purify.Either.of(
          new rdfjsResource.Resource.Value({
            subject: _resource,
            predicate: dataFactory.namedNode(
              "http://www.w3.org/ns/shacl#class",
            ),
            object: dataFactory.namedNode(
              "http://www.w3.org/2004/02/skos/core#Concept",
            ),
          }),
        ),
      )
      .chain((_value) => _value.toIri());
    if (_class_Either.isLeft()) {
      return _class_Either;
    }

    const class_ = _class_Either.unsafeCoerce();
    const _conceptSelectorEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ConceptSelector
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#conceptSelector",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toNamedResource())
      .chain((_resource) =>
        ConceptSelector.fromRdf({ ..._context, resource: _resource }),
      );
    if (_conceptSelectorEither.isLeft()) {
      return _conceptSelectorEither;
    }

    const conceptSelector = _conceptSelectorEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({
      ..._super0,
      class_,
      conceptSelector,
      identifier,
    });
  }

  export function fromRdf(
    parameters: Parameters<typeof CategoricalQuestion.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CategoricalQuestion> {
    return CategoricalQuestion.propertiesFromRdf(parameters).map(
      (properties) => new CategoricalQuestion(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#CategoricalQuestion",
  );

  export function jsonSchema() {
    return zodToJsonSchema(categoricalQuestionJsonZodSchema());
  }

  export function categoricalQuestionJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseQuestion.baseQuestionJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/class_`, type: "Control" },
        { scope: `${scopePrefix}/properties/conceptSelector`, type: "Control" },
      ],
      label: "CategoricalQuestion",
      type: "Group",
    };
  }

  export function categoricalQuestionJsonZodSchema() {
    return BaseQuestion.baseQuestionJsonZodSchema().merge(
      zod.object({
        class_: zod.object({ "@id": zod.string().min(1) }),
        conceptSelector: ConceptSelector.jsonZodSchema(),
        "@id": zod.string().min(1),
        type: zod.literal("CategoricalQuestion"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CategoricalQuestion.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CategoricalQuestion.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CategoricalQuestion.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("categoricalQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "categoricalQuestion");
    return [
      ...BaseQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Class`),
        predicate: dataFactory.namedNode("http://www.w3.org/ns/shacl#class"),
        subject,
      },
      {
        object: dataFactory.variable!(`${variablePrefix}ConceptSelector`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#conceptSelector",
        ),
        subject,
      },
      ...ConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ConceptSelector`),
        variablePrefix: `${variablePrefix}ConceptSelector`,
      }),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("categoricalQuestion");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "categoricalQuestion");
    return [
      ...BaseQuestion.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#CategoricalQuestion",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Class`),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/ns/shacl#class",
                ),
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}ConceptSelector`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#conceptSelector",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      ...ConceptSelector.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ConceptSelector`),
        variablePrefix: `${variablePrefix}ConceptSelector`,
      }),
    ];
  }
}
export class BooleanValue extends BaseValue {
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "BooleanValue";
  readonly value: boolean;

  constructor(
    parameters: {
      readonly identifier?: rdfjs.NamedNode | string;
      readonly value: boolean;
    } & ConstructorParameters<typeof BaseValue>[0],
  ) {
    super(parameters);
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }

    this.value = parameters.value;
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: BooleanValue): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        strictEquals(this.value, other.value).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "value",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    _hasher.update(this.value.toString());
    return _hasher;
  }

  override toJson(): { readonly value: boolean } & ReturnType<
    BaseValue["toJson"]
  > {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        value: this.value,
      } satisfies ReturnType<BooleanValue["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#BooleanValue",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#value"),
      this.value,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace BooleanValue {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; value: boolean } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = booleanValueJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = BaseValue.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const value = _jsonObject["value"];
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BooleanValue> {
    return BooleanValue.propertiesFromJson(json).map(
      (properties) => new BooleanValue(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; value: boolean } & UnwrapR<
      ReturnType<typeof BaseValue.propertiesFromRdf>
    >
  > {
    const _super0Either = BaseValue.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#BooleanValue",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#BooleanValue",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      boolean
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        { unique: true },
      )
      .head()
      .chain((_value) => _value.toBoolean());
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ..._super0, identifier, value });
  }

  export function fromRdf(
    parameters: Parameters<typeof BooleanValue.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, BooleanValue> {
    return BooleanValue.propertiesFromRdf(parameters).map(
      (properties) => new BooleanValue(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#BooleanValue",
  );

  export function jsonSchema() {
    return zodToJsonSchema(booleanValueJsonZodSchema());
  }

  export function booleanValueJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        BaseValue.baseValueJsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "BooleanValue",
      type: "Group",
    };
  }

  export function booleanValueJsonZodSchema() {
    return BaseValue.baseValueJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("BooleanValue"),
        value: zod.boolean(),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BooleanValue.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BooleanValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BooleanValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("booleanValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "booleanValue");
    return [
      ...BaseValue.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Value`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
        ),
        subject,
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("booleanValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "booleanValue");
    return [
      ...BaseValue.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#BooleanValue",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Value`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#value",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
    ];
  }
}
export interface ConceptStub extends KosResourceStub {
  readonly identifier: rdfjs.NamedNode;
  readonly type: "ConceptStub";
}

export namespace ConceptStub {
  export function create(
    parameters: { readonly identifier: rdfjs.NamedNode | string } & Parameters<
      typeof KosResourceStub.create
    >[0],
  ): ConceptStub {
    let identifier: rdfjs.NamedNode;
    if (typeof parameters.identifier === "object") {
      identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      identifier = parameters.identifier as never;
    }

    const type = "ConceptStub" as const;
    return { ...KosResourceStub.create(parameters), identifier, type };
  }

  export function equals(left: ConceptStub, right: ConceptStub): EqualsResult {
    return KosResourceStub.equals(left, right);
  }

  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; type: "ConceptStub" } & UnwrapR<
      ReturnType<typeof KosResourceStub.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = conceptStubJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = KosResourceStub.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const type = "ConceptStub" as const;
    return purify.Either.of({ ..._super0, identifier, type });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConceptStub> {
    return ConceptStub.propertiesFromJson(json);
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; type: "ConceptStub" } & UnwrapR<
      ReturnType<typeof KosResourceStub.propertiesFromRdf>
    >
  > {
    const _super0Either = KosResourceStub.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode("http://www.w3.org/2004/02/skos/core#Concept"),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://www.w3.org/2004/02/skos/core#Concept",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const type = "ConceptStub" as const;
    return purify.Either.of({ ..._super0, identifier, type });
  }

  export function fromRdf(
    parameters: Parameters<typeof ConceptStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ConceptStub> {
    return ConceptStub.propertiesFromRdf(parameters);
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://www.w3.org/2004/02/skos/core#Concept",
  );

  export function jsonSchema() {
    return zodToJsonSchema(conceptStubJsonZodSchema());
  }

  export function conceptStubJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [KosResourceStub.kosResourceStubJsonUiSchema({ scopePrefix })],
      label: "ConceptStub",
      type: "Group",
    };
  }

  export function conceptStubJsonZodSchema() {
    return KosResourceStub.kosResourceStubJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("ConceptStub"),
      }),
    );
  }

  export function hashConceptStub<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_conceptStub: ConceptStub, _hasher: HasherT): HasherT {
    KosResourceStub.hashKosResourceStub(_conceptStub, _hasher);
    return _hasher;
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConceptStub.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConceptStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConceptStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("conceptStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "conceptStub");
    return [
      ...KosResourceStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("conceptStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "conceptStub");
    return [
      ...KosResourceStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://www.w3.org/2004/02/skos/core#Concept",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }

  export function toJson(
    _conceptStub: ConceptStub,
  ): ReturnType<typeof KosResourceStub.toJson> {
    return JSON.parse(
      JSON.stringify({
        ...KosResourceStub.toJson(_conceptStub),
      } satisfies ReturnType<typeof ConceptStub.toJson>),
    );
  }

  export function toRdf(
    _conceptStub: ConceptStub,
    {
      ignoreRdfType,
      mutateGraph,
      resourceSet,
    }: {
      ignoreRdfType?: boolean;
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = KosResourceStub.toRdf(_conceptStub, {
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://www.w3.org/2004/02/skos/core#Concept",
        ),
      );
    }

    return _resource;
  }
}
export interface ConceptSchemeStub extends KosResourceStub {
  readonly identifier: rdfjs.NamedNode;
  readonly type: "ConceptSchemeStub";
}

export namespace ConceptSchemeStub {
  export function create(
    parameters: { readonly identifier: rdfjs.NamedNode | string } & Parameters<
      typeof KosResourceStub.create
    >[0],
  ): ConceptSchemeStub {
    let identifier: rdfjs.NamedNode;
    if (typeof parameters.identifier === "object") {
      identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      identifier = parameters.identifier as never;
    }

    const type = "ConceptSchemeStub" as const;
    return { ...KosResourceStub.create(parameters), identifier, type };
  }

  export function equals(
    left: ConceptSchemeStub,
    right: ConceptSchemeStub,
  ): EqualsResult {
    return KosResourceStub.equals(left, right);
  }

  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { identifier: rdfjs.NamedNode; type: "ConceptSchemeStub" } & UnwrapR<
      ReturnType<typeof KosResourceStub.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult =
      conceptSchemeStubJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either = KosResourceStub.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    const type = "ConceptSchemeStub" as const;
    return purify.Either.of({ ..._super0, identifier, type });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConceptSchemeStub> {
    return ConceptSchemeStub.propertiesFromJson(json);
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { identifier: rdfjs.NamedNode; type: "ConceptSchemeStub" } & UnwrapR<
      ReturnType<typeof KosResourceStub.propertiesFromRdf>
    >
  > {
    const _super0Either = KosResourceStub.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://www.w3.org/2004/02/skos/core#ConceptScheme",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://www.w3.org/2004/02/skos/core#ConceptScheme",
          ),
        }),
      );
    }

    const identifier = _resource.identifier;
    const type = "ConceptSchemeStub" as const;
    return purify.Either.of({ ..._super0, identifier, type });
  }

  export function fromRdf(
    parameters: Parameters<typeof ConceptSchemeStub.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ConceptSchemeStub> {
    return ConceptSchemeStub.propertiesFromRdf(parameters);
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://www.w3.org/2004/02/skos/core#ConceptScheme",
  );

  export function jsonSchema() {
    return zodToJsonSchema(conceptSchemeStubJsonZodSchema());
  }

  export function conceptSchemeStubJsonUiSchema(parameters?: {
    scopePrefix?: string;
  }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [KosResourceStub.kosResourceStubJsonUiSchema({ scopePrefix })],
      label: "ConceptSchemeStub",
      type: "Group",
    };
  }

  export function conceptSchemeStubJsonZodSchema() {
    return KosResourceStub.kosResourceStubJsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        type: zod.literal("ConceptSchemeStub"),
      }),
    );
  }

  export function hashConceptSchemeStub<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_conceptSchemeStub: ConceptSchemeStub, _hasher: HasherT): HasherT {
    KosResourceStub.hashKosResourceStub(_conceptSchemeStub, _hasher);
    return _hasher;
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConceptSchemeStub.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConceptSchemeStub.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConceptSchemeStub.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("conceptSchemeStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "conceptSchemeStub");
    return [
      ...KosResourceStub.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("conceptSchemeStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "conceptSchemeStub");
    return [
      ...KosResourceStub.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://www.w3.org/2004/02/skos/core#ConceptScheme",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
    ];
  }

  export function toJson(
    _conceptSchemeStub: ConceptSchemeStub,
  ): ReturnType<typeof KosResourceStub.toJson> {
    return JSON.parse(
      JSON.stringify({
        ...KosResourceStub.toJson(_conceptSchemeStub),
      } satisfies ReturnType<typeof ConceptSchemeStub.toJson>),
    );
  }

  export function toRdf(
    _conceptSchemeStub: ConceptSchemeStub,
    {
      ignoreRdfType,
      mutateGraph,
      resourceSet,
    }: {
      ignoreRdfType?: boolean;
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = KosResourceStub.toRdf(_conceptSchemeStub, {
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://www.w3.org/2004/02/skos/core#ConceptScheme",
        ),
      );
    }

    return _resource;
  }
}
export class Answer extends InformationContentEntity {
  readonly claims: readonly Claim[];
  private _identifier: rdfjs.NamedNode | undefined;
  override readonly type = "Answer";

  constructor(
    parameters: {
      readonly claims: readonly Claim[];
      readonly identifier?: rdfjs.NamedNode | string;
    } & ConstructorParameters<typeof InformationContentEntity>[0],
  ) {
    super(parameters);
    this.claims = parameters.claims;
    if (typeof parameters.identifier === "object") {
      this._identifier = parameters.identifier;
    } else if (typeof parameters.identifier === "string") {
      this._identifier = dataFactory.namedNode(parameters.identifier);
    } else {
      this._identifier = parameters.identifier as never;
    }
  }

  override get identifier(): rdfjs.NamedNode {
    if (typeof this._identifier === "undefined") {
      this._identifier = dataFactory.namedNode(
        `urn:shaclmate:object:${this.type}:${this.hash(sha256.create())}`,
      );
    }
    return this._identifier;
  }

  override equals(other: Answer): EqualsResult {
    return super
      .equals(other)
      .chain(() =>
        ((left, right) =>
          arrayEquals(left, right, (left, right) => left.equals(right)))(
          this.claims,
          other.claims,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "claims",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.hash(_hasher);
    for (const _element0 of this.claims) {
      _element0.hash(_hasher);
    }

    return _hasher;
  }

  override toJson(): {
    readonly claims: readonly ReturnType<Claim["toJson"]>[];
  } & ReturnType<InformationContentEntity["toJson"]> {
    return JSON.parse(
      JSON.stringify({
        ...super.toJson(),
        claims: this.claims.map((_item) => _item.toJson()),
      } satisfies ReturnType<Answer["toJson"]>),
    );
  }

  override toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    const _resource = super.toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        _resource.dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        ),
        _resource.dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Answer",
        ),
      );
    }

    _resource.add(
      dataFactory.namedNode(
        "http://purl.archive.org/purl/knextract/ontology#claims",
      ),
      this.claims.reduce(
        ({ currentSubListResource, listResource }, item, itemIndex, list) => {
          if (itemIndex === 0) {
            currentSubListResource = listResource;
          } else {
            const newSubListResource = resourceSet.mutableNamedResource({
              identifier: dataFactory.namedNode(
                `${listResource.identifier.value}:${itemIndex}`,
              ),
              mutateGraph,
            });
            currentSubListResource!.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              newSubListResource.identifier,
            );
            currentSubListResource = newSubListResource;
          }

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
            ),
            dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#ClaimList",
            ),
          );

          currentSubListResource.add(
            dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            item.toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
          );

          if (itemIndex + 1 === list.length) {
            currentSubListResource.add(
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
              ),
              dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
              ),
            );
          }

          return { currentSubListResource, listResource };
        },
        {
          currentSubListResource: null,
          listResource: resourceSet.mutableNamedResource({
            identifier: dataFactory.namedNode(
              `urn:shaclmate:list:${this.claims.reduce((_hasher, _item) => {
                _item.hash(_hasher);
                return _hasher;
              }, sha256.create())}`,
            ),
            mutateGraph,
          }),
        } as {
          currentSubListResource: rdfjsResource.MutableResource<rdfjs.NamedNode> | null;
          listResource: rdfjsResource.MutableResource<rdfjs.NamedNode>;
        },
      ).listResource.identifier,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.toJson());
  }
}

export namespace Answer {
  export function propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { claims: readonly Claim[]; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromJson>
    >
  > {
    const _jsonSafeParseResult = answerJsonZodSchema().safeParse(_json);
    if (!_jsonSafeParseResult.success) {
      return purify.Left(_jsonSafeParseResult.error);
    }

    const _jsonObject = _jsonSafeParseResult.data;
    const _super0Either =
      InformationContentEntity.propertiesFromJson(_jsonObject);
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    const claims = _jsonObject["claims"].map((_item) =>
      Claim.fromJson(_item).unsafeCoerce(),
    );
    const identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ..._super0, claims, identifier });
  }

  export function fromJson(json: unknown): purify.Either<zod.ZodError, Answer> {
    return Answer.propertiesFromJson(json).map(
      (properties) => new Answer(properties),
    );
  }

  export function propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { claims: readonly Claim[]; identifier: rdfjs.NamedNode } & UnwrapR<
      ReturnType<typeof InformationContentEntity.propertiesFromRdf>
    >
  > {
    const _super0Either = InformationContentEntity.propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if (_super0Either.isLeft()) {
      return _super0Either;
    }

    const _super0 = _super0Either.unsafeCoerce();
    if (
      !_ignoreRdfType &&
      !_resource.isInstanceOf(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#Answer",
        ),
      )
    ) {
      return purify.Left(
        new rdfjsResource.Resource.ValueError({
          focusResource: _resource,
          message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type`,
          predicate: dataFactory.namedNode(
            "http://purl.archive.org/purl/knextract/ontology#Answer",
          ),
        }),
      );
    }

    const _claimsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly Claim[]
    > = _resource
      .values(
        dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#claims",
        ),
        { unique: true },
      )
      .head()
      .chain((value) => value.toList())
      .map((values) =>
        values.flatMap((_value) =>
          _value
            .toValues()
            .head()
            .chain((value) => value.toNamedResource())
            .chain((_resource) =>
              Claim.fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
      );
    if (_claimsEither.isLeft()) {
      return _claimsEither;
    }

    const claims = _claimsEither.unsafeCoerce();
    const identifier = _resource.identifier;
    return purify.Either.of({ ..._super0, claims, identifier });
  }

  export function fromRdf(
    parameters: Parameters<typeof Answer.propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Answer> {
    return Answer.propertiesFromRdf(parameters).map(
      (properties) => new Answer(properties),
    );
  }

  export const fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://purl.archive.org/purl/knextract/ontology#Answer",
  );

  export function jsonSchema() {
    return zodToJsonSchema(answerJsonZodSchema());
  }

  export function answerJsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        InformationContentEntity.informationContentEntityJsonUiSchema({
          scopePrefix,
        }),
        Claim.claimJsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/claims`,
        }),
      ],
      label: "Answer",
      type: "Group",
    };
  }

  export function answerJsonZodSchema() {
    return InformationContentEntity.informationContentEntityJsonZodSchema().merge(
      zod.object({
        claims: Claim.claimJsonZodSchema().array(),
        "@id": zod.string().min(1),
        type: zod.literal("Answer"),
      }),
    );
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Answer.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Answer.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Answer.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("answer");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "answer");
    return [
      ...InformationContentEntity.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              subject,
              predicate: dataFactory.namedNode(
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
              ),
              object: dataFactory.variable!(`${variablePrefix}RdfType`),
            },
          ]),
      {
        object: dataFactory.variable!(`${variablePrefix}Claims`),
        predicate: dataFactory.namedNode(
          "http://purl.archive.org/purl/knextract/ontology#claims",
        ),
        subject,
      },
      {
        subject: dataFactory.variable!(`${variablePrefix}Claims`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Claims`}Item0`),
      },
      ...Claim.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Claims`}Item0`),
        variablePrefix: `${`${variablePrefix}Claims`}Item0`,
      }),
      {
        subject: dataFactory.variable!(`${variablePrefix}Claims`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Claims`}Rest0`),
      },
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Claims`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Claims`}ItemN`),
      },
      ...Claim.sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Claims`}ItemN`),
        variablePrefix: `${`${variablePrefix}Claims`}ItemN`,
      }),
      {
        subject: dataFactory.variable!(`${`${variablePrefix}Claims`}RestN`),
        predicate: dataFactory.namedNode(
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
        ),
        object: dataFactory.variable!(`${`${variablePrefix}Claims`}RestNBasic`),
      },
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const subject = parameters?.subject ?? dataFactory.variable!("answer");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "answer");
    return [
      ...InformationContentEntity.sparqlWherePatterns({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
      ...(parameters?.ignoreRdfType
        ? []
        : [
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.namedNode(
                    "http://purl.archive.org/purl/knextract/ontology#Answer",
                  ),
                },
              ],
              type: "bgp" as const,
            },
            {
              triples: [
                {
                  subject,
                  predicate: dataFactory.namedNode(
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                  ),
                  object: dataFactory.variable!(`${variablePrefix}RdfType`),
                },
              ],
              type: "bgp" as const,
            },
          ]),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Claims`),
            predicate: dataFactory.namedNode(
              "http://purl.archive.org/purl/knextract/ontology#claims",
            ),
            subject,
          },
        ],
        type: "bgp",
      },
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Claims`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Claims`}Item0`),
          },
        ],
      },
      ...Claim.sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${`${variablePrefix}Claims`}Item0`),
        variablePrefix: `${`${variablePrefix}Claims`}Item0`,
      }),
      {
        type: "bgp",
        triples: [
          {
            subject: dataFactory.variable!(`${variablePrefix}Claims`),
            predicate: dataFactory.namedNode(
              "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
            ),
            object: dataFactory.variable!(`${`${variablePrefix}Claims`}Rest0`),
          },
        ],
      },
      {
        type: "optional",
        patterns: [
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}Claims`),
                predicate: {
                  type: "path",
                  pathType: "*",
                  items: [
                    dataFactory.namedNode(
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                    ),
                  ],
                },
                object: dataFactory.variable!(
                  `${`${variablePrefix}Claims`}RestN`,
                ),
              },
            ],
          },
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Claims`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Claims`}ItemN`,
                ),
              },
            ],
          },
          ...Claim.sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${`${variablePrefix}Claims`}ItemN`),
            variablePrefix: `${`${variablePrefix}Claims`}ItemN`,
          }),
          {
            type: "bgp",
            triples: [
              {
                subject: dataFactory.variable!(
                  `${`${variablePrefix}Claims`}RestN`,
                ),
                predicate: dataFactory.namedNode(
                  "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
                ),
                object: dataFactory.variable!(
                  `${`${variablePrefix}Claims`}RestNBasic`,
                ),
              },
            ],
          },
        ],
      },
    ];
  }
}
export type PromptTemplateLike =
  | CompletionMessage
  | Prompt
  | PromptMessage
  | PromptMessageTemplate
  | PromptTemplate;

export namespace PromptTemplateLike {
  export function equals(
    left: PromptTemplateLike,
    right: PromptTemplateLike,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "CompletionMessage":
          return left.equals(right as unknown as CompletionMessage);
        case "Prompt":
          return left.equals(right as unknown as Prompt);
        case "PromptMessage":
          return left.equals(right as unknown as PromptMessage);
        case "PromptMessageTemplate":
          return left.equals(right as unknown as PromptMessageTemplate);
        case "PromptTemplate":
          return left.equals(right as unknown as PromptTemplate);
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptTemplateLike> {
    return (
      CompletionMessage.fromJson(json) as purify.Either<
        zod.ZodError,
        PromptTemplateLike
      >
    )
      .altLazy(
        () =>
          Prompt.fromJson(json) as purify.Either<
            zod.ZodError,
            PromptTemplateLike
          >,
      )
      .altLazy(
        () =>
          PromptMessage.fromJson(json) as purify.Either<
            zod.ZodError,
            PromptTemplateLike
          >,
      )
      .altLazy(
        () =>
          PromptMessageTemplate.fromJson(json) as purify.Either<
            zod.ZodError,
            PromptTemplateLike
          >,
      )
      .altLazy(
        () =>
          PromptTemplate.fromJson(json) as purify.Either<
            zod.ZodError,
            PromptTemplateLike
          >,
      );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, PromptTemplateLike> {
    return (
      CompletionMessage.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PromptTemplateLike
      >
    )
      .altLazy(
        () =>
          Prompt.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            PromptTemplateLike
          >,
      )
      .altLazy(
        () =>
          PromptMessage.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            PromptTemplateLike
          >,
      )
      .altLazy(
        () =>
          PromptMessageTemplate.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            PromptTemplateLike
          >,
      )
      .altLazy(
        () =>
          PromptTemplate.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            PromptTemplateLike
          >,
      );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_promptTemplateLike: PromptTemplateLike, _hasher: HasherT): HasherT {
    switch (_promptTemplateLike.type) {
      case "CompletionMessage":
        return _promptTemplateLike.hash(_hasher);
      case "Prompt":
        return _promptTemplateLike.hash(_hasher);
      case "PromptMessage":
        return _promptTemplateLike.hash(_hasher);
      case "PromptMessageTemplate":
        return _promptTemplateLike.hash(_hasher);
      case "PromptTemplate":
        return _promptTemplateLike.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      CompletionMessage.completionMessageJsonZodSchema(),
      Prompt.promptJsonZodSchema(),
      PromptMessage.promptMessageJsonZodSchema(),
      PromptMessageTemplate.promptMessageTemplateJsonZodSchema(),
      PromptTemplate.promptTemplateJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptTemplateLike.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptTemplateLike.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptTemplateLike.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...CompletionMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptTemplateLikeCompletionMessage"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}CompletionMessage`
          : "promptTemplateLikeCompletionMessage",
      }).concat(),
      ...Prompt.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptTemplateLikePrompt"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}Prompt`
          : "promptTemplateLikePrompt",
      }).concat(),
      ...PromptMessage.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptTemplateLikePromptMessage"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PromptMessage`
          : "promptTemplateLikePromptMessage",
      }).concat(),
      ...PromptMessageTemplate.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptTemplateLikePromptMessageTemplate"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PromptMessageTemplate`
          : "promptTemplateLikePromptMessageTemplate",
      }).concat(),
      ...PromptTemplate.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptTemplateLikePromptTemplate"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PromptTemplate`
          : "promptTemplateLikePromptTemplate",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: CompletionMessage.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("promptTemplateLikeCompletionMessage"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}CompletionMessage`
                : "promptTemplateLikeCompletionMessage",
            }).concat(),
            type: "group",
          },
          {
            patterns: Prompt.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("promptTemplateLikePrompt"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}Prompt`
                : "promptTemplateLikePrompt",
            }).concat(),
            type: "group",
          },
          {
            patterns: PromptMessage.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("promptTemplateLikePromptMessage"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PromptMessage`
                : "promptTemplateLikePromptMessage",
            }).concat(),
            type: "group",
          },
          {
            patterns: PromptMessageTemplate.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "promptTemplateLikePromptMessageTemplate",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PromptMessageTemplate`
                : "promptTemplateLikePromptMessageTemplate",
            }).concat(),
            type: "group",
          },
          {
            patterns: PromptTemplate.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("promptTemplateLikePromptTemplate"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PromptTemplate`
                : "promptTemplateLikePromptTemplate",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _promptTemplateLike: PromptTemplateLike,
  ):
    | ReturnType<CompletionMessage["toJson"]>
    | ReturnType<Prompt["toJson"]>
    | ReturnType<PromptMessage["toJson"]>
    | ReturnType<PromptMessageTemplate["toJson"]>
    | ReturnType<PromptTemplate["toJson"]> {
    switch (_promptTemplateLike.type) {
      case "CompletionMessage":
        return _promptTemplateLike.toJson();
      case "Prompt":
        return _promptTemplateLike.toJson();
      case "PromptMessage":
        return _promptTemplateLike.toJson();
      case "PromptMessageTemplate":
        return _promptTemplateLike.toJson();
      case "PromptTemplate":
        return _promptTemplateLike.toJson();
    }
  }

  export function toRdf(
    _promptTemplateLike: PromptTemplateLike,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_promptTemplateLike.type) {
      case "CompletionMessage":
        return _promptTemplateLike.toRdf(_parameters);
      case "Prompt":
        return _promptTemplateLike.toRdf(_parameters);
      case "PromptMessage":
        return _promptTemplateLike.toRdf(_parameters);
      case "PromptMessageTemplate":
        return _promptTemplateLike.toRdf(_parameters);
      case "PromptTemplate":
        return _promptTemplateLike.toRdf(_parameters);
    }
  }
}
export type ConceptSelector =
  | ConceptSchemeConceptSelector
  | ConceptSchemeTopConceptSelector
  | EnumeratedConceptSelector
  | NarrowerConceptSelector
  | NarrowerTransitiveConceptSelector;

export namespace ConceptSelector {
  export function equals(
    left: ConceptSelector,
    right: ConceptSelector,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "ConceptSchemeConceptSelector":
          return left.equals(right as unknown as ConceptSchemeConceptSelector);
        case "ConceptSchemeTopConceptSelector":
          return left.equals(
            right as unknown as ConceptSchemeTopConceptSelector,
          );
        case "EnumeratedConceptSelector":
          return left.equals(right as unknown as EnumeratedConceptSelector);
        case "NarrowerConceptSelector":
          return left.equals(right as unknown as NarrowerConceptSelector);
        case "NarrowerTransitiveConceptSelector":
          return left.equals(
            right as unknown as NarrowerTransitiveConceptSelector,
          );
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ConceptSelector> {
    return (
      ConceptSchemeConceptSelector.fromJson(json) as purify.Either<
        zod.ZodError,
        ConceptSelector
      >
    )
      .altLazy(
        () =>
          ConceptSchemeTopConceptSelector.fromJson(json) as purify.Either<
            zod.ZodError,
            ConceptSelector
          >,
      )
      .altLazy(
        () =>
          EnumeratedConceptSelector.fromJson(json) as purify.Either<
            zod.ZodError,
            ConceptSelector
          >,
      )
      .altLazy(
        () =>
          NarrowerConceptSelector.fromJson(json) as purify.Either<
            zod.ZodError,
            ConceptSelector
          >,
      )
      .altLazy(
        () =>
          NarrowerTransitiveConceptSelector.fromJson(json) as purify.Either<
            zod.ZodError,
            ConceptSelector
          >,
      );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, ConceptSelector> {
    return (
      ConceptSchemeConceptSelector.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ConceptSelector
      >
    )
      .altLazy(
        () =>
          ConceptSchemeTopConceptSelector.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ConceptSelector
          >,
      )
      .altLazy(
        () =>
          EnumeratedConceptSelector.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ConceptSelector
          >,
      )
      .altLazy(
        () =>
          NarrowerConceptSelector.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ConceptSelector
          >,
      )
      .altLazy(
        () =>
          NarrowerTransitiveConceptSelector.fromRdf(
            parameters,
          ) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ConceptSelector
          >,
      );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_conceptSelector: ConceptSelector, _hasher: HasherT): HasherT {
    switch (_conceptSelector.type) {
      case "ConceptSchemeConceptSelector":
        return _conceptSelector.hash(_hasher);
      case "ConceptSchemeTopConceptSelector":
        return _conceptSelector.hash(_hasher);
      case "EnumeratedConceptSelector":
        return _conceptSelector.hash(_hasher);
      case "NarrowerConceptSelector":
        return _conceptSelector.hash(_hasher);
      case "NarrowerTransitiveConceptSelector":
        return _conceptSelector.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      ConceptSchemeConceptSelector.conceptSchemeConceptSelectorJsonZodSchema(),
      ConceptSchemeTopConceptSelector.conceptSchemeTopConceptSelectorJsonZodSchema(),
      EnumeratedConceptSelector.enumeratedConceptSelectorJsonZodSchema(),
      NarrowerConceptSelector.narrowerConceptSelectorJsonZodSchema(),
      NarrowerTransitiveConceptSelector.narrowerTransitiveConceptSelectorJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ConceptSelector.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ConceptSelector.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ConceptSelector.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...ConceptSchemeConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("conceptSelectorConceptSchemeConceptSelector"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConceptSchemeConceptSelector`
          : "conceptSelectorConceptSchemeConceptSelector",
      }).concat(),
      ...ConceptSchemeTopConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "conceptSelectorConceptSchemeTopConceptSelector",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}ConceptSchemeTopConceptSelector`
          : "conceptSelectorConceptSchemeTopConceptSelector",
      }).concat(),
      ...EnumeratedConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("conceptSelectorEnumeratedConceptSelector"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}EnumeratedConceptSelector`
          : "conceptSelectorEnumeratedConceptSelector",
      }).concat(),
      ...NarrowerConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("conceptSelectorNarrowerConceptSelector"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NarrowerConceptSelector`
          : "conceptSelectorNarrowerConceptSelector",
      }).concat(),
      ...NarrowerTransitiveConceptSelector.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "conceptSelectorNarrowerTransitiveConceptSelector",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}NarrowerTransitiveConceptSelector`
          : "conceptSelectorNarrowerTransitiveConceptSelector",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: ConceptSchemeConceptSelector.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "conceptSelectorConceptSchemeConceptSelector",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ConceptSchemeConceptSelector`
                : "conceptSelectorConceptSchemeConceptSelector",
            }).concat(),
            type: "group",
          },
          {
            patterns: ConceptSchemeTopConceptSelector.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "conceptSelectorConceptSchemeTopConceptSelector",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}ConceptSchemeTopConceptSelector`
                : "conceptSelectorConceptSchemeTopConceptSelector",
            }).concat(),
            type: "group",
          },
          {
            patterns: EnumeratedConceptSelector.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "conceptSelectorEnumeratedConceptSelector",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}EnumeratedConceptSelector`
                : "conceptSelectorEnumeratedConceptSelector",
            }).concat(),
            type: "group",
          },
          {
            patterns: NarrowerConceptSelector.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("conceptSelectorNarrowerConceptSelector"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}NarrowerConceptSelector`
                : "conceptSelectorNarrowerConceptSelector",
            }).concat(),
            type: "group",
          },
          {
            patterns: NarrowerTransitiveConceptSelector.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "conceptSelectorNarrowerTransitiveConceptSelector",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}NarrowerTransitiveConceptSelector`
                : "conceptSelectorNarrowerTransitiveConceptSelector",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _conceptSelector: ConceptSelector,
  ):
    | ReturnType<ConceptSchemeConceptSelector["toJson"]>
    | ReturnType<ConceptSchemeTopConceptSelector["toJson"]>
    | ReturnType<EnumeratedConceptSelector["toJson"]>
    | ReturnType<NarrowerConceptSelector["toJson"]>
    | ReturnType<NarrowerTransitiveConceptSelector["toJson"]> {
    switch (_conceptSelector.type) {
      case "ConceptSchemeConceptSelector":
        return _conceptSelector.toJson();
      case "ConceptSchemeTopConceptSelector":
        return _conceptSelector.toJson();
      case "EnumeratedConceptSelector":
        return _conceptSelector.toJson();
      case "NarrowerConceptSelector":
        return _conceptSelector.toJson();
      case "NarrowerTransitiveConceptSelector":
        return _conceptSelector.toJson();
    }
  }

  export function toRdf(
    _conceptSelector: ConceptSelector,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_conceptSelector.type) {
      case "ConceptSchemeConceptSelector":
        return _conceptSelector.toRdf(_parameters);
      case "ConceptSchemeTopConceptSelector":
        return _conceptSelector.toRdf(_parameters);
      case "EnumeratedConceptSelector":
        return _conceptSelector.toRdf(_parameters);
      case "NarrowerConceptSelector":
        return _conceptSelector.toRdf(_parameters);
      case "NarrowerTransitiveConceptSelector":
        return _conceptSelector.toRdf(_parameters);
    }
  }
}
export type Value = BooleanValue | CategoricalValue | RealValue | TextValue;

export namespace Value {
  export function equals(left: Value, right: Value): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "BooleanValue":
          return left.equals(right as unknown as BooleanValue);
        case "CategoricalValue":
          return left.equals(right as unknown as CategoricalValue);
        case "RealValue":
          return left.equals(right as unknown as RealValue);
        case "TextValue":
          return left.equals(right as unknown as TextValue);
      }
    });
  }

  export function fromJson(json: unknown): purify.Either<zod.ZodError, Value> {
    return (BooleanValue.fromJson(json) as purify.Either<zod.ZodError, Value>)
      .altLazy(
        () =>
          CategoricalValue.fromJson(json) as purify.Either<zod.ZodError, Value>,
      )
      .altLazy(
        () => RealValue.fromJson(json) as purify.Either<zod.ZodError, Value>,
      )
      .altLazy(
        () => TextValue.fromJson(json) as purify.Either<zod.ZodError, Value>,
      );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, Value> {
    return (
      BooleanValue.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Value
      >
    )
      .altLazy(
        () =>
          CategoricalValue.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Value
          >,
      )
      .altLazy(
        () =>
          RealValue.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Value
          >,
      )
      .altLazy(
        () =>
          TextValue.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Value
          >,
      );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_value: Value, _hasher: HasherT): HasherT {
    switch (_value.type) {
      case "BooleanValue":
        return _value.hash(_hasher);
      case "CategoricalValue":
        return _value.hash(_hasher);
      case "RealValue":
        return _value.hash(_hasher);
      case "TextValue":
        return _value.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      BooleanValue.booleanValueJsonZodSchema(),
      CategoricalValue.categoricalValueJsonZodSchema(),
      RealValue.realValueJsonZodSchema(),
      TextValue.textValueJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Value.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Value.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Value.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...BooleanValue.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ?? dataFactory.variable!("valueBooleanValue"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}BooleanValue`
          : "valueBooleanValue",
      }).concat(),
      ...CategoricalValue.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ?? dataFactory.variable!("valueCategoricalValue"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}CategoricalValue`
          : "valueCategoricalValue",
      }).concat(),
      ...RealValue.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject: parameters.subject ?? dataFactory.variable!("valueRealValue"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RealValue`
          : "valueRealValue",
      }).concat(),
      ...TextValue.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject: parameters.subject ?? dataFactory.variable!("valueTextValue"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}TextValue`
          : "valueTextValue",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: BooleanValue.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("valueBooleanValue"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}BooleanValue`
                : "valueBooleanValue",
            }).concat(),
            type: "group",
          },
          {
            patterns: CategoricalValue.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("valueCategoricalValue"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}CategoricalValue`
                : "valueCategoricalValue",
            }).concat(),
            type: "group",
          },
          {
            patterns: RealValue.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ?? dataFactory.variable!("valueRealValue"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RealValue`
                : "valueRealValue",
            }).concat(),
            type: "group",
          },
          {
            patterns: TextValue.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ?? dataFactory.variable!("valueTextValue"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}TextValue`
                : "valueTextValue",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _value: Value,
  ):
    | ReturnType<BooleanValue["toJson"]>
    | ReturnType<CategoricalValue["toJson"]>
    | ReturnType<RealValue["toJson"]>
    | ReturnType<TextValue["toJson"]> {
    switch (_value.type) {
      case "BooleanValue":
        return _value.toJson();
      case "CategoricalValue":
        return _value.toJson();
      case "RealValue":
        return _value.toJson();
      case "TextValue":
        return _value.toJson();
    }
  }

  export function toRdf(
    _value: Value,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_value.type) {
      case "BooleanValue":
        return _value.toRdf(_parameters);
      case "CategoricalValue":
        return _value.toRdf(_parameters);
      case "RealValue":
        return _value.toRdf(_parameters);
      case "TextValue":
        return _value.toRdf(_parameters);
    }
  }
}
export type WorkflowStepExecution = WorkflowQuestionnaireStepExecution;

export namespace WorkflowStepExecution {
  export function equals(
    left: WorkflowStepExecution,
    right: WorkflowStepExecution,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "WorkflowQuestionnaireStepExecution":
          return left.equals(
            right as unknown as WorkflowQuestionnaireStepExecution,
          );
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowStepExecution> {
    return WorkflowQuestionnaireStepExecution.fromJson(json) as purify.Either<
      zod.ZodError,
      WorkflowStepExecution
    >;
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, WorkflowStepExecution> {
    return WorkflowQuestionnaireStepExecution.fromRdf(
      parameters,
    ) as purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStepExecution
    >;
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_workflowStepExecution: WorkflowStepExecution, _hasher: HasherT): HasherT {
    switch (_workflowStepExecution.type) {
      case "WorkflowQuestionnaireStepExecution":
        return _workflowStepExecution.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      WorkflowQuestionnaireStepExecution.workflowQuestionnaireStepExecutionJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowStepExecution.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowStepExecution.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowStepExecution.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...WorkflowQuestionnaireStepExecution.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "workflowStepExecutionWorkflowQuestionnaireStepExecution",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}WorkflowQuestionnaireStepExecution`
          : "workflowStepExecutionWorkflowQuestionnaireStepExecution",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: WorkflowQuestionnaireStepExecution.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "workflowStepExecutionWorkflowQuestionnaireStepExecution",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}WorkflowQuestionnaireStepExecution`
                : "workflowStepExecutionWorkflowQuestionnaireStepExecution",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _workflowStepExecution: WorkflowStepExecution,
  ): ReturnType<WorkflowQuestionnaireStepExecution["toJson"]> {
    switch (_workflowStepExecution.type) {
      case "WorkflowQuestionnaireStepExecution":
        return _workflowStepExecution.toJson();
    }
  }

  export function toRdf(
    _workflowStepExecution: WorkflowStepExecution,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_workflowStepExecution.type) {
      case "WorkflowQuestionnaireStepExecution":
        return _workflowStepExecution.toRdf(_parameters);
    }
  }
}
export type WorkflowStepExecutionInput =
  WorkflowQuestionnaireStepExecutionInput;

export namespace WorkflowStepExecutionInput {
  export function equals(
    left: WorkflowStepExecutionInput,
    right: WorkflowStepExecutionInput,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "WorkflowQuestionnaireStepExecutionInput":
          return left.equals(
            right as unknown as WorkflowQuestionnaireStepExecutionInput,
          );
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowStepExecutionInput> {
    return WorkflowQuestionnaireStepExecutionInput.fromJson(
      json,
    ) as purify.Either<zod.ZodError, WorkflowStepExecutionInput>;
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    WorkflowStepExecutionInput
  > {
    return WorkflowQuestionnaireStepExecutionInput.fromRdf(
      parameters,
    ) as purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStepExecutionInput
    >;
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _workflowStepExecutionInput: WorkflowStepExecutionInput,
    _hasher: HasherT,
  ): HasherT {
    switch (_workflowStepExecutionInput.type) {
      case "WorkflowQuestionnaireStepExecutionInput":
        return _workflowStepExecutionInput.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      WorkflowQuestionnaireStepExecutionInput.workflowQuestionnaireStepExecutionInputJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowStepExecutionInput.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowStepExecutionInput.sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowStepExecutionInput.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...WorkflowQuestionnaireStepExecutionInput.sparqlConstructTemplateTriples(
        {
          ignoreRdfType: parameters?.ignoreRdfType,
          subject:
            parameters.subject ??
            dataFactory.variable!(
              "workflowStepExecutionInputWorkflowQuestionnaireStepExecutionInput",
            ),
          variablePrefix: parameters?.variablePrefix
            ? `${parameters.variablePrefix}WorkflowQuestionnaireStepExecutionInput`
            : "workflowStepExecutionInputWorkflowQuestionnaireStepExecutionInput",
        },
      ).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns:
              WorkflowQuestionnaireStepExecutionInput.sparqlWherePatterns({
                ignoreRdfType: parameters?.ignoreRdfType,
                subject:
                  parameters.subject ??
                  dataFactory.variable!(
                    "workflowStepExecutionInputWorkflowQuestionnaireStepExecutionInput",
                  ),
                variablePrefix: parameters?.variablePrefix
                  ? `${parameters.variablePrefix}WorkflowQuestionnaireStepExecutionInput`
                  : "workflowStepExecutionInputWorkflowQuestionnaireStepExecutionInput",
              }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _workflowStepExecutionInput: WorkflowStepExecutionInput,
  ): ReturnType<WorkflowQuestionnaireStepExecutionInput["toJson"]> {
    switch (_workflowStepExecutionInput.type) {
      case "WorkflowQuestionnaireStepExecutionInput":
        return _workflowStepExecutionInput.toJson();
    }
  }

  export function toRdf(
    _workflowStepExecutionInput: WorkflowStepExecutionInput,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_workflowStepExecutionInput.type) {
      case "WorkflowQuestionnaireStepExecutionInput":
        return _workflowStepExecutionInput.toRdf(_parameters);
    }
  }
}
export type Question =
  | CategoricalQuestion
  | DichotomousQuestion
  | RealValuedQuestion
  | TextQuestion;

export namespace Question {
  export function equals(left: Question, right: Question): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "CategoricalQuestion":
          return left.equals(right as unknown as CategoricalQuestion);
        case "DichotomousQuestion":
          return left.equals(right as unknown as DichotomousQuestion);
        case "RealValuedQuestion":
          return left.equals(right as unknown as RealValuedQuestion);
        case "TextQuestion":
          return left.equals(right as unknown as TextQuestion);
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Question> {
    return (
      CategoricalQuestion.fromJson(json) as purify.Either<
        zod.ZodError,
        Question
      >
    )
      .altLazy(
        () =>
          DichotomousQuestion.fromJson(json) as purify.Either<
            zod.ZodError,
            Question
          >,
      )
      .altLazy(
        () =>
          RealValuedQuestion.fromJson(json) as purify.Either<
            zod.ZodError,
            Question
          >,
      )
      .altLazy(
        () =>
          TextQuestion.fromJson(json) as purify.Either<zod.ZodError, Question>,
      );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, Question> {
    return (
      CategoricalQuestion.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Question
      >
    )
      .altLazy(
        () =>
          DichotomousQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Question
          >,
      )
      .altLazy(
        () =>
          RealValuedQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Question
          >,
      )
      .altLazy(
        () =>
          TextQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Question
          >,
      );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_question: Question, _hasher: HasherT): HasherT {
    switch (_question.type) {
      case "CategoricalQuestion":
        return _question.hash(_hasher);
      case "DichotomousQuestion":
        return _question.hash(_hasher);
      case "RealValuedQuestion":
        return _question.hash(_hasher);
      case "TextQuestion":
        return _question.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      CategoricalQuestion.categoricalQuestionJsonZodSchema(),
      DichotomousQuestion.dichotomousQuestionJsonZodSchema(),
      RealValuedQuestion.realValuedQuestionJsonZodSchema(),
      TextQuestion.textQuestionJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Question.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Question.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Question.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...CategoricalQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionCategoricalQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}CategoricalQuestion`
          : "questionCategoricalQuestion",
      }).concat(),
      ...DichotomousQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionDichotomousQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DichotomousQuestion`
          : "questionDichotomousQuestion",
      }).concat(),
      ...RealValuedQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionRealValuedQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RealValuedQuestion`
          : "questionRealValuedQuestion",
      }).concat(),
      ...TextQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ?? dataFactory.variable!("questionTextQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}TextQuestion`
          : "questionTextQuestion",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: CategoricalQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionCategoricalQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}CategoricalQuestion`
                : "questionCategoricalQuestion",
            }).concat(),
            type: "group",
          },
          {
            patterns: DichotomousQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionDichotomousQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}DichotomousQuestion`
                : "questionDichotomousQuestion",
            }).concat(),
            type: "group",
          },
          {
            patterns: RealValuedQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionRealValuedQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RealValuedQuestion`
                : "questionRealValuedQuestion",
            }).concat(),
            type: "group",
          },
          {
            patterns: TextQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionTextQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}TextQuestion`
                : "questionTextQuestion",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _question: Question,
  ):
    | ReturnType<CategoricalQuestion["toJson"]>
    | ReturnType<DichotomousQuestion["toJson"]>
    | ReturnType<RealValuedQuestion["toJson"]>
    | ReturnType<TextQuestion["toJson"]> {
    switch (_question.type) {
      case "CategoricalQuestion":
        return _question.toJson();
      case "DichotomousQuestion":
        return _question.toJson();
      case "RealValuedQuestion":
        return _question.toJson();
      case "TextQuestion":
        return _question.toJson();
    }
  }

  export function toRdf(
    _question: Question,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_question.type) {
      case "CategoricalQuestion":
        return _question.toRdf(_parameters);
      case "DichotomousQuestion":
        return _question.toRdf(_parameters);
      case "RealValuedQuestion":
        return _question.toRdf(_parameters);
      case "TextQuestion":
        return _question.toRdf(_parameters);
    }
  }
}
export type PromptInputValue =
  | PromptLiteralInputValue
  | PromptSparqlSelectInputValue;

export namespace PromptInputValue {
  export function equals(
    left: PromptInputValue,
    right: PromptInputValue,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "PromptLiteralInputValue":
          return left.equals(right as unknown as PromptLiteralInputValue);
        case "PromptSparqlSelectInputValue":
          return left.equals(right as unknown as PromptSparqlSelectInputValue);
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PromptInputValue> {
    return (
      PromptLiteralInputValue.fromJson(json) as purify.Either<
        zod.ZodError,
        PromptInputValue
      >
    ).altLazy(
      () =>
        PromptSparqlSelectInputValue.fromJson(json) as purify.Either<
          zod.ZodError,
          PromptInputValue
        >,
    );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, PromptInputValue> {
    return (
      PromptLiteralInputValue.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PromptInputValue
      >
    ).altLazy(
      () =>
        PromptSparqlSelectInputValue.fromRdf(parameters) as purify.Either<
          rdfjsResource.Resource.ValueError,
          PromptInputValue
        >,
    );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_promptInputValue: PromptInputValue, _hasher: HasherT): HasherT {
    switch (_promptInputValue.type) {
      case "PromptLiteralInputValue":
        return _promptInputValue.hash(_hasher);
      case "PromptSparqlSelectInputValue":
        return _promptInputValue.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      PromptLiteralInputValue.promptLiteralInputValueJsonZodSchema(),
      PromptSparqlSelectInputValue.promptSparqlSelectInputValueJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PromptInputValue.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PromptInputValue.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PromptInputValue.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PromptLiteralInputValue.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptInputValuePromptLiteralInputValue"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PromptLiteralInputValue`
          : "promptInputValuePromptLiteralInputValue",
      }).concat(),
      ...PromptSparqlSelectInputValue.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("promptInputValuePromptSparqlSelectInputValue"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PromptSparqlSelectInputValue`
          : "promptInputValuePromptSparqlSelectInputValue",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: PromptLiteralInputValue.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "promptInputValuePromptLiteralInputValue",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PromptLiteralInputValue`
                : "promptInputValuePromptLiteralInputValue",
            }).concat(),
            type: "group",
          },
          {
            patterns: PromptSparqlSelectInputValue.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "promptInputValuePromptSparqlSelectInputValue",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PromptSparqlSelectInputValue`
                : "promptInputValuePromptSparqlSelectInputValue",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _promptInputValue: PromptInputValue,
  ):
    | ReturnType<PromptLiteralInputValue["toJson"]>
    | ReturnType<PromptSparqlSelectInputValue["toJson"]> {
    switch (_promptInputValue.type) {
      case "PromptLiteralInputValue":
        return _promptInputValue.toJson();
      case "PromptSparqlSelectInputValue":
        return _promptInputValue.toJson();
    }
  }

  export function toRdf(
    _promptInputValue: PromptInputValue,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_promptInputValue.type) {
      case "PromptLiteralInputValue":
        return _promptInputValue.toRdf(_parameters);
      case "PromptSparqlSelectInputValue":
        return _promptInputValue.toRdf(_parameters);
    }
  }
}
export type QuestionnaireMember =
  | Instruction
  | CategoricalQuestion
  | DichotomousQuestion
  | RealValuedQuestion
  | TextQuestion;

export namespace QuestionnaireMember {
  export function equals(
    left: QuestionnaireMember,
    right: QuestionnaireMember,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "Instruction":
          return left.equals(right as unknown as Instruction);
        case "CategoricalQuestion":
          return left.equals(right as unknown as CategoricalQuestion);
        case "DichotomousQuestion":
          return left.equals(right as unknown as DichotomousQuestion);
        case "RealValuedQuestion":
          return left.equals(right as unknown as RealValuedQuestion);
        case "TextQuestion":
          return left.equals(right as unknown as TextQuestion);
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuestionnaireMember> {
    return (
      Instruction.fromJson(json) as purify.Either<
        zod.ZodError,
        QuestionnaireMember
      >
    )
      .altLazy(
        () =>
          CategoricalQuestion.fromJson(json) as purify.Either<
            zod.ZodError,
            QuestionnaireMember
          >,
      )
      .altLazy(
        () =>
          DichotomousQuestion.fromJson(json) as purify.Either<
            zod.ZodError,
            QuestionnaireMember
          >,
      )
      .altLazy(
        () =>
          RealValuedQuestion.fromJson(json) as purify.Either<
            zod.ZodError,
            QuestionnaireMember
          >,
      )
      .altLazy(
        () =>
          TextQuestion.fromJson(json) as purify.Either<
            zod.ZodError,
            QuestionnaireMember
          >,
      );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, QuestionnaireMember> {
    return (
      Instruction.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        QuestionnaireMember
      >
    )
      .altLazy(
        () =>
          CategoricalQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            QuestionnaireMember
          >,
      )
      .altLazy(
        () =>
          DichotomousQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            QuestionnaireMember
          >,
      )
      .altLazy(
        () =>
          RealValuedQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            QuestionnaireMember
          >,
      )
      .altLazy(
        () =>
          TextQuestion.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            QuestionnaireMember
          >,
      );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_questionnaireMember: QuestionnaireMember, _hasher: HasherT): HasherT {
    switch (_questionnaireMember.type) {
      case "Instruction":
        return _questionnaireMember.hash(_hasher);
      case "CategoricalQuestion":
        return _questionnaireMember.hash(_hasher);
      case "DichotomousQuestion":
        return _questionnaireMember.hash(_hasher);
      case "RealValuedQuestion":
        return _questionnaireMember.hash(_hasher);
      case "TextQuestion":
        return _questionnaireMember.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      Instruction.instructionJsonZodSchema(),
      CategoricalQuestion.categoricalQuestionJsonZodSchema(),
      DichotomousQuestion.dichotomousQuestionJsonZodSchema(),
      RealValuedQuestion.realValuedQuestionJsonZodSchema(),
      TextQuestion.textQuestionJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuestionnaireMember.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuestionnaireMember.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuestionnaireMember.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...Instruction.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionnaireMemberInstruction"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}Instruction`
          : "questionnaireMemberInstruction",
      }).concat(),
      ...CategoricalQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionnaireMemberCategoricalQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}CategoricalQuestion`
          : "questionnaireMemberCategoricalQuestion",
      }).concat(),
      ...DichotomousQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionnaireMemberDichotomousQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}DichotomousQuestion`
          : "questionnaireMemberDichotomousQuestion",
      }).concat(),
      ...RealValuedQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionnaireMemberRealValuedQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}RealValuedQuestion`
          : "questionnaireMemberRealValuedQuestion",
      }).concat(),
      ...TextQuestion.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("questionnaireMemberTextQuestion"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}TextQuestion`
          : "questionnaireMemberTextQuestion",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: Instruction.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionnaireMemberInstruction"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}Instruction`
                : "questionnaireMemberInstruction",
            }).concat(),
            type: "group",
          },
          {
            patterns: CategoricalQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionnaireMemberCategoricalQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}CategoricalQuestion`
                : "questionnaireMemberCategoricalQuestion",
            }).concat(),
            type: "group",
          },
          {
            patterns: DichotomousQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionnaireMemberDichotomousQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}DichotomousQuestion`
                : "questionnaireMemberDichotomousQuestion",
            }).concat(),
            type: "group",
          },
          {
            patterns: RealValuedQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionnaireMemberRealValuedQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}RealValuedQuestion`
                : "questionnaireMemberRealValuedQuestion",
            }).concat(),
            type: "group",
          },
          {
            patterns: TextQuestion.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("questionnaireMemberTextQuestion"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}TextQuestion`
                : "questionnaireMemberTextQuestion",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _questionnaireMember: QuestionnaireMember,
  ):
    | ReturnType<Instruction["toJson"]>
    | ReturnType<CategoricalQuestion["toJson"]>
    | ReturnType<DichotomousQuestion["toJson"]>
    | ReturnType<RealValuedQuestion["toJson"]>
    | ReturnType<TextQuestion["toJson"]> {
    switch (_questionnaireMember.type) {
      case "Instruction":
        return _questionnaireMember.toJson();
      case "CategoricalQuestion":
        return _questionnaireMember.toJson();
      case "DichotomousQuestion":
        return _questionnaireMember.toJson();
      case "RealValuedQuestion":
        return _questionnaireMember.toJson();
      case "TextQuestion":
        return _questionnaireMember.toJson();
    }
  }

  export function toRdf(
    _questionnaireMember: QuestionnaireMember,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_questionnaireMember.type) {
      case "Instruction":
        return _questionnaireMember.toRdf(_parameters);
      case "CategoricalQuestion":
        return _questionnaireMember.toRdf(_parameters);
      case "DichotomousQuestion":
        return _questionnaireMember.toRdf(_parameters);
      case "RealValuedQuestion":
        return _questionnaireMember.toRdf(_parameters);
      case "TextQuestion":
        return _questionnaireMember.toRdf(_parameters);
    }
  }
}
export type WorkflowExecutionEvent =
  | PostWorkflowExecutionEvent
  | PostWorkflowStepExecutionEvent
  | PreWorkflowExecutionEvent
  | PreWorkflowStepExecutionEvent;

export namespace WorkflowExecutionEvent {
  export function equals(
    left: WorkflowExecutionEvent,
    right: WorkflowExecutionEvent,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "PostWorkflowExecutionEvent":
          return left.equals(right as unknown as PostWorkflowExecutionEvent);
        case "PostWorkflowStepExecutionEvent":
          return left.equals(
            right as unknown as PostWorkflowStepExecutionEvent,
          );
        case "PreWorkflowExecutionEvent":
          return left.equals(right as unknown as PreWorkflowExecutionEvent);
        case "PreWorkflowStepExecutionEvent":
          return left.equals(right as unknown as PreWorkflowStepExecutionEvent);
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowExecutionEvent> {
    return (
      PostWorkflowExecutionEvent.fromJson(json) as purify.Either<
        zod.ZodError,
        WorkflowExecutionEvent
      >
    )
      .altLazy(
        () =>
          PostWorkflowStepExecutionEvent.fromJson(json) as purify.Either<
            zod.ZodError,
            WorkflowExecutionEvent
          >,
      )
      .altLazy(
        () =>
          PreWorkflowExecutionEvent.fromJson(json) as purify.Either<
            zod.ZodError,
            WorkflowExecutionEvent
          >,
      )
      .altLazy(
        () =>
          PreWorkflowStepExecutionEvent.fromJson(json) as purify.Either<
            zod.ZodError,
            WorkflowExecutionEvent
          >,
      );
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, WorkflowExecutionEvent> {
    return (
      PostWorkflowExecutionEvent.fromRdf(parameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        WorkflowExecutionEvent
      >
    )
      .altLazy(
        () =>
          PostWorkflowStepExecutionEvent.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            WorkflowExecutionEvent
          >,
      )
      .altLazy(
        () =>
          PreWorkflowExecutionEvent.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            WorkflowExecutionEvent
          >,
      )
      .altLazy(
        () =>
          PreWorkflowStepExecutionEvent.fromRdf(parameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            WorkflowExecutionEvent
          >,
      );
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(
    _workflowExecutionEvent: WorkflowExecutionEvent,
    _hasher: HasherT,
  ): HasherT {
    switch (_workflowExecutionEvent.type) {
      case "PostWorkflowExecutionEvent":
        return _workflowExecutionEvent.hash(_hasher);
      case "PostWorkflowStepExecutionEvent":
        return _workflowExecutionEvent.hash(_hasher);
      case "PreWorkflowExecutionEvent":
        return _workflowExecutionEvent.hash(_hasher);
      case "PreWorkflowStepExecutionEvent":
        return _workflowExecutionEvent.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      PostWorkflowExecutionEvent.postWorkflowExecutionEventJsonZodSchema(),
      PostWorkflowStepExecutionEvent.postWorkflowStepExecutionEventJsonZodSchema(),
      PreWorkflowExecutionEvent.preWorkflowExecutionEventJsonZodSchema(),
      PreWorkflowStepExecutionEvent.preWorkflowStepExecutionEventJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowExecutionEvent.sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowExecutionEvent.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowExecutionEvent.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...PostWorkflowExecutionEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "workflowExecutionEventPostWorkflowExecutionEvent",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PostWorkflowExecutionEvent`
          : "workflowExecutionEventPostWorkflowExecutionEvent",
      }).concat(),
      ...PostWorkflowStepExecutionEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "workflowExecutionEventPostWorkflowStepExecutionEvent",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PostWorkflowStepExecutionEvent`
          : "workflowExecutionEventPostWorkflowStepExecutionEvent",
      }).concat(),
      ...PreWorkflowExecutionEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "workflowExecutionEventPreWorkflowExecutionEvent",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PreWorkflowExecutionEvent`
          : "workflowExecutionEventPreWorkflowExecutionEvent",
      }).concat(),
      ...PreWorkflowStepExecutionEvent.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!(
            "workflowExecutionEventPreWorkflowStepExecutionEvent",
          ),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PreWorkflowStepExecutionEvent`
          : "workflowExecutionEventPreWorkflowStepExecutionEvent",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: PostWorkflowExecutionEvent.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "workflowExecutionEventPostWorkflowExecutionEvent",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PostWorkflowExecutionEvent`
                : "workflowExecutionEventPostWorkflowExecutionEvent",
            }).concat(),
            type: "group",
          },
          {
            patterns: PostWorkflowStepExecutionEvent.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "workflowExecutionEventPostWorkflowStepExecutionEvent",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PostWorkflowStepExecutionEvent`
                : "workflowExecutionEventPostWorkflowStepExecutionEvent",
            }).concat(),
            type: "group",
          },
          {
            patterns: PreWorkflowExecutionEvent.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "workflowExecutionEventPreWorkflowExecutionEvent",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PreWorkflowExecutionEvent`
                : "workflowExecutionEventPreWorkflowExecutionEvent",
            }).concat(),
            type: "group",
          },
          {
            patterns: PreWorkflowStepExecutionEvent.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!(
                  "workflowExecutionEventPreWorkflowStepExecutionEvent",
                ),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PreWorkflowStepExecutionEvent`
                : "workflowExecutionEventPreWorkflowStepExecutionEvent",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _workflowExecutionEvent: WorkflowExecutionEvent,
  ):
    | ReturnType<PostWorkflowExecutionEvent["toJson"]>
    | ReturnType<PostWorkflowStepExecutionEvent["toJson"]>
    | ReturnType<PreWorkflowExecutionEvent["toJson"]>
    | ReturnType<PreWorkflowStepExecutionEvent["toJson"]> {
    switch (_workflowExecutionEvent.type) {
      case "PostWorkflowExecutionEvent":
        return _workflowExecutionEvent.toJson();
      case "PostWorkflowStepExecutionEvent":
        return _workflowExecutionEvent.toJson();
      case "PreWorkflowExecutionEvent":
        return _workflowExecutionEvent.toJson();
      case "PreWorkflowStepExecutionEvent":
        return _workflowExecutionEvent.toJson();
    }
  }

  export function toRdf(
    _workflowExecutionEvent: WorkflowExecutionEvent,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_workflowExecutionEvent.type) {
      case "PostWorkflowExecutionEvent":
        return _workflowExecutionEvent.toRdf(_parameters);
      case "PostWorkflowStepExecutionEvent":
        return _workflowExecutionEvent.toRdf(_parameters);
      case "PreWorkflowExecutionEvent":
        return _workflowExecutionEvent.toRdf(_parameters);
      case "PreWorkflowStepExecutionEvent":
        return _workflowExecutionEvent.toRdf(_parameters);
    }
  }
}
export type WorkflowStep = WorkflowQuestionnaireStep;

export namespace WorkflowStep {
  export function equals(
    left: WorkflowStep,
    right: WorkflowStep,
  ): EqualsResult {
    return strictEquals(left.type, right.type).chain(() => {
      switch (left.type) {
        case "WorkflowQuestionnaireStep":
          return left.equals(right as unknown as WorkflowQuestionnaireStep);
      }
    });
  }

  export function fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, WorkflowStep> {
    return WorkflowQuestionnaireStep.fromJson(json) as purify.Either<
      zod.ZodError,
      WorkflowStep
    >;
  }

  export function fromRdf(parameters: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource<rdfjs.NamedNode>;
  }): purify.Either<rdfjsResource.Resource.ValueError, WorkflowStep> {
    return WorkflowQuestionnaireStep.fromRdf(parameters) as purify.Either<
      rdfjsResource.Resource.ValueError,
      WorkflowStep
    >;
  }

  export function hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_workflowStep: WorkflowStep, _hasher: HasherT): HasherT {
    switch (_workflowStep.type) {
      case "WorkflowQuestionnaireStep":
        return _workflowStep.hash(_hasher);
    }
  }

  export function jsonZodSchema() {
    return zod.discriminatedUnion("type", [
      WorkflowQuestionnaireStep.workflowQuestionnaireStepJsonZodSchema(),
    ]);
  }

  export function sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        WorkflowStep.sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        WorkflowStep.sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      WorkflowStep.sparqlConstructQuery(parameters),
    );
  }

  export function sparqlConstructTemplateTriples(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...WorkflowQuestionnaireStep.sparqlConstructTemplateTriples({
        ignoreRdfType: parameters?.ignoreRdfType,
        subject:
          parameters.subject ??
          dataFactory.variable!("workflowStepWorkflowQuestionnaireStep"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}WorkflowQuestionnaireStep`
          : "workflowStepWorkflowQuestionnaireStep",
      }).concat(),
    ];
  }

  export function sparqlWherePatterns(parameters: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: WorkflowQuestionnaireStep.sparqlWherePatterns({
              ignoreRdfType: parameters?.ignoreRdfType,
              subject:
                parameters.subject ??
                dataFactory.variable!("workflowStepWorkflowQuestionnaireStep"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}WorkflowQuestionnaireStep`
                : "workflowStepWorkflowQuestionnaireStep",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function toJson(
    _workflowStep: WorkflowStep,
  ): ReturnType<WorkflowQuestionnaireStep["toJson"]> {
    switch (_workflowStep.type) {
      case "WorkflowQuestionnaireStep":
        return _workflowStep.toJson();
    }
  }

  export function toRdf(
    _workflowStep: WorkflowStep,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource<rdfjs.NamedNode> {
    switch (_workflowStep.type) {
      case "WorkflowQuestionnaireStep":
        return _workflowStep.toRdf(_parameters);
    }
  }
}
